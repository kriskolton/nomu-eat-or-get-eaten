const { ObjectId } = require("mongodb");
const config = require("../config");

// Re-use the existing DB connection initialiser so we do **not** open
// multiple MongoClient instances.
const { initDB } = require("./scoreRepository");
const crypto = require("crypto");

// ──────────────────────────────────────────────────────────────────────
// Configuration & constants
// ──────────────────────────────────────────────────────────────────────

// After this period (in minutes) the session is considered invalid and
// must be recreated by the client.
const SESSION_TTL_MINUTES = 90;

// Hard cap on a single run – a 20-minute game is already **extremely**
// long.  Used when validating the replay payload from the client.
const MAX_EXPECTED_DURATION_MS = 20 * 60 * 1000; // 20 minutes

// ──────────────────────────────────────────────────────────────────────
// Public API
// ──────────────────────────────────────────────────────────────────────

/**
 * Create a *single* game session for a user.  The function returns both the
 * `sessionId` (back-end identifier) and the randomly generated RNG `seed`
 * that the **client** must use for Math.seedrandom.
 *
 * @param {string|number} userId – Telegram user id
 * @param {string=} event       – season / event name (defaults to active)
 * @returns {Promise<{sessionId: string, seed: string}>}
 */
async function createSession(userId, event = config.activeEvent) {
  const db = await initDB();
  const sessions = db.collection("sessions");

  // 128-bit cryptographically secure random seed, encoded as hex.
  const seed = crypto.randomBytes(16).toString("hex");

  const doc = {
    userId,
    event,
    seed,
    createdAt: new Date(),
    // Extra fields for more sophisticated validation can be added here.
  };

  const { insertedId } = await sessions.insertOne(doc);
  return { sessionId: insertedId.toString(), seed };
}

/**
 * Fetch a session by id, validating ownership (userId) *and* age.
 *
 * @param {string} sessionId – MongoDB ObjectId string
 * @param {string|number} userId – Telegram user id of the caller
 * @returns {Promise<object|null>} – the session document or null if invalid
 */
async function fetchSession(sessionId, userId) {
  const db = await initDB();
  const sess = await db
    .collection("sessions")
    .findOne({ _id: new ObjectId(sessionId) });

  // Basic validation – id exists and belongs to the caller.
  if (!sess || String(sess.userId) !== String(userId)) return null;

  // TTL – sessions older than the configured time window are rejected.
  const ageMs = Date.now() - sess.createdAt.getTime();
  if (ageMs > SESSION_TTL_MINUTES * 60 * 1000) return null;

  return sess;
}

// ──────────────────────────────────────────────────────────────────────
// Replay verification helper
// ──────────────────────────────────────────────────────────────────────

/**
 * Minimalistic, *fast* verification of the replay payload.
 *
 * The client records only the *eaten* fish events (timestamp + fish size).
 * Given the shared RNG seed we can regenerate the deterministic fish spawn
 * order **very** quickly and check if the claimed events could have
 * occurred.  This does **not** prove the player did *not* cheat, but it
 * makes naive replay attacks (resending an old score JSON) impossible.
 *
 * @param {object} opts
 * @param {string}   opts.seed         – RNG seed (from session)
 * @param {Array}    opts.eatenEvents  – [{t, size}, ...]
 * @param {number}   opts.finalScore   – claimed end-of-round score
 * @param {number}   opts.gameTime     – duration in ms reported by client
 * @returns {boolean} – `true` if plausible, `false` if rejected
 */
function verifyReplay({ seed, eatenEvents, finalScore, gameTime }) {
  if (
    !Array.isArray(eatenEvents) ||
    eatenEvents.length === 0 ||
    typeof finalScore !== "number"
  ) {
    return false;
  }

  const seedrandom = require("seedrandom");
  const rng = seedrandom(seed);

  // ───── FAST deterministic spawn simulation ─────────────────────────
  // We reproduce *only* the fish sizes in the order they are generated by
  // the game.  Any mismatch between simulated and claimed sizes/timing
  // invalidates the replay.

  let simulatedScore = 0;
  let idx = 0;

  for (const evt of eatenEvents) {
    const { t, size } = evt; // t == milliseconds since round start
    if (typeof t !== "number" || typeof size !== "number") return false;
    if (t < 0 || t > MAX_EXPECTED_DURATION_MS) return false;
    if (idx > 2 && t < eatenEvents[idx - 1].t) return false; // time monotone

    // Regenerate the *next* fish size produced by the RNG.
    const simSize = generateNextFishSize(rng);
    if (Math.abs(simSize - size) > 0.1) return false; // tolerance check

    simulatedScore += Math.floor(size); // same as calculateFishScore()
    idx++;
  }

  // Allow minor rounding drift due to power-ups / bonuses.
  return Math.abs(simulatedScore - finalScore) < 3;
}

// Helper replicating the client's spawnFish() size calculation – keep in
// sync with the front-end `fishTypeDefinitions` list.
function generateNextFishSize(rng) {
  const defs = [
    { min: 10, max: 40, w: 0.432 },
    { min: 20, max: 60, w: 0.252 },
    { min: 25, max: 80, w: 0.2 },
    { min: 35, max: 100, w: 0.1 },
    { min: 200, max: 300, w: 0.013 },
    { min: 400, max: 500, w: 0.003 },
  ];
  const total = defs.reduce((s, d) => s + d.w, 0);
  let r = rng() * total;
  let def = defs[0];
  for (const d of defs) {
    if (r < d.w) {
      def = d;
      break;
    }
    r -= d.w;
  }
  return rng() * (def.max - def.min) + def.min;
}

module.exports = { createSession, fetchSession, verifyReplay };
