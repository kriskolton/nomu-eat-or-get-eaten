<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Telegram Mini-App bridge -->
    <script src="https://telegram.org/js/telegram-web-app.js?57"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

    <!-- Deterministic RNG (client & server share the same seed) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>

    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <title>Nomu: Eat or Get Eaten (Season 6): Nomu vs MonkeDAO</title>

    <!-- ----------------------------------------------------------------- -->
    <!--                       FONTS & AUDIO ASSETS                         -->
    <!-- ----------------------------------------------------------------- -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Londrina+Solid&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- ----------------------------------------------------------------- -->
    <!--                              STYLES                               -->
    <!-- ----------------------------------------------------------------- -->
    <style>
      /* --- layout basics --- */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: #222;
        font-family: "Poppins", sans-serif;
      }
      #gameWrapper {
        flex: 1;
        width: 100%;
        position: relative;
        overflow: hidden;
        background: #222 url("img/bg6-2.png") center/cover no-repeat;
        display: flex;
        margin: 0 auto;
        max-width: 430px;
        max-height: 935px;
      }
      #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      /* --- on-screen arrow keys --- */
      #controlsContainer {
        width: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        background: #222;
      }
      .controlsRow {
        display: flex;
        width: 100%;
        max-width: 450px;
        margin: 0 auto;
      }
      .arrowBtn {
        flex: 1;
        background: #f78719;
        border: none;
        color: #fff;
        font-family: "Londrina Solid", sans-serif;
        font-size: 20px;
        margin: 1px;
        border-radius: 4px;
        height: 60px;
        user-select: none;
        touch-action: none;
      }
      .arrowBtn:active {
        transform: scale(0.95);
      }

      /* --- overlay screens --- */
      .overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 30, 15, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .hidden {
        display: none;
      }
      .overlay h1,
      .overlay button,
      .overlay p {
        color: #fff;
        margin: 8px;
      }
      .overlay button {
        font-size: 16px;
        font-weight: bold;
        padding: 8px 10px;
        cursor: pointer;
        border-radius: 40px;
        background: #f78719;
        font-family: "Londrina Solid", sans-serif;
        margin: 4px;
      }
      .overlay p {
        font-size: 14px;
      }
      .tutorialBtn {
        position: absolute;
        bottom: 6px;
        left: 6px;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: none;
        font-family: "Londrina Solid", sans-serif;
        font-size: 22px;
        line-height: 1;
        background: rgba(0, 0, 0, 0.45);
        color: #fff;
        cursor: pointer;
      }
      .teamInfo {
        margin: 6px 0 10px;
      }
      .teamInfo .teamLabel {
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.4px;
        margin: 4px 0 6px;
      }
      .avatarToggle {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        justify-content: center;
        margin-bottom: 4px;
      }
      .choiceBtn {
        background: rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        font-size: 12px;
        padding: 6px 10px;
        border-radius: 16px;
        min-width: 120px;
        opacity: 0.7;
      }
      .choiceBtn.active {
        background: #f78719;
        border-color: #f78719;
        color: #fff;
        opacity: 1;
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(247, 135, 25, 0.25);
      }
      .teamHint {
        font-size: 11px;
        opacity: 0.65;
        margin: 0;
      }
      /* --- tutorial overlay --- */
      #tutorialScreen {
        z-index: 10000;
        cursor: pointer;
      }
      #tutorialScreen .tutorialCard {
        width: 88%;
        max-width: 360px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #tutorialScreen h2 {
        font-family: "Londrina Solid", sans-serif;
        letter-spacing: 1px;
        margin: 6px 0 10px;
      }
      .tutorialViewport {
        width: 100%;
        max-width: 320px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 8px;
        margin-bottom: 12px;
      }
      #tutorialCanvas {
        width: 100%;
        height: 150px;
        display: block;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.2);
      }
      #tutorialText {
        font-size: 15px;
      }
      #tutorialHint {
        font-size: 12px;
        opacity: 0.7;
        margin-top: 4px;
      }
    </style>
  </head>

  <body>
    <!-- ----------------------------------------------------------------- -->
    <!--                            MARK-UP                                -->
    <!-- ----------------------------------------------------------------- -->
    <div id="gameWrapper">
      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Loading overlay (always present at first) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div id="loadingScreen" class="overlay">
        <p
          style="
            font-family: 'Londrina Solid', sans-serif;
            font-size: 32px;
            letter-spacing: 2px;
            color: #fff;
          "
        >
          Loading‚Ä¶
        </p>
      </div>
      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->

      <canvas id="gameCanvas"></canvas>

      <!-- ---------- Start overlay ---------- -->
      <div id="startScreen" class="overlay hidden">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <img
            src="img/title-6.png"
            alt="Eat or Get Eaten"
            style="
              max-width: 50%;
              height: auto;
              padding: 12px;
              padding-bottom: 0;
              margin-bottom: -8px;
              max-height: 30vh;
            "
          />
          <p
            style="
              font-size: 24px;
              -webkit-background-clip: text;
              background-clip: text;
              color: #fff;
              font-family: 'Londrina Solid', sans-serif;
              letter-spacing: 2px;
            "
          >
            SEASON 6: NOMU VS MONKEDAO
          </p>
          <p
            style="
              font-size: 12px;
              color: #fff;
              opacity: 0.5;
              position: absolute;
              bottom: 6px;
              right: 6px;
            "
          >
            v7.3
          </p>
          <button id="tutorialBtn" class="tutorialBtn" aria-label="Tutorial">
            ?
          </button>

          <div
            id="telegramStatus"
            style="
              color: white;
              font-family: 'Poppins', sans-serif;
              font-size: 12px;
              margin-bottom: 12px;
            "
          ></div>

          <div class="teamInfo">
            <p id="playerTeamDisplay" class="teamLabel">Team: --</p>
            <div class="avatarToggle">
              <button id="playAsNomuBtn" class="choiceBtn" type="button">
                Play as Nomu
              </button>
              <button id="playAsMonkeBtn" class="choiceBtn" type="button">
                Play as Monke
              </button>
            </div>
          </div>

          <p style="font-size: 20px; font-weight: bold; letter-spacing: 1px">
            Rules
          </p>
          <p style="font-size: 12px">
            Use the touch screen or arrow keys (‚Üë‚Üí‚Üì‚Üê) to control your character.
            Eat the smaller creatures to grow. Don't let the bigger creatures
            eat you!
          </p>

          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
            "
          >
            <button id="musicBtn" style="width: 40%">üéµ Music On</button>
            <button id="sfxBtn" style="width: 40%">üîä SFX On</button>
          </div>

          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
            "
          >
            <button id="arrowKeysBtn" style="width: 40%">
              üéÆ Arrow Keys Off
            </button>
            <button id="joystickBtn" style="width: 40%">üïπÔ∏è Joystick On</button>
          </div>

          <button id="startBtn" style="font-size: 24px; padding: 12px 24px">
            Start Game
          </button>
        </div>
      </div>

      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEAM‚ÄëSELECT OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div id="teamScreen" class="overlay hidden">
        <div
          style="
            max-width: 90%;
            max-height: 90vh;
            margin: 0 auto;
            text-align: center;
          "
        >
          <img
            src="img/title-6.png"
            alt="Eat¬†or¬†Get¬†Eaten"
            style="
              max-width: 55%;
              height: auto;
              padding: 12px;
              max-height: 30vh;
            "
          />
          <p
            style="
              font-size: 22px;
              font-family: 'Londrina Solid', sans-serif;
              letter-spacing: 1px;
              color: #fff;
              margin-top: 4px;
            "
          >
            CHOOSE&nbsp;YOUR&nbsp;TEAM
          </p>

          <button
            class="teamBtn"
            data-team="MonkeDAO"
            style="background: #f5b400"
          >
            üêí¬†Team¬†MonkeDAO</button
          ><br />
          <button class="teamBtn" data-team="Nomu" style="background: #f78719">
            üê°¬†Team¬†Nomu</button
          ><br />

          <p style="font-size: 12px; color: #fffa">
            *You can‚Äôt change this later
          </p>
        </div>
      </div>
      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ /TEAM‚ÄëSELECT OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->

      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TUTORIAL OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      <div id="tutorialScreen" class="overlay hidden">
        <div class="tutorialCard">
          <h2
            style="
              font-family: 'Londrina Solid', sans-serif;
              font-size: 24px;
              letter-spacing: 1px;
              color: #fff;
            "
          >
            How to Play
          </h2>
          <div class="tutorialViewport">
            <canvas id="tutorialCanvas"></canvas>
          </div>
          <p id="tutorialText"></p>
          <p id="tutorialHint"></p>
        </div>
      </div>
      <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ /TUTORIAL OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->

      <!-- ---------- Game-over overlay ---------- -->
      <div id="gameOverScreen" class="overlay hidden" style="width: 100%">
        <div
          style="
            max-width: 90%;
            margin: 0 auto;
            text-align: center;
            width: 100%;
          "
        >
          <h1
            style="font-family: 'Londrina Solid', sans-serif; font-size: 44px"
          >
            GAME OVER!
          </h1>
          <p id="finalScore"></p>
          <button
            id="shareBtn"
            style="
              font-size: 24px;
              padding: 12px 24px;
              margin-top: 12px;
              background-color: #222;
            "
          >
            ùïè &nbsp;Share on X
          </button>
          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
              width: 100%;
            "
          >
            <button id="musicBtnGameOver" style="width: 40%">
              üéµ Music On
            </button>
            <button id="sfxBtnGameOver" style="width: 40%">üîä SFX On</button>
          </div>
          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
              width: 100%;
            "
          >
            <button id="arrowKeysBtnGameOver" style="width: 40%">
              üéÆ Arrow Keys On
            </button>
            <button id="joystickBtnGameOver" style="width: 40%">
              üïπÔ∏è Joystick On
            </button>
          </div>
          <div class="teamInfo">
            <div class="avatarToggle">
              <button
                id="playAsNomuBtnGameOver"
                class="choiceBtn"
                type="button"
              >
                Play as Nomu
              </button>
              <button
                id="playAsMonkeBtnGameOver"
                class="choiceBtn"
                type="button"
              >
                Play as Monke
              </button>
            </div>
          </div>
          <button
            id="playAgainBtn"
            style="font-size: 24px; padding: 12px 24px; margin-top: 12px"
          >
            Play Again
          </button>
        </div>
      </div>
    </div>

    <!-- ---------- Bottom: on-screen arrow keys ---------- -->
    <div id="controlsContainer">
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowUp">‚Üë</button>
      </div>
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowLeft">‚Üê</button>
        <button class="arrowBtn" id="arrowDown">‚Üì</button>
        <button class="arrowBtn" id="arrowRight">‚Üí</button>
      </div>
    </div>

    <!-- ----------------------------------------------------------------- -->
    <!--                          GAME SCRIPT                               -->
    <!-- ----------------------------------------------------------------- -->
    <script>
      /********************* CONSTANTS & GLOBALS ***************************/

      /* Dev helper ‚Äì ?dev in the URL skips Telegram auth */
      const urlParams = new URLSearchParams(window.location.search);
      const forceDev = urlParams.has("dev");

      // ‚îÄ‚îÄ‚îÄ TEAM‚ÄëSELECT CONSTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const VALID_TEAMS = ["MonkeDAO", "Nomu"];
      let userTeam = null; // populated after /api/score call
      let playerAvatarTeam = null;
      let usingMonkeSprites = false;
      const teamScreen = document.getElementById("teamScreen");
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      let tg, userData, userId, initDataRaw;
      try {
        tg = window.Telegram.WebApp;
        if (!forceDev) {
          initDataRaw = tg.initData;
          userData = tg.initDataUnsafe?.user;
          userId = userData?.id;
          tg.expand();
          tg.ready();
          tg.disableVerticalSwipes();
        }
      } catch (e) {
        console.error("Telegram init error:", e);
      }

      /* Local fallback */
      if (forceDev) {
        userId = "local-dev";
        userData = { username: "dev" };
      }

      /* Status banner */
      const statusDiv = document.getElementById("telegramStatus");
      if (userId) {
        statusDiv.textContent = `Telegram connected ‚úì (${
          userData?.username || userData?.first_name || userId
        })`;
        statusDiv.style.color = "lightgreen";
      } else {
        statusDiv.textContent =
          "‚ö†Ô∏è Not tracking scores ‚Äì open via Telegram bot";
        statusDiv.style.color = "red";
      }

      /* ----------------   DETERMINISTIC RANDOM  ---------------- */
      // rng ‚Äì graphics/FX/anything *except* spawning
      let rng = Math.random; // will be replaced with seed-rng after session starts
      const Rand = () => rng();

      // --- NEW deterministic RNG streams ---
      let spawnSpecRng = null; // generates the ordered list of spawn specs
      let spawnTimingRng = null; // governs WHEN the next spawn occurs
      const specRand = () => (spawnSpecRng ? spawnSpecRng() : Math.random());
      const timingRand = () =>
        spawnTimingRng ? spawnTimingRng() : Math.random();

      /* üîß  MISSING HELPERS RE-ADDED  üîß */
      const getRandom = (min, max) => Rand() * (max - min) + min; // FIXED
      const getSpecRandom = (min, max) => specRand() * (max - min) + min;
      const getSpawnRandom = getSpecRandom; // legacy alias

      /* ---------------------- NEW LIMITING CONSTANTS --------------------- */
      const MAX_WATER_TRAILS = 1500;
      const MAX_EXPLOSIONS = 100;
      const MAX_ROCKS = 80;
      const RETAIN_SCHEDULE_ENTRIES = 1000;

      // Guest character constants
      const CHIPPY_SIZE = 90; // 45‚ÄØ√ó‚ÄØ2
      const POLLY_SIZE = 70; // 35‚ÄØ√ó‚ÄØ2
      const POLLY_HELPER_SIZE = 70;

      // Gorilla + rocks
      const GORILLA_SIZE = 120;
      const ROCK_MIN_SIZE = 22;
      const ROCK_MAX_SIZE = 40;
      const ROCK_MIN_SPEED = 1.6;
      const ROCK_MAX_SPEED = 3.0;
      const GORILLA_THROW_MIN = 3.5;
      const GORILLA_THROW_MAX = 6.5;
      const GORILLA_RISE_SPEED = 1.4;

      // Power-up constants
      const SUSHI_DURATION = 10;
      const BORGY_DURATION = 15;
      const BORGY_SPEED_MULT = 3;
      const STATUS_MESSAGE_DURATION = 3;

      // Spawn schedule (server-verifiable)
      const spawnSchedule = []; // { idx, spawnTime (s), spec }
      let globalSpawnIdx = 0;
      let nextScheduleIdx = 0;
      let scheduleCursorTime = 0; // seconds

      /* Generate exponential delay matching 0.03/frame (‚âà1.8 spawns/s) */
      function getNextSpawnDelay() {
        let u = timingRand();
        // Guard for u === 1 to avoid Infinity delays
        if (u === 1) u = 1 - Number.EPSILON;
        const lambda = 1.8; // per second
        return -Math.log(1 - u) / lambda;
      }

      function scheduleNextEntry() {
        const spec = nextSpawnSpec();
        const delay = getNextSpawnDelay();
        scheduleCursorTime += delay;
        spawnSchedule.push({
          idx: globalSpawnIdx++,
          spawnTime: scheduleCursorTime,
          spec,
        });
      }

      function ensureScheduleAhead(bufferSeconds = 60) {
        while (
          spawnSchedule.length === 0 ||
          spawnSchedule[spawnSchedule.length - 1].spawnTime <
            gameTime + bufferSeconds
        ) {
          scheduleNextEntry();
        }
      }

      /*********************   ASSET HELPERS   ****************************/
      function loadImage(src) {
        return new Promise((resolve) => {
          const img = new Image();
          img.addEventListener("load", () => resolve(img));
          img.addEventListener("error", () => {
            console.warn(`Image failed to load: ${src}`);
            resolve(img); // resolve anyway ‚Äì game can continue
          });
          img.src = src;
        });
      }

      function loadAudio(id) {
        return new Promise((resolve) => {
          const el = document.getElementById(id);
          if (!el) return resolve();
          let resolved = false;
          const finalize = () => {
            if (!resolved) {
              resolved = true;
              resolve(el);
            }
          };
          // Handle normal load/error events
          el.addEventListener("canplaythrough", finalize, { once: true });
          el.addEventListener("error", finalize, { once: true });
          // If already loaded (cached), resolve immediately
          if (el.readyState >= 3) finalize();
          // Fallback: always resolve after 300ms (prevents iOS hanging)
          setTimeout(finalize, 300);
        });
      }

      /* Keyboard state */
      const keys = { left: false, right: false, up: false, down: false };
      const clearKeys = () => {
        keys.left = keys.right = keys.up = keys.down = false;
      };

      /* Pointer-aware button helper */
      const pointerDirMap = Object.create(null);
      function pressKey(dir, down) {
        keys[dir] = down;
      }
      function setupArrowButton(btn, dir) {
        btn.addEventListener(
          "pointerdown",
          (e) => {
            pressKey(dir, true);
            btn.setPointerCapture(e.pointerId);
            pointerDirMap[e.pointerId] = dir;
            e.preventDefault();
          },
          { passive: false }
        );
        function release(e) {
          const d = pointerDirMap[e.pointerId] ?? dir;
          pressKey(d, false);
          delete pointerDirMap[e.pointerId];
        }
        btn.addEventListener("pointerup", release);
        btn.addEventListener("pointercancel", release);
      }
      ["Up", "Left", "Down", "Right"].forEach((dir) =>
        setupArrowButton(
          document.getElementById(`arrow${dir}`),
          dir.toLowerCase()
        )
      );

      /* -------- Score submission (networking/security skipped per brief) -------- */
      const getApiSeed = (() => {
        const codes = [68, 111, 115, 107, 100, 82, 112, 104, 106, 100];
        let cached = null;
        return () => {
          if (cached) return cached;
          cached = codes.map((c) => String.fromCharCode(c - 3)).join("");
          return cached;
        };
      })();
      const getApiPassword = () =>
        getApiSeed()
          .split("")
          .map((ch) => ch.charCodeAt(0).toString(16))
          .join("");

      /* Extended signature (NEW params at the end) */
      async function sendScoreToAPI(
        score,
        eaten,
        sessionId,
        gameTimeMs,
        eatenBy = null, // NEW
        startTimeMs = null, // NEW
        endTimeMs = null // NEW
      ) {
        if (!userId) return; // dev mode skip

        try {
          await fetch("/api/scores", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `tma ${initDataRaw}`,
              "x-api-password": getApiPassword(),
            },
            body: JSON.stringify({
              score,
              gameTime: gameTimeMs, // existing
              event: "Nomu vs MonkeDAO",
              eaten,
              sessionId,

              /* ---- NEW FIELDS ---- */
              eatenBy, // idx of the enemy that killed the player
              epochGameStartTime: startTimeMs, // epoch-ms
              epochGameEndTime: endTimeMs, // epoch-ms
            }),
          });
        } catch (e) {
          console.error("Score send error:", e);
        }
      }

      /* Canvas */
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      let WIDTH = 800,
        HEIGHT = 600;

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth;
        const cssH = canvas.clientHeight;
        canvas.width = cssW * dpr;
        canvas.height = cssH * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        WIDTH = cssW;
        HEIGHT = cssH;

        if (player && player.width && player.height) {
          player.x = Math.min(Math.max(0, player.x), WIDTH - player.width);
          player.y = Math.min(Math.max(0, player.y), HEIGHT - player.height);
        }
        fishList.forEach((ent) => {
          if (ent.width == null || ent.height == null) {
            if (typeof ent.calculateDimensions === "function") {
              ent.calculateDimensions();
            }
          }
          if (ent.width && ent.height) {
            const maxX = Math.max(0, WIDTH - ent.width);
            const maxY = Math.max(0, HEIGHT - ent.height);

            ent.x = Math.min(Math.max(0, ent.x), maxX);
            ent.y = Math.min(Math.max(0, ent.y), maxY);
          }
        });
        resizeTutorialCanvas();
      }
      window.addEventListener("resize", resizeCanvas);

      /* Overlay/DOM refs */
      const startScreen = document.getElementById("startScreen");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const startBtn = document.getElementById("startBtn");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const finalScoreElem = document.getElementById("finalScore");
      const musicBtn = document.getElementById("musicBtn");
      const sfxBtn = document.getElementById("sfxBtn");
      const arrowKeysBtn = document.getElementById("arrowKeysBtn");
      const joystickBtn = document.getElementById("joystickBtn");
      const musicBtnGameOver = document.getElementById("musicBtnGameOver");
      const sfxBtnGameOver = document.getElementById("sfxBtnGameOver");
      const shareBtn = document.getElementById("shareBtn");
      const arrowKeysBtnGameOver = document.getElementById(
        "arrowKeysBtnGameOver"
      );
      const joystickBtnGameOver = document.getElementById(
        "joystickBtnGameOver"
      );
      const controlsContainer = document.getElementById("controlsContainer");
      const arrowUp = document.getElementById("arrowUp");
      const arrowDown = document.getElementById("arrowDown");
      const arrowLeft = document.getElementById("arrowLeft");
      const arrowRight = document.getElementById("arrowRight");
      const tutorialBtn = document.getElementById("tutorialBtn");
      const tutorialScreen = document.getElementById("tutorialScreen");
      const tutorialCanvas = document.getElementById("tutorialCanvas");
      const tutorialText = document.getElementById("tutorialText");
      const tutorialHint = document.getElementById("tutorialHint");
      const playerTeamDisplay = document.getElementById("playerTeamDisplay");
      const playAsNomuBtn = document.getElementById("playAsNomuBtn");
      const playAsMonkeBtn = document.getElementById("playAsMonkeBtn");
      const playAsNomuBtnGameOver = document.getElementById(
        "playAsNomuBtnGameOver"
      );
      const playAsMonkeBtnGameOver = document.getElementById(
        "playAsMonkeBtnGameOver"
      );

      const showStartScreen = () => {
        startScreen.classList.remove("hidden");
        // ensure buttons are enabled after a previous run
        startBtn.disabled = false;
        // sync UI with current settings
        showOrHideArrowKeys(false);
        updateMusicButtons();
        updateSfxButtons();
        updateJoystickButtons();
        updatePlayerAvatarUI();
      };
      const hideStartScreen = () => startScreen.classList.add("hidden");
      const showGameOverScreen = (scoreVal) => {
        finalScoreElem.textContent = `Your Score: ${scoreVal}`;
        gameOverScreen.classList.remove("hidden");
        playGameOverSound();
        syncGameOverUI();
        // re-enable buttons for a new run
        startInProgress = false;
        startBtn.disabled = false;
        playAgainBtn.disabled = false;
        shareBtn.disabled = false;
        shareBtn.addEventListener("click", () => {
          const text = `I just scored ${scoreVal} points in @EatwithNomu Eat or Get Eaten! üî•\n\nCan you beat my score? Play now on Telegram: https://t.me/NomuTheFish`;
          const url =
            "https://x.com/intent/tweet?text=" + encodeURIComponent(text);
          Telegram.WebApp.openLink(url, { tryBrowser: "external" });
        });
      };
      const hideGameOverScreen = () => gameOverScreen.classList.add("hidden");

      /* Tutorial overlay */
      const tutorialCtx = tutorialCanvas
        ? tutorialCanvas.getContext("2d")
        : null;
      const TUTORIAL_POISON_COLOR = { r: 178, g: 90, b: 238 };

      function resizeTutorialCanvas() {
        if (!tutorialCanvas || !tutorialCtx) return;
        const dpr = window.devicePixelRatio || 1;
        const rect = tutorialCanvas.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        tutorialCanvas.width = Math.round(rect.width * dpr);
        tutorialCanvas.height = Math.round(rect.height * dpr);
        tutorialCtx.setTransform(1, 0, 0, 1, 0, 0);
        tutorialCtx.scale(dpr, dpr);
        tutorialCanvasWidth = rect.width;
        tutorialCanvasHeight = rect.height;
      }

      function getSpriteDimensions(img, maxSide) {
        const safeSide = Math.max(1, maxSide);
        const w = img?.naturalWidth || safeSide;
        const h = img?.naturalHeight || safeSide;
        if (!w || !h) return { w: safeSide, h: safeSide };
        const asp = w / h;
        if (asp > 1) return { w: safeSide, h: safeSide / asp };
        return { w: safeSide * asp, h: safeSide };
      }

      function drawTutorialSprite(
        ctx,
        img,
        x,
        y,
        maxSide,
        { flip = false, alpha = 1 } = {}
      ) {
        if (!ctx || !img) return null;
        const { w, h } = getSpriteDimensions(img, maxSide);
        ctx.save();
        ctx.globalAlpha = alpha;
        if (flip) {
          ctx.translate(x + w / 2, y + h / 2);
          ctx.scale(-1, 1);
          ctx.drawImage(img, -w / 2, -h / 2, w, h);
        } else {
          ctx.drawImage(img, x, y, w, h);
        }
        ctx.restore();
        return { w, h };
      }

      const getTutorialPlayerSprite = () => {
        if (playerImg.complete && playerImg.naturalWidth > 0) return playerImg;
        return fishTypes?.[0]?.image || playerImg;
      };

      function renderTutorialEat(ctx, now, w, h) {
        const cycle = 3.2;
        const t = ((now - tutorialStepStart) / 1000) % cycle;
        const eatTime = 1.4;
        const padding = w * 0.1;
        const baseSize = Math.min(h * 0.32, 34);
        const smallSize = baseSize * 0.6;
        const travel = w - padding * 2 - baseSize;
        const moveProgress = Math.min(t / eatTime, 1);
        const playerX = padding + travel * moveProgress;
        const fishX = padding + travel * 0.55;
        const fishY = h * 0.56 - smallSize / 2;
        const contactProgress = Math.min(
          Math.max((fishX - padding - baseSize * 0.6) / travel, 0),
          1
        );
        const contactTime = contactProgress * eatTime;
        const growthProgress =
          t >= contactTime ? Math.min((t - contactTime) / 0.3, 1) : 0;
        const playerSize = baseSize * (1 + 0.25 * growthProgress);
        const playerY = h * 0.56 - playerSize / 2;

        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, "rgba(18, 40, 60, 0.5)");
        grad.addColorStop(1, "rgba(8, 20, 30, 0.8)");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        const smallSprite = fishTypes?.[0]?.image || playerImg;
        if (t < contactTime) {
          drawTutorialSprite(ctx, smallSprite, fishX, fishY, smallSize, {
            flip: true,
          });
        } else {
          const burstProgress = Math.min((t - contactTime) / 0.4, 1);
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const dist = 10 * burstProgress;
            ctx.fillStyle = `rgba(255,255,255,${0.7 * (1 - burstProgress)})`;
            ctx.beginPath();
            ctx.arc(
              fishX + smallSize / 2 + Math.cos(angle) * dist,
              fishY + smallSize / 2 + Math.sin(angle) * dist,
              2.2,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }

        drawTutorialSprite(
          ctx,
          getTutorialPlayerSprite(),
          playerX,
          playerY,
          playerSize
        );
      }

      function renderTutorialLose(ctx, now, w, h) {
        const cycle = 3;
        const t = ((now - tutorialStepStart) / 1000) % cycle;
        const impactTime = 1.3;
        const explosionDuration = 0.7;
        const padding = w * 0.08;
        const playerSize = Math.min(h * 0.28, 30);
        const bigSize = Math.min(h * 0.55, 64);
        const playerStartX = padding;
        const playerEndX = w * 0.52;
        const progress = Math.min(t / impactTime, 1);
        const playerX = playerStartX + (playerEndX - playerStartX) * progress;
        const playerY = h * 0.58 - playerSize / 2;
        const bigX = w * 0.62;
        const bigY = h * 0.52 - bigSize / 2;

        ctx.fillStyle = "rgba(12, 18, 26, 0.8)";
        ctx.fillRect(0, 0, w, h);

        const bigSprite = fishTypes?.[fishTypes.length - 1]?.image || playerImg;
        drawTutorialSprite(ctx, bigSprite, bigX, bigY, bigSize, { flip: true });

        const impactX = playerX + playerSize * 0.75;
        const impactY = playerY + playerSize * 0.55;

        if (t < impactTime) {
          drawTutorialSprite(
            ctx,
            getTutorialPlayerSprite(),
            playerX,
            playerY,
            playerSize
          );
        } else {
          const explosionProgress = Math.min(
            (t - impactTime) / explosionDuration,
            1
          );
          const flash = Math.min((t - impactTime) / 0.2, 1);
          ctx.fillStyle = `rgba(255,255,255,${0.35 * (1 - explosionProgress)})`;
          ctx.beginPath();
          ctx.arc(impactX, impactY, 18 + flash * 6, 0, Math.PI * 2);
          ctx.fill();

          const bubbleCount = 14;
          for (let i = 0; i < bubbleCount; i++) {
            const angle = (i / bubbleCount) * Math.PI * 2;
            const speed = 22 + 8 * Math.sin(i * 1.7);
            const dist = speed * explosionProgress;
            const bx = impactX + Math.cos(angle) * dist;
            const by = impactY + Math.sin(angle) * dist;
            const radius = 2.5 + (1 - explosionProgress) * 2;
            const alpha = 0.8 * (1 - explosionProgress);
            ctx.fillStyle = `rgba(255,255,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(bx, by, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function renderTutorialPoison(ctx, now, w, h) {
        const cycle = 3.4;
        const t = ((now - tutorialStepStart) / 1000) % cycle;
        const eatTime = 1.6;
        const padding = w * 0.1;
        const baseSize = Math.min(h * 0.32, 32);
        const shrinkSize = baseSize * 0.7;
        const playerProgress = Math.min(t / eatTime, 1);
        const playerX = padding + (w * 0.45 - padding) * playerProgress;
        const jellySize = baseSize * 0.9;
        const jellyX = w * 0.62;
        const jellyY = h * 0.5 - jellySize / 2 + Math.sin(t * 3) * 4;

        ctx.fillStyle = "rgba(10, 20, 18, 0.75)";
        ctx.fillRect(0, 0, w, h);

        if (t < eatTime) {
          ctx.save();
          const trailCount = 14;
          for (let i = 0; i < trailCount; i++) {
            const progress = i / (trailCount - 1);
            const alpha = (1 - progress) * 0.65;
            const wobble = Math.sin(t * 6 + i * 0.8) * 2;
            const trailX =
              jellyX + jellySize * 0.48 + Math.sin(t * 3 + i * 0.7) * 3;
            const trailY =
              -24 +
              jellyY +
              jellySize * 0.15 +
              progress * jellySize * 1.2 +
              wobble;
            const radius = 1.2 + (1 - progress) * 2.2;
            ctx.shadowBlur = 8 * (1 - progress);
            ctx.shadowColor = `rgba(${TUTORIAL_POISON_COLOR.r},${TUTORIAL_POISON_COLOR.g},${TUTORIAL_POISON_COLOR.b},${alpha})`;
            ctx.fillStyle = `rgba(${TUTORIAL_POISON_COLOR.r},${
              TUTORIAL_POISON_COLOR.g
            },${TUTORIAL_POISON_COLOR.b},${alpha * 0.9})`;
            ctx.beginPath();
            ctx.arc(trailX, trailY, radius, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        if (t < eatTime) {
          drawTutorialSprite(ctx, jellyfishImg, jellyX, jellyY, jellySize, {
            flip: true,
          });
        }

        let playerSize = baseSize;
        if (t > eatTime) {
          const shrinkProgress = Math.min((t - eatTime) / 0.5, 1);
          playerSize = baseSize - (baseSize - shrinkSize) * shrinkProgress;
        }
        const playerY = h * 0.6 - playerSize / 2;
        drawTutorialSprite(
          ctx,
          getTutorialPlayerSprite(),
          playerX,
          playerY,
          playerSize
        );
      }

      function renderTutorialPowerups(ctx, now, w, h) {
        const t = (now - tutorialStepStart) / 1000;
        const bob = Math.sin(t * 2.2) * 4;
        const size = Math.min(h * 0.42, 52);
        const leftX = w * 0.2;
        const rightX = w * 0.6;
        const baseY = h * 0.36 + bob;

        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, "rgba(12, 26, 34, 0.7)");
        grad.addColorStop(1, "rgba(6, 14, 20, 0.85)");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        const drawFallback = (x, y, color) => {
          ctx.save();
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.arc(x + size / 2, y + size / 2, size * 0.28, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        };

        const chippyReady = borgyImg.complete && borgyImg.naturalWidth > 0;
        const pollyReady = pollyImg.complete && pollyImg.naturalWidth > 0;

        if (chippyReady) {
          drawTutorialSprite(ctx, borgyImg, leftX, baseY, size, { flip: true });
        } else {
          drawFallback(leftX, baseY, "rgba(3, 176, 176, 0.9)");
        }

        if (pollyReady) {
          drawTutorialSprite(ctx, pollyImg, rightX, baseY, size, {
            flip: true,
          });
        } else {
          drawFallback(rightX, baseY, "rgba(125, 255, 154, 0.9)");
        }

        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.font = "12px 'Poppins', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText("Banana Power-up", leftX + size / 2, baseY + size + 4);
        ctx.fillText("Monke Helper", rightX + size / 2, baseY + size + 4);
        ctx.restore();
      }

      const tutorialSteps = [
        {
          text: "Eat creatures smaller than you to grow.",
          render: renderTutorialEat,
        },
        {
          text: "You lose if you hit a creature larger than you.",
          render: renderTutorialLose,
        },
        {
          text: "These are power-ups you can always eat.",
          render: renderTutorialPowerups,
        },
        {
          text: "Watch out for poisonous creatures and other special abilities!",
          render: renderTutorialPoison,
        },
      ];

      function updateTutorialStep() {
        const step = tutorialSteps[tutorialStep];
        tutorialText.textContent = step?.text ?? "";
        tutorialHint.textContent = `Tap to continue (${tutorialStep + 1}/${
          tutorialSteps.length
        })`;
        tutorialStepStart = performance.now();
      }

      function renderTutorialFrame(now) {
        if (tutorialScreen.classList.contains("hidden")) return;
        if (!tutorialCanvasWidth || !tutorialCanvasHeight)
          resizeTutorialCanvas();
        const w = tutorialCanvasWidth || tutorialCanvas.clientWidth;
        const h = tutorialCanvasHeight || tutorialCanvas.clientHeight;
        if (!tutorialCtx || !w || !h) return;
        tutorialCtx.clearRect(0, 0, w, h);
        const step = tutorialSteps[tutorialStep];
        if (step?.render) step.render(tutorialCtx, now, w, h);
        tutorialAnimId = requestAnimationFrame(renderTutorialFrame);
      }

      function startTutorialAnimation() {
        if (!tutorialCtx) return;
        stopTutorialAnimation();
        resizeTutorialCanvas();
        tutorialAnimId = requestAnimationFrame(renderTutorialFrame);
      }

      function stopTutorialAnimation() {
        if (tutorialAnimId) cancelAnimationFrame(tutorialAnimId);
        tutorialAnimId = null;
      }

      function showTutorialScreen() {
        tutorialStep = 0;
        updateTutorialStep();
        hideStartScreen();
        hideGameOverScreen();
        tutorialScreen.classList.remove("hidden");
        startTutorialAnimation();
      }

      function hideTutorialScreen() {
        tutorialScreen.classList.add("hidden");
        stopTutorialAnimation();
      }

      function maybeShowTutorialOrStart() {
        if (!tutorialScreen || tutorialSeen) {
          showStartScreen();
          return;
        }
        showTutorialScreen();
      }

      async function markTutorialSeen() {
        if (!userId) return;
        try {
          await fetch("/api/tutorial/seen", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `tma ${initDataRaw}`,
              "x-api-password": getApiPassword(),
            },
            body: JSON.stringify({}),
          });
        } catch (e) {
          console.warn("Tutorial seen send error:", e);
        }
      }

      /* Game-state flags */
      let gameState = "start"; // "start" | "playing" | "over"
      let isGameOver = false;
      let pendingGameOver = false; // wait until explosions finish
      let tutorialSeen = false;
      let tutorialStep = 0;
      let tutorialStepStart = 0;
      let tutorialAnimId = null;
      let tutorialCanvasWidth = 0;
      let tutorialCanvasHeight = 0;

      /* Anti-cheat tracking */
      let eatenEvents = [];
      let currentSessionId = null;

      /*********************   IMAGES & SPRITES   ***************************/
      const fishTypeDefinitions = [
        { src: "img/fish1-6.png", minSize: 10, maxSize: 40, weight: 0.432 },
        { src: "img/fish2-6.png", minSize: 20, maxSize: 60, weight: 0.252 },
        { src: "img/fish3-6.png", minSize: 25, maxSize: 80, weight: 0.2 },
        { src: "img/fish4-6.png", minSize: 35, maxSize: 100, weight: 0.1 },
        {
          src: "img/fish5-6.png",
          minSize: 200,
          maxSize: 300,
          weight: 0.013,
          vines: true,
          useChipJellySprite: true,
        },
        { src: "img/fish6-6.png", minSize: 400, maxSize: 500, weight: 0.003 },
      ];
      const fishTypes = fishTypeDefinitions.map((def) => {
        const image = new Image();
        image.src = def.src;
        return {
          image,
          minSize: def.minSize,
          maxSize: def.maxSize,
          weight: def.weight,
          vines: !!def.vines,
          useChipJellySprite: !!def.useChipJellySprite,
        };
      });

      const frozenPlaceholderImg = new Image();
      frozenPlaceholderImg.src = "img/fish-frozen-placeholder.png";

      // ‚îÄ‚îÄ preload & cache ¬´frozen¬ª skins ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      fishTypes.forEach((ft) => {
        // start with the placeholder so we always have *something*
        ft.frozenSprite = frozenPlaceholderImg;

        const customSrc = ft.image.src.replace(/\.png$/, "-frozen.png");
        const custom = new Image();

        // If the custom image loads, use it; otherwise keep the placeholder.
        custom.onload = () => {
          ft.frozenSprite = custom;
        };
        custom.onerror = () => {
          /* leave placeholder in place */
        };

        custom.src = customSrc; // kicks off the request immediately
      });

      const playerImg = new Image();

      // NEW: Additional player sprites for different states
      const playerPoweredUpImg = new Image();
      playerPoweredUpImg.onerror = () =>
        console.warn(
          `${playerPoweredUpImg.src} not found - using filters instead`
        );

      const playerParalyzedImg = new Image();
      playerParalyzedImg.onerror = () =>
        console.warn(
          `${playerParalyzedImg.src} not found - using filters instead`
        );

      const playerBorgyImg = new Image();
      playerBorgyImg.onerror = () =>
        console.warn(`${playerBorgyImg.src} not found - using filters instead`);

      const crabImg = new Image();
      crabImg.src = "img/crab-6.png";
      const gorillaImg = new Image();
      gorillaImg.src = "img/gorilla-6.png";
      gorillaImg.onerror = () =>
        console.warn("gorilla-6.png not found - gorilla will be invisible");
      const rockImg = new Image();
      rockImg.src = "img/rock-6.png";
      rockImg.onerror = () =>
        console.warn("rock-6.png not found - rocks will be invisible");
      const jellyfishImg = new Image();
      jellyfishImg.src = "img/jellyfish-6-2.png";
      const electricJellyfishImg = new Image();
      electricJellyfishImg.src = "img/electric-jellyfish-6-2.png";
      const snakeImg = new Image();
      snakeImg.src = "img/snake-6.png";
      snakeImg.onerror = () =>
        console.warn("snake-6.png not found - snake will be invisible");
      const sushiImg = new Image();
      sushiImg.src = "img/sushi.png";
      const pufferImg = new Image();
      pufferImg.src = "img/pufferfish-6.png";
      const borgyImg = new Image();
      borgyImg.src = "img/chippy-6.png";
      const chipImg = new Image();
      chipImg.src = "img/chip-6.png";
      chipImg.onerror = () =>
        console.warn(
          "chip.png not found ‚Äì enemies will keep their normal sprite"
        );
      const chipJellyImg = new Image();
      chipJellyImg.src = "img/chip-jelly-6.png";
      chipJellyImg.onerror = () => {
        chipJellyImg.onerror = null;
        console.warn("chip-jelly-6.png not found - falling back to chip-6.png");
        chipJellyImg.src = chipImg.src;
      };

      const pollyImg = new Image();
      pollyImg.src = "img/polly-6.png"; // 35¬†√ó¬†35 fish (¬´Polly¬ª)

      const pollyHelperImg = new Image();
      pollyHelperImg.src = "img/polly-6.png";

      const playerPollyImg = new Image();
      playerPollyImg.onerror = () =>
        console.warn(`${playerPollyImg.src} not found - using filters instead`);

      const PLAYER_SPRITE_SETS = {
        nomu: {
          base: "img/player_fish-6.png",
          powered: "img/player_fish_powered.png",
          paralyzed: "img/player_fish_paralyzed-6.png",
          borgy: "img/player_fish_chippy-6.png",
          polly: "img/player_fish_polly-6.png",
        },
        monke: {
          base: "img/player_fish_monkedao-6.png",
          powered: "img/player_fish_monkedao_powered.png",
          paralyzed: "img/player_fish_monkedao_paralyzed-6.png",
          borgy: "img/player_fish_monkedao_chippy-6.png",
          polly: "img/player_fish_monkedao_polly-6.png",
        },
      };

      function applyPlayerSpriteSet(team) {
        const useMonke = team === "MonkeDAO";
        usingMonkeSprites = useMonke;
        const set = useMonke
          ? PLAYER_SPRITE_SETS.monke
          : PLAYER_SPRITE_SETS.nomu;
        playerImg.src = set.base;
        playerPoweredUpImg.src = set.powered;
        playerParalyzedImg.src = set.paralyzed;
        playerBorgyImg.src = set.borgy;
        playerPollyImg.src = set.polly;
      }

      function getPlayerAvatarTeam() {
        if (VALID_TEAMS.includes(playerAvatarTeam)) return playerAvatarTeam;
        if (VALID_TEAMS.includes(userTeam)) return userTeam;
        return "Nomu";
      }

      function updatePlayerAvatarUI() {
        if (playerTeamDisplay) {
          playerTeamDisplay.textContent = userTeam
            ? `Team: ${userTeam}`
            : "Team: --";
        }
        const active = getPlayerAvatarTeam();
        if (playAsNomuBtn) {
          playAsNomuBtn.classList.toggle("active", active === "Nomu");
          playAsNomuBtn.setAttribute("aria-pressed", active === "Nomu");
        }
        if (playAsMonkeBtn) {
          playAsMonkeBtn.classList.toggle("active", active === "MonkeDAO");
          playAsMonkeBtn.setAttribute("aria-pressed", active === "MonkeDAO");
        }
        if (playAsNomuBtnGameOver) {
          playAsNomuBtnGameOver.classList.toggle("active", active === "Nomu");
          playAsNomuBtnGameOver.setAttribute("aria-pressed", active === "Nomu");
        }
        if (playAsMonkeBtnGameOver) {
          playAsMonkeBtnGameOver.classList.toggle(
            "active",
            active === "MonkeDAO"
          );
          playAsMonkeBtnGameOver.setAttribute(
            "aria-pressed",
            active === "MonkeDAO"
          );
        }
      }

      function syncPlayerAvatarSprites() {
        const active = getPlayerAvatarTeam();
        playerAvatarTeam = active;
        applyPlayerSpriteSet(active);
        updatePlayerAvatarUI();
      }

      function setPlayerAvatarTeam(team) {
        if (!VALID_TEAMS.includes(team)) return;
        playerAvatarTeam = team;
        syncPlayerAvatarSprites();
      }

      syncPlayerAvatarSprites();

      // const frozenPlaceholderImg = new Image();
      // frozenPlaceholderImg.src = "img/fish-frozen-placeholder.png";

      // ‚îÄ‚îÄ frozen versions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const jellyfishFrozenImg = new Image();
      jellyfishFrozenImg.src = "img/jellyfish-5-frozen.png";
      jellyfishFrozenImg.onerror = () =>
        (jellyfishFrozenImg.src = frozenPlaceholderImg.src);

      const electricJellyFrozenImg = new Image();
      electricJellyFrozenImg.src = "img/electric-jellyfish-5-frozen.png";
      electricJellyFrozenImg.onerror = () =>
        (electricJellyFrozenImg.src = frozenPlaceholderImg.src);

      /*********************   GAME VARIABLES   ****************************/
      let fishList = [],
        score = 0,
        nextMilestone = 100000,
        enemySpeedMultiplier = 1,
        player,
        touchTarget = null;
      let waterTrails = [],
        poisonParticles = [],
        explosions = [],
        rocks = [];
      let gameTime = 0, // seconds
        gameTimeMs = 0; // milliseconds

      /* Game-wide timers (NEW) */
      let epochGameStartTime = null;
      let epochGameEndTime = null;

      /* Status effects */
      let playerParalyzeTime = 0;
      let playerParalyzeCause = null; // "electric" | "rock" | null
      const PARALYZE_DURATION = 3;
      const EATING_LEEWAY = 1.3;
      const JELLY_SHRINK_FACTOR = 0.6;
      const SNAKE_VINE_DROP_DURATION = 0.5;
      const SNAKE_VINE_FALL_ACCEL = 1800;
      const SNAKE_VINE_FALL_DRAG = 0.985;
      const SNAKE_VINE_COLOR = "rgba(18, 58, 32, 0.92)";
      const POISON_TRAIL_COLOR = { r: 178, g: 90, b: 238 }; // bright purple
      const MAX_POISON_PARTICLES = 100;
      const MIN_PLAYER_SIZE = 25;
      const GROWTH_FACTOR = 0.04; // ‚Üì smaller than the old 0.05 means slower growth
      const GROWTH_CAP = 1.5; // (optional) lower the absolute cap too
      let sushiPowerUpTime = 0;
      let borgyPowerUpTime = 0;
      let playerIsPoweredUp = false;
      let statusMessage = "";
      let statusMessageTime = 0;

      //¬†<<< Polly¬†power‚Äëup¬†globals¬†&¬†asset -------------------------------
      const POLLY_DURATION = 15; // seconds helper stays active
      let pollyFreezeTime = 0; // helper timer
      let pollyHelper = null;
      //¬†>>> ----------------------------------------------------------------

      /* --------------- NEW: Debounce state flag ---------------- */
      let startInProgress = false;

      /*********************   AUDIO: HOWLER.JS   *****************************/

      const sounds = {
        backgroundMusic: new Howl({
          src: ["sounds/background6.mp3"],
          loop: true,
          volume: 0.2,
          html5: true, // Ensures streaming for longer music on mobile
        }),
        eat: new Howl({ src: ["sounds/eat.mp3"], volume: 0.5 }),
        gameover: new Howl({ src: ["sounds/gameover.mp3"], volume: 0.5 }),
        powerup: new Howl({ src: ["sounds/powerup.mp3"], volume: 0.5 }),
        borgyPowerUp: new Howl({
          src: ["sounds/borgy-powerup.mp3"],
          volume: 0.3,
        }),
        borgySpawn: new Howl({
          src: ["sounds/chippy-spawn-6.mp3"],
          volume: 0.1,
        }),
        pollySpawn: new Howl({
          src: ["sounds/polly-spawn-6.mp3"],
          volume: 0.3,
        }),
        pollyPowerUp: new Howl({
          src: ["sounds/polly-powerup-6.mp3"],
          volume: 0.3,
        }),
        achievement: new Howl({ src: ["sounds/achievement.mp3"], volume: 0.5 }),
        shrink: new Howl({ src: ["sounds/shrink.mp3"], volume: 0.3 }),
        electric: new Howl({ src: ["sounds/electric.mp3"], volume: 0.3 }),
        shock: new Howl({ src: ["sounds/shock.mp3"], volume: 0.5 }),
        gorilla: new Howl({ src: ["sounds/gorilla.mp3"], volume: 0.2 }),
        rock: new Howl({ src: ["sounds/rock.mp3"], volume: 0.2 }),
        crab: new Howl({ src: ["sounds/crab.mp3"], volume: 0.2 }),
      };

      let isSfxEnabled = true;
      let isMusicEnabled = true;
      let isJoystickEnabled = true; // DEFAULT: on ‚Üí joystick mode

      const joystick = {
        active: false,
        baseX: 0,
        baseY: 0,
        stickX: 0,
        stickY: 0,
        radius: 60,
        innerRadius: 24,
      };

      const startAudio = () => {
        if (isMusicEnabled && !sounds.backgroundMusic.playing()) {
          sounds.backgroundMusic.play();
          sounds.backgroundMusic.volume(0.2);
        }
      };

      const stopAudio = () => {
        sounds.backgroundMusic.stop();
      };

      function playSfx(howl) {
        if (!isSfxEnabled) return;
        howl.play();
      }

      const playEatSound = () => playSfx(sounds.eat);
      const playGameOverSound = () => playSfx(sounds.gameover);
      const playPowerUpSound = () => playSfx(sounds.powerup);
      const playBorgyPowerUpSound = () => playSfx(sounds.borgyPowerUp);
      const playBorgySpawnSound = () => playSfx(sounds.borgySpawn);
      const playAchvSound = () => playSfx(sounds.achievement);
      const playShrinkSound = () => playSfx(sounds.shrink);
      const playElectricSound = () => playSfx(sounds.electric);
      const playShockSound = () => playSfx(sounds.shock);
      const playGorillaSpawnSound = () => playSfx(sounds.gorilla);
      const playRockThrowSound = () => playSfx(sounds.rock);
      const playCrabSpawnSound = () => playSfx(sounds.crab);
      const playPollySpawnSound = () => playSfx(sounds.pollySpawn);
      const playPollyPowerUpSound = () => playSfx(sounds.pollyPowerUp);

      const updateMusicButtons = () => {
        const txt = isMusicEnabled ? "üéµ Music On" : "üéµ Music Off";
        musicBtn.textContent = txt;
        musicBtnGameOver.textContent = txt;
      };

      const updateSfxButtons = () => {
        const txt = isSfxEnabled ? "üîä SFX On" : "üîà SFX Off";
        sfxBtn.textContent = txt;
        sfxBtnGameOver.textContent = txt;
      };

      const updateJoystickButtons = () => {
        const txt = isJoystickEnabled ? "üïπÔ∏è Joystick On" : "üïπÔ∏è Joystick Off";
        joystickBtn.textContent = txt;
        joystickBtnGameOver.textContent = txt;
      };

      const toggleMusic = () => {
        isMusicEnabled = !isMusicEnabled;
        if (isMusicEnabled) {
          if (!sounds.backgroundMusic.playing()) {
            sounds.backgroundMusic.play();
          }
          sounds.backgroundMusic.volume(0.2);
        } else {
          sounds.backgroundMusic.pause();
        }
        updateMusicButtons();
      };

      const toggleSFX = () => {
        isSfxEnabled = !isSfxEnabled;
        // Use Howler's mute globally for SFX (not music):
        // But to NOT mute music when SFX are off, we control each sound's volume
        // So instead, set SFX volume to 0 or back to original
        sounds.eat.volume(isSfxEnabled ? 0.5 : 0);
        sounds.gameover.volume(isSfxEnabled ? 0.5 : 0);
        sounds.powerup.volume(isSfxEnabled ? 0.5 : 0);
        sounds.borgyPowerUp.volume(isSfxEnabled ? 0.3 : 0);
        sounds.borgySpawn.volume(isSfxEnabled ? 0.3 : 0);
        sounds.achievement.volume(isSfxEnabled ? 0.5 : 0);
        sounds.shrink.volume(isSfxEnabled ? 0.3 : 0);
        sounds.electric.volume(isSfxEnabled ? 0.3 : 0);
        sounds.shock.volume(isSfxEnabled ? 0.5 : 0);
        sounds.gorilla.volume(isSfxEnabled ? 0.45 : 0);
        sounds.rock.volume(isSfxEnabled ? 0.45 : 0);
        sounds.crab.volume(isSfxEnabled ? 0.45 : 0);
        updateSfxButtons();
      };

      const toggleJoystick = () => {
        isJoystickEnabled = !isJoystickEnabled;
        updateJoystickButtons();
        joystick.active = false;
        touchTarget = null;
      };

      /*********************   HELPERS   *****************************/
      /* ---------- off-screen hue / sat / lum tint ---------- */
      function drawTextWithBg(
        ctx,
        text,
        x,
        y,
        {
          padding = 8,
          radius = 8,
          bgColor = "rgba(0,0,0,0.55)",
          textColor = "#fff",
          font = null,
        } = {}
      ) {
        ctx.save();
        if (font) ctx.font = font;
        const metrics = ctx.measureText(text);
        const textHeight = parseInt(ctx.font.match(/\d+/)); // crude height
        const width = metrics.width + padding * 2;
        const height = textHeight + padding * 1.5;
        // Rounded rect
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fillStyle = bgColor;
        ctx.fill();
        // Text
        ctx.fillStyle = textColor;
        ctx.textBaseline = "top";
        ctx.fillText(text, x + padding, y + padding * 0.75);
        ctx.restore();
        return height;
      }

      function showStatusMessage(text, duration = STATUS_MESSAGE_DURATION) {
        statusMessage = text;
        statusMessageTime = duration;
      }

      const jetpackState = {
        driftX: 0,
        driftY: 1,
        particles: [],
        lastEmitAt: 0,
        lastUpdateAt: 0,
      };
      const vineStates = new WeakMap();

      function getVineState(entity) {
        if (!entity) return null;
        let state = vineStates.get(entity);
        if (!state) {
          state = { bendX: 0, bendY: 0 };
          vineStates.set(entity, state);
        }
        return state;
      }

      function getEntityVelocity(entity) {
        let vx = 0;
        let vy = 0;
        if (Number.isFinite(entity.vx)) vx = entity.vx;
        else if (Number.isFinite(entity.speedX)) vx = entity.speedX;
        if (Number.isFinite(entity.vy)) vy = entity.vy;
        else if (Number.isFinite(entity.speedY)) vy = entity.speedY;
        return { vx, vy };
      }

      function drawPlayerJetpack(c, p) {
        if (!p) return;
        if (p.width == null || p.height == null) p.calculateDimensions();
        const w = p.width ?? p.maxSide;
        const h = p.height ?? p.maxSide;
        const baseX = p.x + w / 2;
        const baseY = p.y + h;
        const vx = Number.isFinite(p.vx) ? p.vx : 0;
        const vy = Number.isFinite(p.vy) ? p.vy : 0;
        const speed = Math.hypot(vx, vy);

        const targetDriftX = -vx * 0.8;
        const targetDriftY = 1 - vy * 0.15;
        jetpackState.driftX += (targetDriftX - jetpackState.driftX) * 0.12;
        jetpackState.driftY += (targetDriftY - jetpackState.driftY) * 0.12;

        let dirX = jetpackState.driftX;
        let dirY = jetpackState.driftY;
        const mag = Math.hypot(dirX, dirY) || 1;
        dirX /= mag;
        dirY /= mag;

        const now = performance.now();
        const lastUpdateAt = jetpackState.lastUpdateAt || now;
        const dt = Math.min(0.05, (now - lastUpdateAt) / 1000);
        jetpackState.lastUpdateAt = now;

        const side = Math.max(2, w * 0.08);
        const perpX = -dirY;
        const perpY = dirX;
        const emissionRate = 70 + speed * 4; // particles per second (subtle)
        const emitInterval = 1000 / emissionRate;
        if (!jetpackState.lastEmitAt) jetpackState.lastEmitAt = now;

        while (now - jetpackState.lastEmitAt >= emitInterval) {
          jetpackState.lastEmitAt += emitInterval;
          for (const sideDir of [-1, 1]) {
            const startX = baseX + perpX * side * sideDir;
            const startY = baseY + perpY * side * sideDir;
            const spread = 0.2;
            const jitter = (Math.random() - 0.5) * spread;
            const jitterX = dirX * Math.cos(jitter) - dirY * Math.sin(jitter);
            const jitterY = dirX * Math.sin(jitter) + dirY * Math.cos(jitter);
            const speedPx = 60 + Math.random() * 40 + speed * 3;
            const size = 0.8 + Math.random() * 1.2;
            const ttl = 0.2 + Math.random() * 0.15;
            jetpackState.particles.push({
              x: startX,
              y: startY,
              vx: jitterX * speedPx,
              vy: jitterY * speedPx,
              life: ttl,
              ttl,
              size,
            });
          }
        }

        for (let i = jetpackState.particles.length - 1; i >= 0; i--) {
          const pfx = jetpackState.particles[i];
          pfx.life -= dt;
          if (pfx.life <= 0) {
            jetpackState.particles.splice(i, 1);
            continue;
          }
          pfx.x += pfx.vx * dt;
          pfx.y += pfx.vy * dt;
        }

        if (jetpackState.particles.length > 180) {
          jetpackState.particles.splice(0, jetpackState.particles.length - 180);
        }

        c.save();
        for (const pfx of jetpackState.particles) {
          const alpha = Math.max(0, pfx.life / pfx.ttl);
          c.fillStyle = `rgba(220,235,255,${alpha * 0.35})`;
          c.beginPath();
          c.arc(pfx.x, pfx.y, pfx.size, 0, Math.PI * 2);
          c.fill();
        }
        c.restore();
      }

      function drawEntityVine(c, p) {
        if (!p) return;
        if (p.width == null || p.height == null) p.calculateDimensions();
        const w = p.width ?? p.maxSide;
        const anchorX = p.x + w / 2;
        const anchorY = p.y;
        const topY = -60;
        const topX = anchorX + Math.sin(performance.now() / 700) * 5;
        const { vx, vy } = getEntityVelocity(p);
        const state = getVineState(p);
        const targetBendX = -vx * 6;
        const targetBendY = -vy * 2;
        state.bendX += (targetBendX - state.bendX) * 0.1;
        state.bendY += (targetBendY - state.bendY) * 0.1;

        const midY = topY + (anchorY - topY) * 0.5;
        const controlX = anchorX + state.bendX;
        const controlY = midY + state.bendY;
        c.save();
        c.lineCap = "round";
        c.shadowBlur = 6;
        c.shadowColor = "rgba(0, 0, 0, 0.25)";
        c.strokeStyle = "rgba(22, 110, 62, 0.85)";
        c.lineWidth = 3.2;
        c.beginPath();
        c.moveTo(topX, topY);
        c.quadraticCurveTo(controlX, controlY, anchorX, anchorY);
        c.stroke();

        c.shadowBlur = 0;
        c.strokeStyle = "rgba(70, 165, 115, 0.55)";
        c.lineWidth = 1.1;
        c.beginPath();
        c.moveTo(topX + 1, topY);
        c.quadraticCurveTo(controlX + 1.5, controlY, anchorX + 0.5, anchorY);
        c.stroke();
        c.restore();
      }

      function drawPlayerVine(c, p) {
        drawEntityVine(c, p);
      }

      const __tintCache = Object.create(null);
      /**
       * Returns a cached <canvas> with the sprite recoloured.
       * @param {HTMLImageElement} img  original sprite
       * @param {number} hueDeg         hue rotation, 0-360
       * @param {number} satMul         saturation multiplier (1 = unchanged)
       * @param {number} lumMul         luminance  multiplier (1 = unchanged)
       */
      function getTintedSprite(img, hueDeg = 0, satMul = 1, lumMul = 1) {
        const key = `${img.src}|${hueDeg}|${satMul}|${lumMul}`;
        if (__tintCache[key]) return __tintCache[key];

        const off = document.createElement("canvas");
        off.width = img.naturalWidth;
        off.height = img.naturalHeight;
        const oc = off.getContext("2d");
        oc.drawImage(img, 0, 0);

        const id = oc.getImageData(0, 0, off.width, off.height);
        const d = id.data;
        const H = (hueDeg % 360) / 360;

        // helpers
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        for (let i = 0; i < d.length; i += 4) {
          // --- RGB ‚ûú HSL ---
          let r = d[i] / 255,
            g = d[i + 1] / 255,
            b = d[i + 2] / 255;

          const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          let h,
            s,
            l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const diff = max - min;
            s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);
            switch (max) {
              case r:
                h = ((g - b) / diff + (g < b ? 6 : 0)) / 6;
                break;
              case g:
                h = ((b - r) / diff + 2) / 6;
                break;
              case b:
                h = ((r - g) / diff + 4) / 6;
                break;
            }
          }

          // --- shift hue / sat / lum ---
          h = (h + H) % 1;
          s = Math.min(s * satMul, 1);
          l = Math.min(l * lumMul, 1);

          // --- HSL ‚ûú RGB ---
          if (s === 0) {
            r = g = b = l; // grey
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }

          d[i] = r * 255;
          d[i + 1] = g * 255;
          d[i + 2] = b * 255; // alpha (d[i+3]) unchanged
        }
        oc.putImageData(id, 0, 0);

        return (__tintCache[key] = off);
      }

      const calculateFishScore = (sz) => Math.floor(sz);
      const totalFishWeight = fishTypes.reduce((s, f) => s + f.weight, 0);

      function getRandomWeightedFishType(arr, randFn = Rand) {
        let r = randFn() * totalFishWeight;
        for (const ft of arr) {
          if (r < ft.weight) return ft;
          r -= ft.weight;
        }
        return arr[arr.length - 1];
      }

      function getRockSpeed(size) {
        const t =
          (size - ROCK_MIN_SIZE) / Math.max(ROCK_MAX_SIZE - ROCK_MIN_SIZE, 1);
        const clamped = Math.max(0, Math.min(1, t));
        return ROCK_MAX_SPEED - clamped * (ROCK_MAX_SPEED - ROCK_MIN_SPEED);
      }

      function tagEntity(ent, type, manualIdx = null) {
        ent.spawnIdx = manualIdx !== null ? manualIdx : globalSpawnIdx++;
        ent.spawnType = type;
        return ent;
      }

      /* ---------- canvas-filter capability ---------- */
      const CAN_FILTER = (() => {
        try {
          const testCtx = document.createElement("canvas").getContext("2d");
          testCtx.filter = "brightness(2)"; // will be ignored if unsupported
          return testCtx.filter === "brightness(2)";
        } catch (_) {
          return false;
        }
      })();

      /********************* NEW  ‚Äî SPAWN SPEC GENERATOR ********************/
      const SPAWN_SPEC_WEIGHTS = [
        { kind: "fish", weight: 0.881 },
        { kind: "crab", weight: 0.00147 },
        { kind: "gorilla", weight: 0.002 },
        { kind: "jelly", weight: 0.0294 },
        { kind: "snake", weight: 0.0147 },
        // { kind: "sushi", weight: 0.0147 },
        { kind: "borgy", weight: 0.00735 },
        { kind: "polly", weight: 0.00735 }, //¬†<<< NEW
        { kind: "puffer", weight: 0 }, // disabled: keep code, stop spawning
      ];
      const TOTAL_SPEC_WEIGHT = SPAWN_SPEC_WEIGHTS.reduce(
        (s, w) => s + w.weight,
        0
      );

      function nextSpawnSpec() {
        let r = specRand() * TOTAL_SPEC_WEIGHT;
        for (const w of SPAWN_SPEC_WEIGHTS) {
          if (r < w.weight) return generateSpecByKind(w.kind);
          r -= w.weight;
        }
        return generateSpecByKind("fish");
      }

      function generateSpecByKind(kind) {
        switch (kind) {
          case "fish":
            return generateFishSpec();
          case "crab":
            return { kind: "crab", size: getSpecRandom(50, 120) };
          case "gorilla":
            return { kind: "gorilla", size: GORILLA_SIZE };
          case "jelly":
            return { kind: "jelly", size: getSpecRandom(30, 80) };
          case "snake":
            return { kind: "snake", size: getSpecRandom(40, 90) };
          case "sushi":
            return { kind: "sushi", fromLeft: specRand() < 0.5 };
          case "borgy":
            return { kind: "borgy", fromLeft: specRand() < 0.5 };
          case "puffer": {
            const baseSize = getSpecRandom(30, 60);
            const fromLeft = specRand() < 0.5;
            return { kind: "puffer", baseSize, fromLeft };
          }
          case "polly":
            return { kind: "polly", fromLeft: specRand() < 0.5 };
        }
      }

      function generateFishSpec() {
        const t = getRandomWeightedFishType(fishTypes, specRand);
        const size = getSpecRandom(t.minSize, t.maxSize);
        const fromLeft = specRand() < 0.5;
        const ultras = specRand();
        const ultra = ultras < 0.01;
        const fast = !ultra && ultras < 0.04;
        const sizeFactor = 1 - size / 500;
        const minSpd = 0.3 + 0.5 * sizeFactor;
        const maxSpd = 1.5 + 0.3 * sizeFactor;
        const baseSpeed = getSpecRandom(minSpd, maxSpd);
        return {
          kind: "fish",
          fishTypeIndex: fishTypes.indexOf(t),
          size,
          fromLeft,
          ultra,
          fast,
          baseSpeed,
        };
      }

      function spawnEntityFromSpec(spec, idx) {
        switch (spec.kind) {
          case "fish": {
            const t = fishTypes[spec.fishTypeIndex];
            const size = spec.size;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, Math.max(0, HEIGHT - size));
            // let spd = spec.baseSpeed * (0.4 + 0.6 * Math.min(score / 1000, 1));
            // if (spec.ultra) spd *= 5;
            // else if (spec.fast) spd *= 3;
            // spd = fromLeft ? spd : -spd;

            // ‚ë†‚ÄÜBase ramp‚Äëup (unchanged): 0‚ÄØ‚Üí‚ÄØ1√ó between 0‚Äë1‚ÄØ000 pts
            const baseMult = 0.4 + 0.6 * Math.min(score / 1000, 1);

            /*
             * ‚ë°‚ÄÜExtra ramp‚Äëup: starts once the player is already at
             *    the ‚Äúfull‚Äù base speed (‚â•1‚ÄØ000‚ÄØpts) and rises linearly
             *    to +25‚ÄØ% at 100‚ÄØ000‚ÄØpts.
             *
             *    ‚Äì We use the range 1‚ÄØ000‚ÄØ‚Üí‚ÄØ100‚ÄØ000¬†pts (Œî¬†=¬†99‚ÄØ000).
             *    ‚Äì Slope = 0.25 / 99‚ÄØ000  (‚âà‚ÄØ2.53‚ÄØe‚Äë6 per point)
             *    ‚Äì Continues past 100‚ÄØ000¬†pts with the same slope,
             *      so the reset-round at 100‚ÄØk does **not** roll it back.
             */
            const extraMult = (Math.max(score - 1000, 0) / 99000) * 0.25; // linear 0¬†‚Üí¬†0.25¬†‚Üí¬†‚Ä¶

            // ‚ë¢‚ÄÜTotal multiplier
            let spd =
              spec.baseSpeed * (baseMult + extraMult) * enemySpeedMultiplier;

            // keep the existing ‚Äúfast / ultra‚Äù modifiers & direction
            if (spec.ultra) spd *= 5;
            else if (spec.fast) spd *= 3;
            spd = fromLeft ? spd : -spd;

            const fish = tagEntity(
              new Fish(x, y, spd, 0, t.image, size, false),
              "fish",
              idx
            );
            fish.fishType = t;
            fish.isUltraFast = spec.ultra;
            fish.isFast = spec.fast;
            fish.isVineSwinging = !!t.vines;
            fish.useChipJellySprite = !!t.useChipJellySprite;
            fishList.push(fish);
            break;
          }
          case "crab": {
            const size = spec.size;
            fishList.push(
              tagEntity(
                new Crab(getRandom(0, WIDTH - size), HEIGHT + size, size),
                "crab",
                idx
              )
            );
            playCrabSpawnSound();
            break;
          }
          case "gorilla": {
            const size = spec.size ?? GORILLA_SIZE;
            const maxX = Math.max(0, WIDTH - size);
            const x = getRandom(0, maxX);
            const targetY = Math.max(0, HEIGHT - size);
            const y = HEIGHT + size;
            fishList.push(
              tagEntity(new Gorilla(x, y, size, targetY), "gorilla", idx)
            );
            playGorillaSpawnSound();
            break;
          }
          case "jelly": {
            const size = spec.size;
            fishList.push(
              tagEntity(
                new Jellyfish(getRandom(0, WIDTH - size), -size, size),
                "jelly",
                idx
              )
            );
            break;
          }
          case "snake": {
            const size = spec.size;
            fishList.push(
              tagEntity(
                new Snake(getRandom(0, WIDTH - size), HEIGHT + size, size),
                "snake",
                idx
              )
            );
            break;
          }
          case "sushi": {
            const size = 30;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, HEIGHT - size);
            const spd = (fromLeft ? 1 : -1) * 1.5;
            fishList.push(tagEntity(new Sushi(x, y, spd), "sushi", idx));
            break;
          }
          case "borgy": {
            const size = CHIPPY_SIZE;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, HEIGHT - size);
            const spd = (fromLeft ? 1 : -1) * 1.2;
            fishList.push(tagEntity(new Borgy(x, y, spd), "borgy", idx));
            playBorgySpawnSound();
            break;
          }
          case "puffer": {
            const baseSize = spec.baseSize;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -baseSize : WIDTH;
            const y = getRandom(0, HEIGHT - baseSize);
            const spd =
              getRandom(0.2, 1.2) * enemySpeedMultiplier * (fromLeft ? 1 : -1);
            fishList.push(
              tagEntity(new Pufferfish(x, y, spd, baseSize), "puffer", idx)
            );
            break;
          }
          case "polly": {
            const size = POLLY_SIZE;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, HEIGHT - size);
            const spd = (fromLeft ? 1 : -1) * 1.2;
            fishList.push(tagEntity(new Polly(x, y, spd), "polly", idx));
            playPollySpawnSound(); // <-- add this
            break;
          }
        }
      }

      /*********************   SCHEDULED SPAWN PROCESSOR   *********************/
      function processScheduledSpawns() {
        ensureScheduleAhead();
        while (
          nextScheduleIdx < spawnSchedule.length &&
          spawnSchedule[nextScheduleIdx].spawnTime <= gameTime
        ) {
          const entry = spawnSchedule[nextScheduleIdx];
          const spec = entry.spec;

          /* Difficulty / cap rule checks */
          const maxEnemies = score < 1000 ? 20 : 30;
          const isEnemy =
            spec.kind !== "sushi" &&
            spec.kind !== "borgy" &&
            spec.kind !== "crab" &&
            spec.kind !== "gorilla";
          if (isEnemy && fishList.length >= maxEnemies) {
            nextScheduleIdx++;
            continue;
          }
          if (
            (spec.kind === "crab" || spec.kind === "gorilla") &&
            score < 2000
          ) {
            nextScheduleIdx++;
            continue;
          }

          spawnEntityFromSpec(spec, entry.idx);
          nextScheduleIdx++;
        }

        /* Recycle old schedule entries */
        if (nextScheduleIdx > RETAIN_SCHEDULE_ENTRIES) {
          const removeCount = nextScheduleIdx - RETAIN_SCHEDULE_ENTRIES;
          spawnSchedule.splice(0, removeCount);
          nextScheduleIdx -= removeCount;
        }
      }

      /*********************    CLASS DEFINITIONS  *************************/
      /* ---- WaterTrail ---- */
      class WaterTrail {
        constructor(
          x,
          y,
          dir,
          fishSize,
          isUltra = false,
          colorRGB = null,
          isVertical = false
        ) {
          this.x = x;
          this.y = y;
          const base = Math.min(12, Math.max(3, fishSize * 0.08));
          this.length = base * getRandom(2.5, 4);
          this.thickness = Math.max(1, base * 0.25);
          this.life = 1;
          this.fadeSpeed = getRandom(0.02, 0.04);
          this.dir = dir;
          this.isVertical = isVertical;
          this.offsetX = getRandom(-3, 3);
          this.offsetY = getRandom(-3, 3);
          this.isUltra = isUltra;
          this.colorRGB = colorRGB;
          this.hue = Rand() * 360;
          this.hueSpeed = getRandom(2, 4);
        }
        update(dt) {
          this.life -= this.fadeSpeed * dt * 60;
          if (this.isVertical) {
            this.y += this.dir * 0.5 * dt * 60;
          } else {
            this.x += this.dir * 0.5 * dt * 60;
          }
          if (this.isUltra) this.hue = (this.hue + this.hueSpeed) % 360;
        }
        draw(c) {
          // if (this.life <= 0) return;
          /* ---- safety: bail if any value is non‚Äëfinite ---- */
          if (
            !Number.isFinite(this.x) ||
            !Number.isFinite(this.y) ||
            !Number.isFinite(this.length) ||
            !Number.isFinite(this.thickness)
          )
            return;
          const cx = this.x + this.offsetX;
          const cy = this.y + this.offsetY;
          const half = this.length * 0.5;
          c.beginPath();
          if (this.isVertical) {
            c.moveTo(cx, cy - half);
            c.lineTo(cx, cy + half);
          } else {
            c.moveTo(cx - half, cy);
            c.lineTo(cx + half, cy);
          }

          c.strokeStyle = `rgba(255,255,255,${this.life * 0.15})`;
          c.shadowBlur = 0;
          c.lineWidth = this.thickness;
          c.lineCap = "round";
          c.stroke();
          c.shadowBlur = 0;
        }
      }

      /* ---- PoisonParticle ---- */
      class PoisonParticle {
        constructor(x, y, vx, vy, size, ttl) {
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.size = size;
          this.life = ttl;
          this.ttl = ttl;
        }
        update(dt) {
          const df = dt * 60;
          this.life -= dt;
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.vx *= Math.pow(0.96, df);
          this.vy *= Math.pow(0.96, df);
        }
        draw(c) {
          if (this.life <= 0) return;
          if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;
          const alpha = Math.max(0, this.life / this.ttl);
          c.save();
          c.shadowBlur = 10;
          c.shadowColor = `rgba(${POISON_TRAIL_COLOR.r},${POISON_TRAIL_COLOR.g},${POISON_TRAIL_COLOR.b},${alpha})`;
          c.fillStyle = `rgba(${POISON_TRAIL_COLOR.r},${POISON_TRAIL_COLOR.g},${
            POISON_TRAIL_COLOR.b
          },${alpha * 0.9})`;
          c.beginPath();
          c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          c.fill();
          c.restore();
        }
      }

      function spawnPoisonParticles(x, y, dir) {
        const count = Math.floor(getRandom(6, 10));
        for (let i = 0; i < count; i++) {
          const jitterX = getRandom(-6, 6);
          const jitterY = getRandom(-6, 6);
          const vx = getRandom(-18, 18);
          const baseVy = dir >= 0 ? getRandom(12, 30) : getRandom(-30, -12);
          const vy = baseVy + getRandom(-8, 8);
          const size = getRandom(1.8, 3.4);
          const ttl = getRandom(0.35, 0.6);
          poisonParticles.push(
            new PoisonParticle(x + jitterX, y + jitterY, vx, vy, size, ttl)
          );
        }
        if (poisonParticles.length > MAX_POISON_PARTICLES) {
          poisonParticles.splice(
            0,
            poisonParticles.length - MAX_POISON_PARTICLES
          );
        }
      }

      /* ---- Fish (base + player) ---- */
      class Fish {
        constructor(x, y, sx, sy, img, maxSide, isPlayer = false) {
          this.baseSprite = img;
          this.x = x;
          this.y = y;
          this.speedX = sx;
          this.speedY = sy;
          this.sprite = img;
          this.maxSide = maxSide;
          this.isPlayer = isPlayer;
          this.lastTrailTime = 0;
          this.isFast =
            this.isUltraFast =
            this.isCrab =
            this.isJellyfish =
            this.isSushi =
            this.isBorgy =
            this.isPuffer =
            this.isPolly =
            this.isPollyHelper =
            this.isGorilla =
              false;
          this.drawFullHeight = false;
          if (!isPlayer) {
            this.oscSpd = getRandom(0.005, 0.01);
            this.oscAmt = getRandom(0.05, 0.1);
            this.oscOff = getRandom(0, Math.PI * 2);
            this.accel = 0.05;
            this.maxSpd = Math.abs(sx) * 1.2;
          } else {
            this.vx = this.vy = 0;
            this.accel = 0.055;
            this.friction = 0.99;
            this.baseMaxSpd = 10;
            this.maxSpd = this.baseMaxSpd;
            this.facingLeft = false;
          }
          this.width = this.height = null;
        }
        calculateDimensions() {
          const w = this.sprite.naturalWidth,
            h = this.sprite.naturalHeight;
          if (!w || !h) {
            this.width = this.height = this.maxSide;
            return;
          }
          const asp = w / h;
          if (asp > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / asp;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * asp;
          }
        }
        draw(c) {
          if (!this.sprite.complete) return;
          // sprite finished downloading but failed? ‚Äì also skip it
          if (!this.sprite.naturalWidth || !this.sprite.naturalHeight) return;
          if (this.width === null || this.height === null)
            this.calculateDimensions();

          if (this.isPlayer) {
            if (Math.abs(this.vx) > 0.1) this.facingLeft = this.vx < 0;
          }
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;

          const ultra =
            this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
          const boostRemaining =
            borgyPowerUpTime > 0 ? borgyPowerUpTime : sushiPowerUpTime;
          const flickerActive =
            this.isPlayer && playerIsPoweredUp && boostRemaining <= 3;

          c.save();
          if (movingLeft) {
            c.translate(this.x + this.width / 2, this.y + this.height / 2);
            c.scale(-1, 1);
            c.translate(-this.width / 2, -this.height / 2);
          } else c.translate(this.x, this.y);

          // NEW: Select appropriate sprite for player based on state
          let imgToDraw = this.sprite;
          let useFilter = true; // Whether to apply CSS filters

          /* Enemy re‚Äëskin while Borgy power‚Äëup is active */
          const isJellyTarget =
            this.isJellyfish || this.isElectric || this.useChipJellySprite;
          const chipSprite =
            isJellyTarget &&
            chipJellyImg.complete &&
            chipJellyImg.naturalWidth > 0
              ? chipJellyImg
              : chipImg;
          if (
            !this.isPlayer &&
            !this.isPolly && // ‚¨ÖÔ∏è  NEW
            !this.isBorgy && // ‚¨ÖÔ∏è  NEW (Chippy itself)
            !this.isPollyHelper &&
            !this.isGorilla &&
            borgyPowerUpTime > 0 &&
            chipSprite.complete &&
            chipSprite.naturalWidth > 0
          ) {
            imgToDraw = chipSprite;
            useFilter = false; // no colour tweaks on Chip sprite
            this.drawFullHeight = true;
          } else {
            // when the potion is gone, go back to normal drawing
            // Power‚Äëup ended: clear the flag *only* for the Chip skin itself.
            // Frozen sprites (or anything else) keep their own setting.
            if (this.sprite === chipImg || this.sprite === chipJellyImg) {
              this.drawFullHeight = false;
            }
          }

          if (this.isPlayer) {
            if (
              playerParalyzedImg.complete &&
              playerParalyzedImg.naturalWidth > 0 &&
              playerParalyzeTime > 0
            ) {
              imgToDraw = playerParalyzedImg;
              useFilter = false; // Don't apply filter since we have a custom sprite
            } else if (
              playerBorgyImg.complete &&
              playerBorgyImg.naturalWidth > 0 &&
              borgyPowerUpTime > 0
            ) {
              imgToDraw = playerBorgyImg;
              useFilter = false;
            } else if (
              playerPoweredUpImg.complete &&
              playerPoweredUpImg.naturalWidth > 0 &&
              sushiPowerUpTime > 0
            ) {
              imgToDraw = playerPoweredUpImg;
              useFilter = false;
            }
          }

          // Apply filters only if we're using the original sprite or for non-player entities
          if (useFilter) {
            if (this.isPlayer && playerParalyzeTime > 0) {
              c.filter = "hue-rotate(30deg) brightness(1.4) saturate(1.8)";
            } else if (this.isPlayer && borgyPowerUpTime > 0) {
              c.filter = "hue-rotate(100deg) brightness(2) saturate(3)";
            } else if (ultra) {
              c.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
            } else if (this.isFast) {
              c.filter = "hue-rotate(45deg) brightness(1.2)";
            }
          }

          if (flickerActive) {
            // Toggle every 100 ms ‚Üí full opacity vs almost invisible
            const blinkVisible =
              (Math.floor(performance.now() / 100) & 1) === 0;
            c.globalAlpha = blinkVisible ? 1 : 0.15; // 0.15 ‚âà "off" frame
            // keep the desaturate/brightness tweak so the colour shift remains
            if (useFilter) {
              c.filter =
                (c.filter ? c.filter + " " : "") +
                "brightness(0.7) contrast(0.9)";
            }
          }

          /* ---------- BEGIN filtered / fallback draw ---------- */
          if (!CAN_FILTER && useFilter) {
            // Decide which tint, mimicking the original filter stacks
            let tintParams = null; // [hueDeg, satMul, lumMul]
            if (this.isPlayer && playerParalyzeTime > 0)
              tintParams = [30, 1.8, 1.4]; // yellow-ish
            else if (this.isPlayer && borgyPowerUpTime > 0)
              tintParams = [100, 3.0, 2.0]; // green boost
            else if (ultra) tintParams = [180, 2.0, 1.5]; // rainbow-fish
            else if (this.isFast) tintParams = [45, 1.2, 1.2]; // quick fish

            if (tintParams) {
              const [h, s, l] = tintParams;
              imgToDraw = getTintedSprite(this.sprite, h, s, l);
            }
          }
          /* ---------- draw sprite (original or tinted) ---------- */

          // NEW ‚ÄØ‚Äì‚ÄØ keep the sprite‚Äôs natural aspect‚Äëratio when requested
          let drawW = this.width; // logical width (physics)
          let drawH = this.height; // logical height
          let offset = 0; // centred shift if needed

          if (this.drawFullHeight && this.sprite.naturalHeight) {
            const scale = this.height / this.sprite.naturalHeight; // stretch to full height
            drawW = this.sprite.naturalWidth * scale; // preserve aspect
            offset = (this.width - drawW) / 2; // centre inside hit‚Äëbox
          }

          c.drawImage(imgToDraw, offset, 0, drawW, drawH);
          /* ---------- END patch ---------- */

          c.restore();
        }
        getBounds() {
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          const scale = 0.6,
            rX = (this.width * scale) / 2,
            rY = (this.height * scale) / 2;
          let cX = this.x + this.width / 2,
            cY = this.y + this.height / 2;
          const shift = this.width * 0.07;
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;
          if (movingLeft) cX -= shift;
          else cX += shift;
          return { centerX: cX, centerY: cY, radiusX: rX, radiusY: rY };
        }
        update(dt) {
          const df = dt * 60;
          if (this.isPlayer) {
            let speedMult = 1;
            if (borgyPowerUpTime > 0) speedMult = BORGY_SPEED_MULT;
            this.maxSpd = this.baseMaxSpd * speedMult;

            const f = Math.pow(this.friction, df);
            this.vx *= f;
            this.vy *= f;
            this.x += this.vx * df;
            this.y += this.vy * df;
            if (this.width && this.height) {
              if (this.x < 0) {
                this.x = 0;
                this.vx = 0;
              }
              if (this.y < 0) {
                this.y = 0;
                this.vy = 0;
              }
              if (this.x + this.width > WIDTH) {
                this.x = WIDTH - this.width;
                this.vx = 0;
              }
              if (this.y + this.height > HEIGHT) {
                this.y = HEIGHT - this.height;
                this.vy = 0;
              }
            }
          } else {
            const osc =
              Math.sin(performance.now() * this.oscSpd + this.oscOff) *
              this.oscAmt;
            if (!this.isJellyfish && !this.isCrab && !this.isPollyHelper) {
              this.speedX +=
                this.accel *
                Math.sign(this.speedX) *
                df *
                (Math.abs(this.speedX) < this.maxSpd ? 1 : 0);
              if (Math.abs(this.speedX) > this.maxSpd)
                this.speedX = Math.sign(this.speedX) * this.maxSpd;
              this.x += this.speedX * df;
              this.y += osc * df;
            }
          }
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 50) return;
          this.lastTrailTime = now;
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;
          const speed = this.isPlayer
            ? Math.hypot(this.vx, this.vy)
            : Math.abs(this.speedX);
          if (speed > 0.5) {
            const ultra =
              this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
            const count = ultra ? 2 : Rand() < 0.3 ? 1 : 0;
            for (let i = 0; i < count; i++) {
              waterTrails.push(
                new WaterTrail(
                  this.x + (movingLeft ? this.width : 0),
                  this.y + this.height * 0.5,
                  movingLeft ? 1 : -1,
                  this.maxSide,
                  ultra
                )
              );
              if (waterTrails.length > MAX_WATER_TRAILS) {
                waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
              }
            }
          }
        }
      }

      /* ---- Crab ---- */
      class Crab extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, 0, crabImg, size, false);
          this.isCrab = true;
          this.entered = false;
          this.timeAlive = 0;
          this.remove = false;
        }
        update(dt, player) {
          if (this.remove) return;
          const df = dt * 60;
          if (!this.entered) {
            this.y -= 2 * enemySpeedMultiplier * df;
            if (this.y + this.height <= HEIGHT) this.entered = true;
            return;
          }
          this.timeAlive += dt;
          if (this.timeAlive > 15) {
            spawnExplosion(this);
            this.remove = true;
            return;
          }
          const c = this.getBounds(),
            p = player.getBounds();
          const dx = p.centerX - c.centerX,
            dy = p.centerY - c.centerY,
            dist = Math.hypot(dx, dy) || 1;
          const s = 1.5 * enemySpeedMultiplier;
          if (c.radiusX > p.radiusX) {
            this.x += (dx / dist) * s * df;
            this.y += (dy / dist) * s * df;
          } else {
            this.x -= (dx / dist) * s * df;
            this.y -= (dy / dist) * s * df;
          }
          if (this.width && this.height) {
            this.x = Math.min(Math.max(0, this.x), WIDTH - this.width);
            this.y = Math.min(Math.max(0, this.y), HEIGHT - this.height);
          }
        }
      }

      /* ---- Jellyfish ---- */
      class Jellyfish extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, -1.2, jellyfishImg, size, false);
          this.frozenSprite = jellyfishFrozenImg;
          this.isJellyfish = true;
          this.oscS = getRandom(0.0008, 0.0015);
          this.oscA = getRandom(10, 15);
          this.oscO = Rand() * Math.PI * 2;
          this.baseX = x;
          this.vSpeed = getRandom(0.5, 1.2) * enemySpeedMultiplier;
          this.verticalDir = 1; // regular jellyfish move top -> bottom
          this.webRising = false;
          this.webRiseOffset = 0;
          this.webRiseSpeed = 240;
          this.webAnchorX = x + size / 2;
          this.webEndY = y + size * 0.35;
          this.hideBody = false;
        }
        startWebRise() {
          if (this.webRising) return;
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          const w = this.width ?? this.maxSide;
          const h = this.height ?? this.maxSide;
          this.webRising = true;
          this.webRiseOffset = 0;
          this.webAnchorX = this.x + w / 2;
          this.webEndY = this.y + h * 0.35;
          this.hideBody = true;
          this.noCollision = true;
        }
        draw(c) {
          if (!this.isElectric) {
            if (this.width == null || this.height == null)
              this.calculateDimensions();
            const w = this.width ?? this.maxSide;
            const h = this.height ?? this.maxSide;
            const lineX = this.webRising ? this.webAnchorX : this.x + w / 2;
            const lineEndY = this.webRising
              ? this.webEndY - this.webRiseOffset
              : this.y + h * 0.35;
            const lineStartY = this.webRising ? -10 - this.webRiseOffset : -10;
            c.save();
            c.strokeStyle = "rgba(255,255,255,0.7)";
            c.lineWidth = 1;
            c.beginPath();
            c.moveTo(lineX, lineStartY);
            c.lineTo(lineX, lineEndY);
            c.stroke();
            c.restore();
          }
          if (!this.hideBody) super.draw(c);
        }
        update(dt) {
          if (this.webRising) {
            this.webRiseOffset += this.webRiseSpeed * dt;
            if (this.webEndY - this.webRiseOffset < -20) {
              this.remove = true;
            }
            return;
          }
          const df = dt * 60;
          this.y += this.vSpeed * df * this.verticalDir;
          this.x =
            this.baseX +
            Math.sin(performance.now() * this.oscS + this.oscO) * this.oscA;
          const h = this.height ?? this.maxSide;
          if (!this.isElectric) {
            if (this.verticalDir < 0) {
              if (this.y + h < -50) this.startWebRise();
            } else {
              if (this.y > HEIGHT + 50) this.startWebRise();
            }
          } else {
            if (this.verticalDir < 0) {
              if (this.y + h < -50) this.maxSide = 0;
            } else {
              if (this.y > HEIGHT + 50) this.maxSide = 0;
            }
          }
        }
        createWaterTrail() {
          if (this.webRising) return;
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 55) return;
          this.lastTrailTime = now;
          const movingDown = this.verticalDir >= 0;
          const trailDir = movingDown ? -1 : 1;
          const trailY = movingDown ? this.y : this.y + this.height;
          spawnPoisonParticles(this.x + this.width / 2, trailY, trailDir);
        }
      }

      /* ---- Electric Jellyfish ---- */
      class ElectricJellyfish extends Jellyfish {
        constructor(x, y, size) {
          super(x, y, size);
          this.frozenSprite = electricJellyFrozenImg;
          this.sprite = electricJellyfishImg;
          this.isElectric = true;
          this.verticalDir = -1; // electric jellyfish move bottom -> top
          this.pulseCooldown = getRandom(5, 12);
          this.pauseTimeRemaining = 0;
          this.pulseRadius = size * 2.3;
        }
        update(dt) {
          if (this.pauseTimeRemaining > 0) {
            this.pauseTimeRemaining -= dt;
            if (this.pauseTimeRemaining <= 0) {
              this.pauseTimeRemaining = 0;
              // thaw out frozen enemies
              const phase = Math.sin(performance.now() * this.oscS + this.oscO);
              this.baseX = this.x - phase * this.oscA;
              this.pulseCooldown = getRandom(5, 12);
            }
            return;
          }
          this.pulseCooldown -= dt;
          if (this.pulseCooldown <= 0) {
            this.performPulse();
            return;
          }
          super.update(dt);
        }
        performPulse() {
          this.pauseTimeRemaining = 1;
          this.pulseCooldown = getRandom(5, 12);
          playElectricSound();
          const p = player.getBounds();
          const b = this.getBounds();
          const dx = p.centerX - b.centerX;
          const dy = p.centerY - b.centerY;
          const dist = Math.hypot(dx, dy);
          if (dist <= this.pulseRadius && borgyPowerUpTime <= 0) {
            playerParalyzeTime = PARALYZE_DURATION;
            playerParalyzeCause = "electric";
            playShockSound();
          }
        }
        draw(c) {
          super.draw(c);
          if (this.pauseTimeRemaining > 0 && this.width && this.height) {
            const alpha = this.pauseTimeRemaining;
            const cx = this.x + this.width / 2;
            const cy = this.y + this.height / 2;
            const maxLen = this.pulseRadius * (1 - alpha * 0.25);
            const bolts = 10;
            const segmentsPerBolt = 3;
            c.save();
            for (let i = 0; i < bolts; i++) {
              const baseAngle = (i / bolts) * Math.PI * 2;
              let prevX = cx,
                prevY = cy;
              for (let s = 1; s <= segmentsPerBolt; s++) {
                const segLen = (maxLen / segmentsPerBolt) * s;
                const jitter = segLen * 0.25;
                const angle = baseAngle + getRandom(-0.2, 0.2);
                const x =
                  cx + Math.cos(angle) * segLen + getRandom(-jitter, jitter);
                const y =
                  cy + Math.sin(angle) * segLen + getRandom(-jitter, jitter);
                c.beginPath();
                c.moveTo(prevX, prevY);
                c.lineTo(x, y);
                c.strokeStyle = `rgba(255,255,0,${alpha})`;
                c.lineWidth = 2;
                c.shadowBlur = 8;
                c.shadowColor = `rgba(255,255,0,${alpha})`;
                c.stroke();
                prevX = x;
                prevY = y;
              }
            }
            c.restore();
          }
        }
        createWaterTrail() {
          if (this.webRising) return;
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 80) return;
          this.lastTrailTime = now;
          const movingDown = this.verticalDir >= 0;
          const trailDir = movingDown ? -1 : 1;
          const trailY = movingDown ? this.y : this.y + this.height;
          waterTrails.push(
            new WaterTrail(
              this.x + this.width / 2,
              trailY,
              trailDir,
              this.maxSide * 0.4,
              false,
              { r: 255, g: 255, b: 0 },
              true
            )
          );
          if (waterTrails.length > MAX_WATER_TRAILS)
            waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
        }
      }

      /* ---- Snake ---- */
      class Snake extends Jellyfish {
        constructor(x, y, size) {
          super(x, y, size);
          this.sprite = snakeImg;
          this.frozenSprite = frozenPlaceholderImg;
          this.isSnake = true;
          this.isElectric = false;
          this.verticalDir = -1; // climb up
          this.vineBaseX = x + size / 2;
          this.vineX = this.vineBaseX;
          this.vineProgress = 0;
          this.vineFalling = false;
          this.vineFallOffset = 0;
          this.vineFallVelocity = 0;
          this.hideBody = false;
          this.noCollision = false;
          this.vineSwayPhase = Rand() * Math.PI * 2;
          this.vineSwaySpeed = getRandom(0.6, 1.1);
          this.vineSwayAmp = getRandom(1.5, 4.5);
          this.vineCurveSpeed = this.vineSwaySpeed * getRandom(0.8, 1.3);
          this.vineCurveAmp = getRandom(4, 10);
        }
        getVineX(now = performance.now()) {
          const t = now / 1000;
          return (
            this.vineBaseX +
            Math.sin(t * this.vineSwaySpeed + this.vineSwayPhase) *
              this.vineSwayAmp
          );
        }
        startVineFall() {
          if (this.vineFalling) return;
          this.vineFalling = true;
          this.vineProgress = 1;
          this.vineFallOffset = 0;
          this.vineFallVelocity = 0;
          this.hideBody = true;
          this.noCollision = true;
        }
        update(dt) {
          if (this.vineFalling) {
            this.vineFallVelocity += SNAKE_VINE_FALL_ACCEL * dt;
            this.vineFallVelocity *= Math.pow(SNAKE_VINE_FALL_DRAG, dt * 60);
            this.vineFallOffset += this.vineFallVelocity * dt;
            if (this.vineFallOffset > HEIGHT + 80) {
              this.remove = true;
            }
            return;
          }
          if (this.vineProgress < 1) {
            this.vineProgress = Math.min(
              1,
              this.vineProgress + dt / SNAKE_VINE_DROP_DURATION
            );
            if (this.vineProgress < 1) return;
          }
          const df = dt * 60;
          this.y += this.vSpeed * df * this.verticalDir;
          if (this.width == null || this.height == null) {
            this.calculateDimensions();
          }
          this.vineX = this.getVineX();
          const w = this.width ?? this.maxSide;
          this.x = this.vineX - w / 2;
          const h = this.height ?? this.maxSide;
          if (this.verticalDir < 0) {
            if (this.y + h < -50) this.startVineFall();
          } else {
            if (this.y > HEIGHT + 50) this.startVineFall();
          }
        }
        draw(c) {
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          const now = performance.now();
          const vineX = Number.isFinite(this.vineX)
            ? this.vineX
            : this.getVineX(now);
          const topY = -20;
          const fullLen = HEIGHT + 60;
          let startY = topY;
          let endY = topY + fullLen * (this.vineProgress || 0);
          if (this.vineFalling) {
            startY += this.vineFallOffset;
            endY += this.vineFallOffset;
          }
          const midY = (startY + endY) * 0.5;
          const curveAmp = this.vineCurveAmp * (this.vineFalling ? 1.4 : 1);
          const curveX =
            vineX +
            Math.sin((now / 1000) * this.vineCurveSpeed + this.vineSwayPhase) *
              curveAmp;
          c.save();
          c.lineCap = "round";
          const drawVinePath = () => {
            c.beginPath();
            c.moveTo(vineX, startY);
            c.quadraticCurveTo(curveX, midY, vineX, endY);
          };
          c.shadowBlur = 8;
          c.shadowColor = "rgba(0, 0, 0, 0.3)";
          c.strokeStyle = "rgba(10, 36, 20, 0.75)";
          c.lineWidth = 5;
          drawVinePath();
          c.stroke();
          c.shadowBlur = 0;
          c.strokeStyle = SNAKE_VINE_COLOR;
          c.lineWidth = 3.2;
          drawVinePath();
          c.stroke();
          c.strokeStyle = "rgba(90, 170, 120, 0.35)";
          c.lineWidth = 1.2;
          drawVinePath();
          c.stroke();
          c.restore();
          if (!this.hideBody) {
            Fish.prototype.draw.call(this, c);
          }
        }
        createWaterTrail() {
          if (this.vineFalling || this.vineProgress < 1) return;
          super.createWaterTrail();
        }
      }

      /* ---- Sushi ---- */
      class Sushi extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, sushiImg, 30, false);
          this.isSushi = true;
        }
      }

      /* ---- Borgy ---- */
      class Borgy extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, borgyImg, CHIPPY_SIZE, false);
          this.isBorgy = true;
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          // Create trail more frequently
          if (now - this.lastTrailTime < 25) return; // was 50ms for normal fish
          this.lastTrailTime = now;
          // Bigger, colored, and more persistent
          const movingLeft = this.speedX < 0;
          for (let i = 0; i < 3; i++) {
            // triple trail for visibility
            waterTrails.push(
              new WaterTrail(
                this.x + (movingLeft ? this.width : 0),
                this.y + this.height * (0.3 + 0.4 * Math.random()), // more spread
                movingLeft ? 1 : -1,
                this.maxSide * 1.2, // larger trail
                false,
                { r: 3, g: 176, b: 176 } // teal color #03b0b0
              )
            );
          }
          if (waterTrails.length > MAX_WATER_TRAILS) {
            waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
          }
        }
      }

      /* ---- Pufferfish ---- */
      class Pufferfish extends Fish {
        constructor(x, y, speedX, baseSize) {
          super(x, y, speedX, 0, pufferImg, baseSize, false);
          this.frozenSprite = frozenPlaceholderImg;
          this.isPuffer = true;
          this.baseSize = baseSize;
          this.inflating = false;
          this.inflateStart = 0;
          this.inflateDuration = 500;
        }
        update(dt) {
          super.update(dt);
          if (!this.inflating && this.maxSide < this.baseSize * 2.9) {
            if (Rand() < 0.0003 * dt * 60) {
              this.inflating = true;
              this.inflateStart = performance.now();
            }
          }
          if (this.inflating) {
            const elapsed = performance.now() - this.inflateStart;
            const p = Math.min(elapsed / this.inflateDuration, 1);
            const centreX = this.x + (this.width ?? this.maxSide) / 2;
            const centreY = this.y + (this.height ?? this.maxSide) / 2;
            this.maxSide = this.baseSize * (1 + 3 * p);
            this.width = this.height = null;
            this.calculateDimensions();
            this.x = centreX - this.width / 2;
            this.y = centreY - this.height / 2;
            if (p === 1) this.inflating = false;
          }
        }
      }

      /* ---- Rock (gorilla projectile) ---- */
      class Rock {
        constructor(x, y, size, vx, vy, delay = 0) {
          this.sprite = rockImg;
          this.x = x;
          this.y = y;
          this.vx = vx;
          this.vy = vy;
          this.maxSide = size;
          this.width = this.height = null;
          this.delayRemaining = delay;
        }
        calculateDimensions() {
          const w = this.sprite.naturalWidth,
            h = this.sprite.naturalHeight;
          if (!w || !h) {
            this.width = this.height = this.maxSide;
            return;
          }
          const asp = w / h;
          if (asp > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / asp;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * asp;
          }
        }
        update(dt) {
          if (this.delayRemaining > 0) {
            this.delayRemaining = Math.max(0, this.delayRemaining - dt);
            return;
          }
          const df = dt * 60;
          this.x += this.vx * df;
          this.y += this.vy * df;
        }
        getBounds() {
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          const scale = 0.7;
          return {
            centerX: this.x + this.width / 2,
            centerY: this.y + this.height / 2,
            radiusX: (this.width * scale) / 2,
            radiusY: (this.height * scale) / 2,
          };
        }
        draw(c) {
          if (!this.sprite.complete) return;
          if (!this.sprite.naturalWidth || !this.sprite.naturalHeight) return;
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          c.drawImage(this.sprite, this.x, this.y, this.width, this.height);
        }
      }

      /* ---- Gorilla ---- */
      class Gorilla extends Fish {
        constructor(x, y, size, targetY) {
          super(x, y, 0, 0, gorillaImg, size, false);
          this.isGorilla = true;
          this.targetY = targetY ?? y;
          this.inPosition = false;
          this.timeAlive = 0;
          this.throwCooldown = getRandom(GORILLA_THROW_MIN, GORILLA_THROW_MAX);
        }
        update(dt) {
          const df = dt * 60;
          if (!this.inPosition) {
            this.y -= GORILLA_RISE_SPEED * enemySpeedMultiplier * df;
            if (this.y <= this.targetY) {
              this.y = this.targetY;
              this.inPosition = true;
              this.throwCooldown = getRandom(
                GORILLA_THROW_MIN,
                GORILLA_THROW_MAX
              );
            }
            return;
          }

          this.timeAlive += dt;
          if (this.timeAlive > 15) {
            if (this.width == null || this.height == null) {
              this.calculateDimensions();
            }
            spawnExplosion(this);
            this.remove = true;
            return;
          }
          this.throwCooldown -= dt;
          if (this.throwCooldown <= 0) {
            this.throwRock();
            this.throwCooldown = getRandom(
              GORILLA_THROW_MIN,
              GORILLA_THROW_MAX
            );
          }
        }
        throwRock() {
          if (!player) return;
          if (this.width == null || this.height == null) {
            this.calculateDimensions();
          }
          if (player.width == null || player.height == null) {
            player.calculateDimensions();
          }
          const startX = this.x + this.width / 2;
          const startY = this.y + this.height * 0.2;
          const targetX = player.x + player.width / 2;
          const targetY = player.y + player.height / 2;
          const dx = targetX - startX;
          const dy = targetY - startY;
          const dist = Math.hypot(dx, dy) || 1;
          const size = getRandom(ROCK_MIN_SIZE, ROCK_MAX_SIZE);
          const speed = getRockSpeed(size);
          const vx = (dx / dist) * speed;
          const vy = (dy / dist) * speed;
          const delay = 0.35;
          rocks.push(
            new Rock(startX - size / 2, startY - size / 2, size, vx, vy, delay)
          );
          playRockThrowSound();
          if (rocks.length > MAX_ROCKS) {
            rocks.splice(0, rocks.length - MAX_ROCKS);
          }
        }
        createWaterTrail() {
          /* gorilla does not leave trails */
        }
      }

      /* ---- Polly (helper power‚Äëup) ---- */
      //¬†<<< add directly after Borgy / Pufferfish classes ---------------
      class Polly extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, pollyImg, POLLY_SIZE, false);
          this.isPolly = true;
          // no extra behaviour ‚Äì basic Fish flight path
        }
      }
      //¬†>>> ----------------------------------------------------------------

      /* ---- PollyHelper ---- */
      class PollyHelper extends Fish {
        constructor(x, size) {
          super(x, -size, 0, 0, pollyHelperImg, size, false);
          this.isPollyHelper = true;
          this.speed = 2.5;
          this.timeAlive = 0;
          this.remove = false;
        }
        update(dt) {
          if (this.remove) return;
          const df = dt * 60;
          this.timeAlive += dt;
          let minDist = Infinity;
          let nearest = null;
          for (const f of fishList) {
            if (
              f === this ||
              f.isPlayer ||
              f.isPollyHelper ||
              f.isGorilla ||
              f.remove ||
              f.maxSide <= 0
            )
              continue;
            if (f.width == null || f.height == null) {
              if (typeof f.calculateDimensions === "function") {
                f.calculateDimensions();
              }
            }
            const fWidth = f.width ?? f.maxSide;
            const fHeight = f.height ?? f.maxSide;
            if (
              f.x + fWidth < 0 ||
              f.x > WIDTH ||
              f.y + fHeight < 0 ||
              f.y > HEIGHT
            )
              continue;
            const d = Math.hypot(f.x - this.x, f.y - this.y);
            if (d < minDist) {
              minDist = d;
              nearest = f;
            }
          }
          if (nearest) {
            const myB = this.getBounds();
            const eB = nearest.getBounds();
            const dx = eB.centerX - myB.centerX;
            const dy = eB.centerY - myB.centerY;
            const dist = Math.hypot(dx, dy) || 1;
            const s = this.speed;
            const vx = (dx / dist) * s;
            const vy = (dy / dist) * s;
            this.x += vx * df;
            this.y += vy * df;
            this.speedX = vx;
            this.speedY = vy;
          }
          if (this.width && this.height) {
            this.x = Math.min(Math.max(0, this.x), WIDTH - this.width);
            this.y = Math.min(Math.max(0, this.y), HEIGHT - this.height);
          }
        }
      }

      /* ---- Explosion ---- */
      class Explosion {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.particles = [];
          this.life = 1;
          this.fadeSpeed = 0.02;
          const n = Math.floor(size * 0.5);
          for (let i = 0; i < n; i++) {
            const angle = (i / n) * Math.PI * 2,
              spd = getRandom(2, 4);
            this.particles.push({
              x: 0,
              y: 0,
              sx: Math.cos(angle) * spd,
              sy: Math.sin(angle) * spd,
              size: getRandom(3, 8),
              life: 1,
              fadeSpeed: getRandom(0.01, 0.03),
            });
          }
        }
        update(dt) {
          this.life -= this.fadeSpeed * dt * 60;
          for (const p of this.particles) {
            p.x += p.sx * dt * 60;
            p.y += p.sy * dt * 60;
            p.life -= p.fadeSpeed * dt * 60;
          }
        }
        isComplete() {
          return this.life <= 0;
        }
        draw(c) {
          if (this.isComplete()) return;
          if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;
          for (const p of this.particles) {
            if (p.life <= 0) continue;
            c.beginPath();
            c.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
            c.fillStyle = `rgba(255,255,255,${p.life * 0.8})`;
            c.fill();
          }
        }
      }

      /*********************      SPAWNERS      *****************************/
      function spawnExplosion(f) {
        if (f.width && f.height) {
          explosions.push(
            new Explosion(f.x + f.width / 2, f.y + f.height / 2, f.maxSide)
          );
          if (explosions.length > MAX_EXPLOSIONS)
            explosions.splice(0, explosions.length - MAX_EXPLOSIONS);
        }
      }

      /*********************     RESET ROUND (size)     *********************/
      function resetRound() {
        fishList = [];
        waterTrails = [];
        poisonParticles = [];
        explosions = [];
        rocks = [];
        player.maxSide = 25;
        player.width = player.height = null;
        player.x = WIDTH / 2;
        player.y = HEIGHT / 2;
        player.vx = player.vy = 0;
        sushiPowerUpTime = 0;
        borgyPowerUpTime = 0;
        playerIsPoweredUp = false;
        playerParalyzeTime = 0;
        playerParalyzeCause = null;
        pollyFreezeTime = 0;
        pollyHelper = null;
        joystick.active = false;
      }

      /*********************      GAME LOOP LOGIC      *********************/
      function checkCollisionOval(a, b) {
        const A = a.getBounds();
        const B = b.getBounds();
        if (
          A.radiusX === 0 ||
          A.radiusY === 0 ||
          B.radiusX === 0 ||
          B.radiusY === 0
        )
          return false;
        const dx = A.centerX - B.centerX;
        const dy = A.centerY - B.centerY;
        return (
          (dx * dx) / (A.radiusX + B.radiusX) ** 2 +
            (dy * dy) / (A.radiusY + B.radiusY) ** 2 <=
          1
        );
      }

      function updateGame(dt) {
        /* explosions */
        for (let i = explosions.length - 1; i >= 0; i--) {
          explosions[i].update(dt);
          if (explosions[i].isComplete()) explosions.splice(i, 1);
        }
        if (pendingGameOver && explosions.length === 0) {
          showGameOverScreen(score);
          pendingGameOver = false;
        }
        if (gameState !== "playing") return;
        if (isGameOver) return;

        /* time */
        gameTime += dt;
        gameTimeMs = Math.round(gameTime * 1000);

        /* Polly helper timer ------------------------------------------- */
        if (pollyFreezeTime > 0) {
          pollyFreezeTime -= dt;
          if (pollyFreezeTime <= 0) {
            pollyFreezeTime = 0;
            if (pollyHelper) {
              spawnExplosion(pollyHelper);
              const idx = fishList.indexOf(pollyHelper);
              if (idx !== -1) fishList.splice(idx, 1);
              pollyHelper = null;
            }
          }
        }

        /* power-up timers */
        if (sushiPowerUpTime > 0) {
          sushiPowerUpTime -= dt;
          if (sushiPowerUpTime <= 0) sushiPowerUpTime = 0;
        }
        if (borgyPowerUpTime > 0) {
          borgyPowerUpTime -= dt;
          if (borgyPowerUpTime <= 0) borgyPowerUpTime = 0;
        }
        playerIsPoweredUp = sushiPowerUpTime > 0 || borgyPowerUpTime > 0;

        if (statusMessageTime > 0) {
          statusMessageTime = Math.max(0, statusMessageTime - dt);
          if (statusMessageTime === 0) statusMessage = "";
        }

        /* status decrement */
        if (playerParalyzeTime > 0) {
          playerParalyzeTime -= dt;
          if (playerParalyzeTime <= 0) {
            playerParalyzeTime = 0;
            playerParalyzeCause = null;
          }
        }

        /* spawn processing */
        processScheduledSpawns();

        /* water trails */
        for (let i = waterTrails.length - 1; i >= 0; i--) {
          waterTrails[i].update(dt);
          if (waterTrails[i].life <= 0) waterTrails.splice(i, 1);
        }
        if (waterTrails.length > MAX_WATER_TRAILS) {
          waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
        }
        /* poison particles */
        for (let i = poisonParticles.length - 1; i >= 0; i--) {
          poisonParticles[i].update(dt);
          if (poisonParticles[i].life <= 0) poisonParticles.splice(i, 1);
        }
        if (poisonParticles.length > MAX_POISON_PARTICLES) {
          poisonParticles.splice(
            0,
            poisonParticles.length - MAX_POISON_PARTICLES
          );
        }

        /* player input */
        const canMove = playerParalyzeTime <= 0;
        const accelMult = borgyPowerUpTime > 0 ? BORGY_SPEED_MULT : 1;

        const a = player.accel * accelMult * dt * 60;

        if (canMove) {
          if (isJoystickEnabled && joystick.active) {
            const dx = joystick.stickX - joystick.baseX;
            const dy = joystick.stickY - joystick.baseY;
            const dist = Math.hypot(dx, dy);
            if (dist > 5) {
              const nx = dx / dist;
              const ny = dy / dist;
              const force = dist / joystick.radius;
              player.vx += nx * a * force;
              player.vy += ny * a * force;
            }
          } else {
            if (keys.left) player.vx -= a;
            if (keys.right) player.vx += a;
            if (keys.up) player.vy -= a;
            if (keys.down) player.vy += a;
            if (touchTarget && player.width && player.height) {
              const px = player.x + player.width / 2;
              const py = player.y + player.height / 2;
              const dx = touchTarget.x - px;
              const dy = touchTarget.y - py;
              const dist = Math.hypot(dx, dy);
              if (dist > 1) {
                player.vx += (dx / dist) * a;
                player.vy += (dy / dist) * a;
              }
            }
          }
        }

        const spd = Math.hypot(player.vx, player.vy);
        if (spd > player.maxSpd) {
          const r = player.maxSpd / spd;
          player.vx *= r;
          player.vy *= r;
        }

        /* update entities */
        player.update(dt);
        player.createWaterTrail();

        /* enemies & pickups */
        for (let i = fishList.length - 1; i >= 0; i--) {
          const e = fishList[i];
          /* honour frozen enemies (if any) ------------------------------- */
          if (!e.isPlayer && e.isFrozen) {
            // skip movement & AI ‚Äì but still let player collide with it
          } else {
            if (e.remove) {
              fishList.splice(i, 1);
              continue;
            }
            if (e instanceof ElectricJellyfish) e.update(dt);
            else if (e.isCrab) e.update(dt, player);
            else if (e.isPollyHelper) e.update(dt);
            else e.update(dt);
          }
          e.createWaterTrail();

          const b = e.getBounds();
          const skipBoundsCull = e.webRising;
          if (
            !skipBoundsCull &&
            (e.maxSide <= 0 ||
              b.centerX + b.radiusX < -200 ||
              b.centerX - b.radiusX > WIDTH + 200 ||
              e.y > HEIGHT + 200)
          ) {
            fishList.splice(i, 1);
            continue;
          }

          if (e.noCollision) continue;

          /* collision with player */
          if (checkCollisionOval(player, e)) {
            if (e.isPollyHelper || e.isGorilla) continue;
            /* --- Polly pickup ------------------------------------------ */
            if (e.isPolly) {
              score += 75;
              pollyFreezeTime = POLLY_DURATION; // helper active timer
              playPollyPowerUpSound();
              showStatusMessage("You've got help!");
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: false,
              });
              if (!pollyHelper) {
                const size = POLLY_HELPER_SIZE;
                const x = getRandom(0, WIDTH - size);
                pollyHelper = new PollyHelper(x, size);
                fishList.push(pollyHelper);
              }
              fishList.splice(i, 1);
              continue;
            }
            /* --- sushi pickup --- */
            if (e.isSushi) {
              score += 50;
              sushiPowerUpTime = SUSHI_DURATION;
              playPowerUpSound();
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });
              fishList.splice(i, 1);
              continue;
            }

            /* --- borgy pickup --- */
            if (e.isBorgy) {
              score += 75;
              borgyPowerUpTime = BORGY_DURATION;
              playBorgyPowerUpSound();
              showStatusMessage("Eat anything!");
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });
              fishList.splice(i, 1);
              continue;
            }

            if (e.isFrozen) {
              score += calculateFishScore(e.maxSide);

              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });

              // apply normal growth / side‚Äëeffects
              if (e.isJellyfish && !e.isElectric && borgyPowerUpTime <= 0) {
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }

              if (e.isElectric && borgyPowerUpTime <= 0) {
                // frozen electric still shocks!
                playerParalyzeTime = PARALYZE_DURATION;
                playerParalyzeCause = "electric";
                playShockSound();
              }

              player.width = player.height = null; // force dimension recalc
              if (
                e.isJellyfish &&
                !e.isElectric &&
                typeof e.startWebRise === "function"
              ) {
                e.startWebRise();
              } else if (e.isSnake && typeof e.startVineFall === "function") {
                e.startVineFall();
              } else {
                fishList.splice(i, 1); // remove the enemy
              }
              continue; // done with this entity
            }

            /* --- player is powered-up --- */
            if (playerIsPoweredUp) {
              score += calculateFishScore(e.maxSide);
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });

              if (e.isJellyfish && !e.isElectric && borgyPowerUpTime <= 0) {
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }

              if (e.isElectric && borgyPowerUpTime <= 0) {
                playerParalyzeTime = PARALYZE_DURATION;
                playerParalyzeCause = "electric";
                playShockSound();
              }

              player.width = player.height = null;
              // if (e.isUltraFast) {
              //   sushiPowerUpTime = SUSHI_DURATION;
              //   playPowerUpSound();
              // }
              if (
                e.isJellyfish &&
                !e.isElectric &&
                typeof e.startWebRise === "function"
              ) {
                e.startWebRise();
              } else if (e.isSnake && typeof e.startVineFall === "function") {
                e.startVineFall();
              } else {
                fishList.splice(i, 1);
              }
              continue;
            }

            /* --- no power-up, check size --- */
            const pR = player.getBounds().radiusX;
            const eR = e.getBounds().radiusX;
            if (pR * EATING_LEEWAY > eR) {
              /* player eats */
              score += calculateFishScore(e.maxSide);
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });

              if (e.isJellyfish && !e.isElectric) {
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }

              if (e.isElectric) {
                playerParalyzeTime = PARALYZE_DURATION;
                playerParalyzeCause = "electric";
                playShockSound();
              }

              player.width = player.height = null;
              // if (e.isUltraFast) {
              // sushiPowerUpTime = SUSHI_DURATION;
              // playPowerUpSound();
              // }
              if (
                e.isJellyfish &&
                !e.isElectric &&
                typeof e.startWebRise === "function"
              ) {
                e.startWebRise();
              } else if (e.isSnake && typeof e.startVineFall === "function") {
                e.startVineFall();
              } else {
                fishList.splice(i, 1);
              }
              continue;
            } else {
              /* player is eaten */
              isGameOver = true;
              touchTarget = null;
              joystick.active = false;
              gameState = "over";

              const eatenBy = e.spawnIdx ?? null;
              epochGameEndTime = Date.now();

              sendScoreToAPI(
                score,
                eatenEvents,
                currentSessionId,
                gameTimeMs,
                eatenBy,
                epochGameStartTime,
                epochGameEndTime
              );

              spawnExplosion(player);
              pendingGameOver = true;
              touchTarget = null;
              return;
            }
          }
        }

        /* Polly Helper collisions */
        if (pollyHelper) {
          for (let j = fishList.length - 1; j >= 0; j--) {
            const e = fishList[j];
            if (
              e === pollyHelper ||
              e.isPlayer ||
              e.isPollyHelper ||
              e.isGorilla
            )
              continue;
            if (e.noCollision) continue;
            if (checkCollisionOval(pollyHelper, e)) {
              // Award points based on creature type (same logic as player eating)
              if (e.isSushi) {
                score += 50;
              } else if (e.isBorgy) {
                score += 75;
              } else if (e.isPolly) {
                score += 75;
              } else {
                score += calculateFishScore(e.maxSide);
              }
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });
              if (!(e.isJellyfish && !e.isElectric) && !e.isElectric) {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }
              // if (e.isUltraFast) {
              //   sushiPowerUpTime = SUSHI_DURATION;
              //   playPowerUpSound();
              // }
              player.width = player.height = null;
              if (e.isBorgy) {
                // helper ate a Chippy
                borgyPowerUpTime = BORGY_DURATION;
                playBorgyPowerUpSound();
              } else if (e.isPolly) {
                // helper ate another Polly
                pollyFreezeTime = POLLY_DURATION; // helper active timer
                playPollyPowerUpSound();
              }
              if (e.isSnake && typeof e.startVineFall === "function") {
                e.startVineFall();
              } else {
                fishList.splice(j, 1);
              }
            }
          }
        }

        /* Gorilla rocks */
        for (let i = rocks.length - 1; i >= 0; i--) {
          const rock = rocks[i];
          rock.update(dt);
          const b = rock.getBounds();
          if (
            b.centerX + b.radiusX < -200 ||
            b.centerX - b.radiusX > WIDTH + 200 ||
            b.centerY + b.radiusY < -200 ||
            b.centerY - b.radiusY > HEIGHT + 200
          ) {
            rocks.splice(i, 1);
            continue;
          }
          if (rock.delayRemaining > 0) continue;
          if (checkCollisionOval(player, rock)) {
            if (borgyPowerUpTime <= 0) {
              playerParalyzeTime = PARALYZE_DURATION;
              playerParalyzeCause = "rock";
              playShockSound();
            }
            rocks.splice(i, 1);
          }
        }

        if (score >= nextMilestone) {
          playAchvSound();
          const diff = Math.floor((score - nextMilestone) / 100000) + 1;
          enemySpeedMultiplier *= Math.pow(1.5, diff);
          resetRound();
          nextMilestone += diff * 100000;
        }
      }

      /*********************   RENDER LOOP & MASTER LOOP  *****************************/
      let cachedScoreText = "";
      function renderGame() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        waterTrails.forEach((t) => t.draw(ctx));
        poisonParticles.forEach((p) => p.draw(ctx));
        if (player && !(isGameOver && pendingGameOver)) {
          if (usingMonkeSprites) drawPlayerVine(ctx, player);
          else drawPlayerJetpack(ctx, player);
          player.draw(ctx);
        }
        const showEnemyVines = borgyPowerUpTime <= 0;
        fishList.forEach((f) => {
          if (!showEnemyVines && !f.isPollyHelper) return;
          if (f.isPolly || f.isPollyHelper || f.isVineSwinging) {
            drawEntityVine(ctx, f);
          }
        });
        fishList.forEach((f) => f.draw(ctx));
        rocks.forEach((r) => r.draw(ctx));
        explosions.forEach((ex) => ex.draw(ctx));

        const scoreText = `Score: ${score}`;
        if (cachedScoreText !== scoreText) {
          cachedScoreText = scoreText;
        }
        ctx.fillStyle = playerParalyzeTime > 0 ? "#ffea00" : "#fff";
        ctx.font = "20px 'Londrina Solid', sans-serif";
        ctx.fillText(cachedScoreText, 20, 30);

        let y = 55;
        ctx.font = "16px 'Poppins', sans-serif";
        const paralyzeLabel =
          playerParalyzeCause === "rock" ? "KO" : "Paralyzed";
        if (playerParalyzeTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `${paralyzeLabel}: ${playerParalyzeTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(40, 40, 0, 0.72)", // dark yellow
                textColor: "#ffea00",
                font: ctx.font,
              }
            ) + 4;
        }
        if (borgyPowerUpTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `Banana Power-Up: ${borgyPowerUpTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(60, 50, 0, 0.72)", // dark yellow
                textColor: "#ffe066",
                font: ctx.font,
              }
            ) + 4;
        }
        if (sushiPowerUpTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `Power-Up: ${sushiPowerUpTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(30, 0, 20, 0.7)", // dark magenta
                textColor: "#ffaaff",
                font: ctx.font,
              }
            ) + 4;
        }

        if (pollyFreezeTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `Monke Helper: ${pollyFreezeTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(0, 60, 30, 0.72)",
                textColor: "#7dff9a",
                font: ctx.font,
              }
            ) + 4;
        }

        if (statusMessageTime > 0 && statusMessage) {
          const alpha = Math.min(
            1,
            statusMessageTime / STATUS_MESSAGE_DURATION
          );
          ctx.save();
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.font = "32px 'Londrina Solid', sans-serif";
          ctx.lineWidth = 3;
          ctx.strokeStyle = `rgba(0, 0, 0, ${0.35 * alpha})`;
          ctx.fillStyle = `rgba(255, 255, 255, ${0.7 * alpha})`;
          const msgY = 250;
          ctx.strokeText(statusMessage, WIDTH / 2, msgY);
          ctx.fillText(statusMessage, WIDTH / 2, msgY);
          ctx.restore();
        }

        if (isJoystickEnabled && joystick.active) {
          ctx.save();
          ctx.globalAlpha = 0.75;
          ctx.fillStyle = "#ffffff33";
          ctx.beginPath();
          ctx.arc(
            joystick.baseX,
            joystick.baseY,
            joystick.radius,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.strokeStyle = "#ffffffaa";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.fillStyle = "#ffffffcc";
          ctx.beginPath();
          ctx.arc(
            joystick.stickX,
            joystick.stickY,
            joystick.innerRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.strokeStyle = "#ffffffdd";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }

        if (touchTarget && !isJoystickEnabled) {
          ctx.beginPath();
          ctx.arc(touchTarget.x, touchTarget.y, 15, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffffff88";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      /* ---- MASTER LOOP (update + render) ---- */
      let lastFrameTime = performance.now();
      let accumulator = 0;
      const FIXED_STEP = 1 / 60; // 60 FPS physics

      function masterLoop() {
        const now = performance.now();
        let dt = (now - lastFrameTime) / 1000;
        if (dt > 0.25) dt = 0.25;
        lastFrameTime = now;
        accumulator += dt;
        if (accumulator > FIXED_STEP * 5) {
          accumulator = FIXED_STEP * 5;
        }
        while (accumulator >= FIXED_STEP) {
          updateGame(FIXED_STEP);
          accumulator -= FIXED_STEP;
        }
        renderGame();
        requestAnimationFrame(masterLoop);
      }

      /*********************        INIT          *************************/
      function initGame() {
        resizeCanvas();
        score = 0;
        nextMilestone = 100000;
        enemySpeedMultiplier = 1;
        gameTime = 0;
        gameTimeMs = 0;
        isGameOver = false;
        pendingGameOver = false;
        fishList = [];
        explosions = [];
        waterTrails = [];
        poisonParticles = [];
        rocks = [];
        player = new Fish(WIDTH / 2, HEIGHT / 2, 0, 0, playerImg, 25, true);
        sushiPowerUpTime = 0;
        borgyPowerUpTime = 0;
        playerIsPoweredUp = false;
        playerParalyzeTime = 0;
        playerParalyzeCause = null;
        pollyFreezeTime = 0;
        pollyHelper = null;
        clearKeys();
        joystick.active = false;
        updateMusicButtons();
        updateSfxButtons();
        updateJoystickButtons();
      }

      /*********************      UI EVENTS       *************************/
      const showOrHideArrowKeys = (show) => {
        controlsContainer.style.display = show ? "flex" : "none";
        const txt = show ? "üéÆ Arrow Keys On" : "üéÆ Arrow Keys Off";
        arrowKeysBtn.textContent = txt;
        arrowKeysBtnGameOver.textContent = txt;
        if (!show) clearKeys();
      };
      const syncGameOverUI = () => {
        showOrHideArrowKeys(controlsContainer.style.display !== "none");
        updateMusicButtons();
        updateSfxButtons();
        updateJoystickButtons();
        updatePlayerAvatarUI();
      };

      /* ---- Start Game ---- */
      async function startNewRun() {
        if (!VALID_TEAMS.includes(userTeam)) {
          alert("Please pick a team first!");
          return;
        }

        if (startInProgress) return;
        startInProgress = true;
        startBtn.disabled = true;
        playAgainBtn.disabled = true;
        shareBtn.disabled = true;

        hideStartScreen();
        hideGameOverScreen();
        showOrHideArrowKeys(arrowKeysBtn.textContent.includes("On"));

        startAudio();

        let sessionInfo;
        try {
          const resp = await fetch("/api/session", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `tma ${initDataRaw}`,
              "x-api-password": getApiPassword(),
            },
          });
          sessionInfo = await resp.json();
        } catch (e) {
          alert("Cannot start game ‚Äì session failed.");
          startInProgress = false;
          startBtn.disabled = false;
          playAgainBtn.disabled = false;
          window.location.reload();
          return;
        }

        rng = new Math.seedrandom(sessionInfo.seed);
        spawnSpecRng = new Math.seedrandom(sessionInfo.seed + ":spec");
        spawnTimingRng = new Math.seedrandom(sessionInfo.seed + ":timing");

        globalSpawnIdx = 0;

        spawnSchedule.length = 0;
        nextScheduleIdx = 0;
        scheduleCursorTime = 0;
        ensureScheduleAhead(120);

        currentSessionId = sessionInfo.sessionId;
        eatenEvents.length = 0;

        gameState = "playing";
        epochGameStartTime = Date.now();
        epochGameEndTime = null;

        initGame();
        startInProgress = false;
      }

      startBtn.onclick = startNewRun;
      playAgainBtn.onclick = startNewRun;

      musicBtn.onclick = toggleMusic;
      musicBtnGameOver.onclick = toggleMusic;
      sfxBtn.onclick = toggleSFX;
      sfxBtnGameOver.onclick = toggleSFX;
      arrowKeysBtn.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");
      arrowKeysBtnGameOver.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");
      joystickBtn.onclick = toggleJoystick;
      joystickBtnGameOver.onclick = toggleJoystick;
      if (playAsNomuBtn)
        playAsNomuBtn.onclick = () => setPlayerAvatarTeam("Nomu");
      if (playAsMonkeBtn)
        playAsMonkeBtn.onclick = () => setPlayerAvatarTeam("MonkeDAO");
      if (playAsNomuBtnGameOver)
        playAsNomuBtnGameOver.onclick = () => setPlayerAvatarTeam("Nomu");
      if (playAsMonkeBtnGameOver)
        playAsMonkeBtnGameOver.onclick = () => setPlayerAvatarTeam("MonkeDAO");
      if (tutorialBtn) tutorialBtn.onclick = showTutorialScreen;
      tutorialScreen.addEventListener(
        "pointerdown",
        (e) => {
          if (tutorialScreen.classList.contains("hidden")) return;
          e.preventDefault();
          e.stopPropagation();
          tutorialStep += 1;
          if (tutorialStep >= tutorialSteps.length) {
            tutorialSeen = true;
            hideTutorialScreen();
            markTutorialSeen();
            showStartScreen();
          } else {
            updateTutorialStep();
          }
        },
        { passive: false }
      );

      /* hardware keyboard */
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = true;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });

      /* touch / mouse aiming & joystick */
      canvas.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        if (!t) return;
        const r = canvas.getBoundingClientRect();
        if (isJoystickEnabled) {
          joystick.baseX = joystick.stickX = t.clientX - r.left;
          joystick.baseY = joystick.stickY = t.clientY - r.top;
          joystick.active = true;
          e.preventDefault();
        } else {
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchmove", (e) => {
        const t = e.touches[0];
        if (!t) return;
        const r = canvas.getBoundingClientRect();
        if (isJoystickEnabled && joystick.active) {
          const rawX = t.clientX - r.left;
          const rawY = t.clientY - r.top;
          const dx = rawX - joystick.baseX;
          const dy = rawY - joystick.baseY;
          const dist = Math.hypot(dx, dy);
          if (dist > joystick.radius) {
            const ratio = joystick.radius / dist;
            joystick.stickX = joystick.baseX + dx * ratio;
            joystick.stickY = joystick.baseY + dy * ratio;
          } else {
            joystick.stickX = rawX;
            joystick.stickY = rawY;
          }
          e.preventDefault();
        } else if (!isJoystickEnabled) {
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchend", () => {
        if (isJoystickEnabled) {
          joystick.active = false;
        } else {
          touchTarget = null;
        }
      });

      /* Mouse (desktop dev) */
      canvas.addEventListener("mousedown", (e) => {
        const r = canvas.getBoundingClientRect();
        if (isJoystickEnabled) {
          joystick.baseX = joystick.stickX = e.clientX - r.left;
          joystick.baseY = joystick.stickY = e.clientY - r.top;
          joystick.active = true;
        } else {
          touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
        }
      });
      canvas.addEventListener("mousemove", (e) => {
        const r = canvas.getBoundingClientRect();
        if (e.buttons > 0) {
          if (isJoystickEnabled && joystick.active) {
            const rawX = e.clientX - r.left;
            const rawY = e.clientY - r.top;
            const dx = rawX - joystick.baseX;
            const dy = rawY - joystick.baseY;
            const dist = Math.hypot(dx, dy);
            if (dist > joystick.radius) {
              const ratio = joystick.radius / dist;
              joystick.stickX = joystick.baseX + dx * ratio;
              joystick.stickY = joystick.baseY + dy * ratio;
            } else {
              joystick.stickX = rawX;
              joystick.stickY = rawY;
            }
          } else if (!isJoystickEnabled) {
            touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
          }
        }
      });
      canvas.addEventListener("mouseup", () => {
        if (isJoystickEnabled) {
          joystick.active = false;
        } else {
          touchTarget = null;
        }
      });

      /* safety: clear keys on blur */
      window.addEventListener("blur", () => {
        clearKeys();
        joystick.active = false;
        touchTarget = null;
      });
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          clearKeys();
          joystick.active = false;
          touchTarget = null;
        }
      });

      // ‚îÄ‚îÄ‚îÄ TEAM‚ÄëSELECT HANDLERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      teamScreen.addEventListener("click", async (e) => {
        const btn = e.target.closest(".teamBtn");
        if (!btn) return;

        const chosen = btn.dataset.team;
        if (!VALID_TEAMS.includes(chosen)) return;

        btn.disabled = true; // optimistic UX
        try {
          // Only one chance ‚Äì backend should reject changes later
          const resp = await fetch("/api/score/team", {
            method: "POST", // or PUT ‚Äì match your API
            headers: {
              "Content-Type": "application/json",
              Authorization: `tma ${initDataRaw}`,
              "x-api-password": getApiPassword(),
            },
            body: JSON.stringify({ team: chosen }),
          });
          if (!resp.ok) throw new Error(await resp.text());
          const scoreDoc = await resp.json();
          userTeam = scoreDoc?.team ?? chosen;
          tutorialSeen = !!scoreDoc?.tutorialSeen;
          syncPlayerAvatarSprites();
          teamScreen.classList.add("hidden");
          maybeShowTutorialOrStart();
        } catch (err) {
          console.error(err);
          alert("Couldn‚Äôt save team ‚Äì try again?");
          btn.disabled = false;
        }
      });
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      /*********************    PRELOAD & BOOT     **************************/
      Promise.all([
        loadImage(PLAYER_SPRITE_SETS.nomu.base),
        // These are optional - game will fall back to filters if they don't exist
        new Promise((resolve) => {
          playerPoweredUpImg.onload = resolve;
          playerPoweredUpImg.onerror = resolve;
        }),
        new Promise((resolve) => {
          playerParalyzedImg.onload = resolve;
          playerParalyzedImg.onerror = resolve;
        }),
        new Promise((resolve) => {
          playerBorgyImg.onload = resolve;
          playerBorgyImg.onerror = resolve;
        }),
        new Promise((resolve) => {
          playerPollyImg.onload = resolve;
          playerPollyImg.onerror = resolve;
        }),
        loadImage(PLAYER_SPRITE_SETS.monke.base),
        loadImage(PLAYER_SPRITE_SETS.monke.powered),
        loadImage(PLAYER_SPRITE_SETS.monke.paralyzed),
        loadImage(PLAYER_SPRITE_SETS.monke.borgy),
        loadImage(PLAYER_SPRITE_SETS.monke.polly),
        ...fishTypes.map(
          ({ image }) =>
            new Promise((resolve) => {
              if (image.complete) return resolve();
              image.addEventListener("load", resolve, { once: true });
              image.addEventListener("error", resolve, { once: true });
            })
        ),
        loadImage("img/crab-6.png"),
        loadImage("img/gorilla-6.png"),
        loadImage("img/jellyfish-6-2.png"),
        loadImage("img/electric-jellyfish-6-2.png"),
        loadImage("img/snake-6.png"),
        loadImage("img/sushi.png"),
        loadImage("img/chippy-6.png"),
        loadImage("img/pufferfish-6.png"),
        loadImage("img/chip-6.png"),
        loadImage("img/chip-jelly-6.png"),
        loadImage("img/rock-6.png"),
        loadImage("img/polly-6.png"),
        loadImage("img/polly-helper.png"),
      ]).then(() => {
        resizeCanvas();
        (async function initialiseTeam() {
          try {
            const scoreResp = await fetch("/api/score", {
              method: "GET",
              headers: {
                Authorization: `tma ${initDataRaw}`,
                "x-api-password": getApiPassword(),
              },
            });
            if (!scoreResp.ok) throw new Error("score fetch failed");
            const scoreDoc = await scoreResp.json();
            userTeam = scoreDoc?.team ?? null;
            tutorialSeen = !!scoreDoc?.tutorialSeen;
          } catch (e) {
            console.error(e);
            userTeam = null; // fall back
            tutorialSeen = false;
          }
          syncPlayerAvatarSprites();

          /* Dismiss the loader */
          document.getElementById("loadingScreen").classList.add("hidden");

          if (!VALID_TEAMS.includes(userTeam)) {
            teamScreen.classList.remove("hidden"); // show picker
          } else {
            maybeShowTutorialOrStart(); // carry on
          }
        })();
        let audioStarted = false;
        function kickAudio() {
          if (!audioStarted) {
            startAudio();
            audioStarted = true;
          }
        }
        startScreen.addEventListener("click", kickAudio, { once: true });
        document.addEventListener("mousemove", kickAudio, { once: true });
        requestAnimationFrame(masterLoop);
      });
    </script>
  </body>
</html>
