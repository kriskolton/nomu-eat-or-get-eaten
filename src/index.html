<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Telegram Mini-App bridge -->
    <script src="https://telegram.org/js/telegram-web-app.js?57"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

    <!-- Deterministic RNG (client & server share the same seed) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>

    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <title>Nomu: Eat or Get Eaten (Season 5): Community Showdown ⚔️</title>

    <!-- ----------------------------------------------------------------- -->
    <!--                       FONTS & AUDIO ASSETS                         -->
    <!-- ----------------------------------------------------------------- -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Londrina+Solid&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- ----------------------------------------------------------------- -->
    <!--                              STYLES                               -->
    <!-- ----------------------------------------------------------------- -->
    <style>
      /* --- layout basics --- */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: #222;
        font-family: "Poppins", sans-serif;
      }
      #gameWrapper {
        flex: 1;
        width: 100%;
        position: relative;
        overflow: hidden;
        background: #222 url("img/bg5-2.png") center/cover no-repeat;
        display: flex;
        margin: 0 auto;
        max-width: 430px;
        max-height: 935px;
      }
      #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      /* --- on-screen arrow keys --- */
      #controlsContainer {
        width: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        background: #222;
      }
      .controlsRow {
        display: flex;
        width: 100%;
        max-width: 450px;
        margin: 0 auto;
      }
      .arrowBtn {
        flex: 1;
        background: #f78719;
        border: none;
        color: #fff;
        font-family: "Londrina Solid", sans-serif;
        font-size: 20px;
        margin: 1px;
        border-radius: 4px;
        height: 60px;
        user-select: none;
        touch-action: none;
      }
      .arrowBtn:active {
        transform: scale(0.95);
      }

      /* --- overlay screens --- */
      .overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 10, 30, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .hidden {
        display: none;
      }
      .overlay h1,
      .overlay button,
      .overlay p {
        color: #fff;
        margin: 8px;
      }
      .overlay button {
        font-size: 16px;
        font-weight: bold;
        padding: 8px 10px;
        cursor: pointer;
        border-radius: 40px;
        background: #f78719;
        font-family: "Londrina Solid", sans-serif;
        margin: 4px;
      }
      .overlay p {
        font-size: 14px;
      }
    </style>
  </head>

  <body>
    <!-- ----------------------------------------------------------------- -->
    <!--                            MARK-UP                                -->
    <!-- ----------------------------------------------------------------- -->
    <div id="gameWrapper">
      <!-- ─────────────── Loading overlay (always present at first) ─────────────── -->
      <div id="loadingScreen" class="overlay">
        <p
          style="
            font-family: 'Londrina Solid', sans-serif;
            font-size: 32px;
            letter-spacing: 2px;
            color: #fff;
          "
        >
          Loading…
        </p>
      </div>
      <!-- ───────────────────────────────────────────────────────────────────────── -->

      <canvas id="gameCanvas"></canvas>

      <!-- ---------- Start overlay ---------- -->
      <div id="startScreen" class="overlay hidden">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <img
            src="img/title.png"
            alt="Eat or Get Eaten"
            style="
              max-width: 50%;
              height: auto;
              padding: 12px;
              padding-bottom: 0;
              margin-bottom: -8px;
              max-height: 30vh;
            "
          />
          <p
            style="
              font-size: 24px;
              -webkit-background-clip: text;
              background-clip: text;
              color: #fff;
              font-family: 'Londrina Solid', sans-serif;
              letter-spacing: 2px;
            "
          >
            SEASON 5: COMMUNITY SHOWDOWN ⚔️
          </p>
          <p
            style="
              font-size: 12px;
              color: #fff;
              opacity: 0.5;
              position: absolute;
              bottom: 6px;
              right: 6px;
            "
          >
            v5.1
          </p>

          <div
            id="telegramStatus"
            style="
              color: white;
              font-family: 'Poppins', sans-serif;
              font-size: 12px;
              margin-bottom: 12px;
            "
          ></div>

          <p style="font-size: 24px; font-weight: bold; letter-spacing: 1px">
            Rules
          </p>
          <p>
            Use the touch screen or arrow keys (↑→↓←) to control Nomu. Eat the
            smaller fish to grow. Don't let the bigger fish eat you!
          </p>
          <p>The larger the fish, the more points you get.</p>

          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
            "
          >
            <button id="musicBtn" style="width: 40%">🎵 Music On</button>
            <button id="sfxBtn" style="width: 40%">🔊 SFX On</button>
          </div>

          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
            "
          >
            <button id="arrowKeysBtn" style="width: 40%">
              🎮 Arrow Keys Off
            </button>
            <button id="joystickBtn" style="width: 40%">🕹️ Joystick On</button>
          </div>

          <button id="startBtn" style="font-size: 24px; padding: 12px 24px">
            Start Game
          </button>
        </div>
      </div>

      <!-- ─────────────────── TEAM‑SELECT OVERLAY ─────────────────── -->
      <div id="teamScreen" class="overlay hidden">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <img
            src="img/title.png"
            alt="Eat or Get Eaten"
            style="
              max-width: 55%;
              height: auto;
              padding: 12px;
              max-height: 30vh;
            "
          />
          <p
            style="
              font-size: 22px;
              font-family: 'Londrina Solid', sans-serif;
              letter-spacing: 1px;
              color: #fff;
              margin-top: 4px;
            "
          >
            CHOOSE&nbsp;YOUR&nbsp;TEAM
          </p>

          <button class="teamBtn" data-team="Nomu" style="background: #f78719">
            🐡 Team Nomu</button
          ><br />
          <button class="teamBtn" data-team="Polly" style="background: #4b74ff">
            🐧 Team Polly</button
          ><br />
          <button
            class="teamBtn"
            data-team="Chippy"
            style="background: #03b0b0"
          >
            🐟 Team Chippy</button
          ><br />

          <p style="font-size: 12px; color: #fffa">
            *You can’t change this later
          </p>
        </div>
      </div>
      <!-- ─────────────────── /TEAM‑SELECT OVERLAY ─────────────────── -->

      <!-- ---------- Game-over overlay ---------- -->
      <div id="gameOverScreen" class="overlay hidden" style="width: 100%">
        <div
          style="
            max-width: 90%;
            margin: 0 auto;
            text-align: center;
            width: 100%;
          "
        >
          <h1
            style="font-family: 'Londrina Solid', sans-serif; font-size: 44px"
          >
            GAME OVER!
          </h1>
          <p id="finalScore"></p>
          <button
            id="shareBtn"
            style="
              font-size: 24px;
              padding: 12px 24px;
              margin-top: 12px;
              background-color: #222;
            "
          >
            𝕏 &nbsp;Share on X
          </button>
          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
              width: 100%;
            "
          >
            <button id="musicBtnGameOver" style="width: 40%">
              🎵 Music On
            </button>
            <button id="sfxBtnGameOver" style="width: 40%">🔊 SFX On</button>
          </div>
          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
              width: 100%;
            "
          >
            <button id="arrowKeysBtnGameOver" style="width: 40%">
              🎮 Arrow Keys On
            </button>
            <button id="joystickBtnGameOver" style="width: 40%">
              🕹️ Joystick On
            </button>
          </div>
          <button
            id="playAgainBtn"
            style="font-size: 24px; padding: 12px 24px; margin-top: 12px"
          >
            Play Again
          </button>
        </div>
      </div>
    </div>

    <!-- ---------- Bottom: on-screen arrow keys ---------- -->
    <div id="controlsContainer">
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowUp">↑</button>
      </div>
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowLeft">←</button>
        <button class="arrowBtn" id="arrowDown">↓</button>
        <button class="arrowBtn" id="arrowRight">→</button>
      </div>
    </div>

    <!-- ----------------------------------------------------------------- -->
    <!--                          GAME SCRIPT                               -->
    <!-- ----------------------------------------------------------------- -->
    <script>
      /********************* CONSTANTS & GLOBALS ***************************/

      /* Dev helper – ?dev in the URL skips Telegram auth */
      const urlParams = new URLSearchParams(window.location.search);
      const forceDev = urlParams.has("dev");

      // ─── TEAM‑SELECT CONSTS ───────────────────────────────────────
      const VALID_TEAMS = ["Nomu", "Polly", "Chippy"];
      let userTeam = null; // populated after /api/score call
      const teamScreen = document.getElementById("teamScreen");
      // ───────────────────────────────────────────────────────────────

      let tg, userData, userId, initDataRaw;
      try {
        tg = window.Telegram.WebApp;
        if (!forceDev) {
          initDataRaw = tg.initData;
          userData = tg.initDataUnsafe?.user;
          userId = userData?.id;
          tg.expand();
          tg.ready();
          tg.disableVerticalSwipes();
        }
      } catch (e) {
        console.error("Telegram init error:", e);
      }

      /* Local fallback */
      if (forceDev) {
        userId = "local-dev";
        userData = { username: "dev" };
      }

      /* Status banner */
      const statusDiv = document.getElementById("telegramStatus");
      if (userId) {
        statusDiv.textContent = `Telegram connected ✓ (${
          userData?.username || userData?.first_name || userId
        })`;
        statusDiv.style.color = "lightgreen";
      } else {
        statusDiv.textContent =
          "⚠️ Not tracking scores – open via Telegram bot";
        statusDiv.style.color = "red";
      }

      /* ----------------   DETERMINISTIC RANDOM  ---------------- */
      // rng – graphics/FX/anything *except* spawning
      let rng = Math.random; // will be replaced with seed-rng after session starts
      const Rand = () => rng();

      // --- NEW deterministic RNG streams ---
      let spawnSpecRng = null; // generates the ordered list of spawn specs
      let spawnTimingRng = null; // governs WHEN the next spawn occurs
      const specRand = () => (spawnSpecRng ? spawnSpecRng() : Math.random());
      const timingRand = () =>
        spawnTimingRng ? spawnTimingRng() : Math.random();

      /* 🔧  MISSING HELPERS RE-ADDED  🔧 */
      const getRandom = (min, max) => Rand() * (max - min) + min; // FIXED
      const getSpecRandom = (min, max) => specRand() * (max - min) + min;
      const getSpawnRandom = getSpecRandom; // legacy alias

      /* ---------------------- NEW LIMITING CONSTANTS --------------------- */
      const MAX_WATER_TRAILS = 1500;
      const MAX_EXPLOSIONS = 100;
      const RETAIN_SCHEDULE_ENTRIES = 1000;

      // Guest character constants
      const CHIPPY_SIZE = 90; // 45 × 2
      const POLLY_SIZE = 70; // 35 × 2
      const POLLY_HELPER_SIZE = 70;

      // Power-up constants
      const SUSHI_DURATION = 10;
      const BORGY_DURATION = 15;
      const BORGY_SPEED_MULT = 3;
      const POLLY_SPEED_MULT = 2;

      // Spawn schedule (server-verifiable)
      const spawnSchedule = []; // { idx, spawnTime (s), spec }
      let globalSpawnIdx = 0;
      let nextScheduleIdx = 0;
      let scheduleCursorTime = 0; // seconds

      /* Generate exponential delay matching 0.03/frame (≈1.8 spawns/s) */
      function getNextSpawnDelay() {
        let u = timingRand();
        // Guard for u === 1 to avoid Infinity delays
        if (u === 1) u = 1 - Number.EPSILON;
        const lambda = 1.8; // per second
        return -Math.log(1 - u) / lambda;
      }

      function scheduleNextEntry() {
        const spec = nextSpawnSpec();
        const delay = getNextSpawnDelay();
        scheduleCursorTime += delay;
        spawnSchedule.push({
          idx: globalSpawnIdx++,
          spawnTime: scheduleCursorTime,
          spec,
        });
      }

      function ensureScheduleAhead(bufferSeconds = 60) {
        while (
          spawnSchedule.length === 0 ||
          spawnSchedule[spawnSchedule.length - 1].spawnTime <
            gameTime + bufferSeconds
        ) {
          scheduleNextEntry();
        }
      }

      /*********************   ASSET HELPERS   ****************************/
      function loadImage(src) {
        return new Promise((resolve) => {
          const img = new Image();
          img.addEventListener("load", () => resolve(img));
          img.addEventListener("error", () => {
            console.warn(`Image failed to load: ${src}`);
            resolve(img); // resolve anyway – game can continue
          });
          img.src = src;
        });
      }

      function loadAudio(id) {
        return new Promise((resolve) => {
          const el = document.getElementById(id);
          if (!el) return resolve();
          let resolved = false;
          const finalize = () => {
            if (!resolved) {
              resolved = true;
              resolve(el);
            }
          };
          // Handle normal load/error events
          el.addEventListener("canplaythrough", finalize, { once: true });
          el.addEventListener("error", finalize, { once: true });
          // If already loaded (cached), resolve immediately
          if (el.readyState >= 3) finalize();
          // Fallback: always resolve after 300ms (prevents iOS hanging)
          setTimeout(finalize, 300);
        });
      }

      /* Keyboard state */
      const keys = { left: false, right: false, up: false, down: false };
      const clearKeys = () => {
        keys.left = keys.right = keys.up = keys.down = false;
      };

      /* Pointer-aware button helper */
      const pointerDirMap = Object.create(null);
      function pressKey(dir, down) {
        keys[dir] = down;
      }
      function setupArrowButton(btn, dir) {
        btn.addEventListener(
          "pointerdown",
          (e) => {
            pressKey(dir, true);
            btn.setPointerCapture(e.pointerId);
            pointerDirMap[e.pointerId] = dir;
            e.preventDefault();
          },
          { passive: false }
        );
        function release(e) {
          const d = pointerDirMap[e.pointerId] ?? dir;
          pressKey(d, false);
          delete pointerDirMap[e.pointerId];
        }
        btn.addEventListener("pointerup", release);
        btn.addEventListener("pointercancel", release);
      }
      ["Up", "Left", "Down", "Right"].forEach((dir) =>
        setupArrowButton(
          document.getElementById(`arrow${dir}`),
          dir.toLowerCase()
        )
      );

      /* -------- Score submission (networking/security skipped per brief) -------- */
      const getApiSeed = (() => {
        const codes = [68, 111, 115, 107, 100, 82, 112, 104, 106, 100];
        let cached = null;
        return () => {
          if (cached) return cached;
          cached = codes.map((c) => String.fromCharCode(c - 3)).join("");
          return cached;
        };
      })();
      const getApiPassword = () =>
        getApiSeed()
          .split("")
          .map((ch) => ch.charCodeAt(0).toString(16))
          .join("");

      /* Extended signature (NEW params at the end) */
      async function sendScoreToAPI(
        score,
        eaten,
        sessionId,
        gameTimeMs,
        eatenBy = null, // NEW
        startTimeMs = null, // NEW
        endTimeMs = null // NEW
      ) {
        if (!userId) return; // dev mode skip

        try {
          await fetch("/api/scores", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `tma ${initDataRaw}`,
              "x-api-password": getApiPassword(),
            },
            body: JSON.stringify({
              score,
              gameTime: gameTimeMs, // existing
              event: "Community Showdown",
              eaten,
              sessionId,

              /* ---- NEW FIELDS ---- */
              eatenBy, // idx of the enemy that killed the player
              epochGameStartTime: startTimeMs, // epoch-ms
              epochGameEndTime: endTimeMs, // epoch-ms
            }),
          });
        } catch (e) {
          console.error("Score send error:", e);
        }
      }

      /* Canvas */
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      let WIDTH = 800,
        HEIGHT = 600;

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth;
        const cssH = canvas.clientHeight;
        canvas.width = cssW * dpr;
        canvas.height = cssH * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        WIDTH = cssW;
        HEIGHT = cssH;

        if (player && player.width && player.height) {
          player.x = Math.min(Math.max(0, player.x), WIDTH - player.width);
          player.y = Math.min(Math.max(0, player.y), HEIGHT - player.height);
        }
        [...fishList, ...bubbles].forEach((ent) => {
          if (ent.width == null || ent.height == null) {
            if (typeof ent.calculateDimensions === "function") {
              ent.calculateDimensions();
            }
          }
          if (ent.width && ent.height) {
            const maxX = Math.max(0, WIDTH - ent.width);
            const maxY = Math.max(0, HEIGHT - ent.height);

            ent.x = Math.min(Math.max(0, ent.x), maxX);
            ent.y = Math.min(Math.max(0, ent.y), maxY);
          }
        });
      }
      window.addEventListener("resize", resizeCanvas);

      /* Overlay/DOM refs */
      const startScreen = document.getElementById("startScreen");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const startBtn = document.getElementById("startBtn");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const finalScoreElem = document.getElementById("finalScore");
      const musicBtn = document.getElementById("musicBtn");
      const sfxBtn = document.getElementById("sfxBtn");
      const arrowKeysBtn = document.getElementById("arrowKeysBtn");
      const joystickBtn = document.getElementById("joystickBtn");
      const musicBtnGameOver = document.getElementById("musicBtnGameOver");
      const sfxBtnGameOver = document.getElementById("sfxBtnGameOver");
      const shareBtn = document.getElementById("shareBtn");
      const arrowKeysBtnGameOver = document.getElementById(
        "arrowKeysBtnGameOver"
      );
      const joystickBtnGameOver = document.getElementById(
        "joystickBtnGameOver"
      );
      const controlsContainer = document.getElementById("controlsContainer");
      const arrowUp = document.getElementById("arrowUp");
      const arrowDown = document.getElementById("arrowDown");
      const arrowLeft = document.getElementById("arrowLeft");
      const arrowRight = document.getElementById("arrowRight");

      const showStartScreen = () => {
        startScreen.classList.remove("hidden");
        // ensure buttons are enabled after a previous run
        startBtn.disabled = false;
        // sync UI with current settings
        showOrHideArrowKeys(false);
        updateMusicButtons();
        updateSfxButtons();
        updateJoystickButtons();
      };
      const hideStartScreen = () => startScreen.classList.add("hidden");
      const showGameOverScreen = (scoreVal) => {
        finalScoreElem.textContent = `Your Score: ${scoreVal}`;
        gameOverScreen.classList.remove("hidden");
        playGameOverSound();
        syncGameOverUI();
        // re-enable buttons for a new run
        startInProgress = false;
        startBtn.disabled = false;
        playAgainBtn.disabled = false;
        shareBtn.disabled = false;
        shareBtn.addEventListener("click", () => {
          const text = `I just scored ${scoreVal} points in @EatwithNomu Eat or Get Eaten! 🔥\n\nCan you beat my score? Play now on Telegram: https://t.me/NomuTheFish`;
          const url =
            "https://x.com/intent/tweet?text=" + encodeURIComponent(text);
          Telegram.WebApp.openLink(url, { tryBrowser: "external" });
        });
      };
      const hideGameOverScreen = () => gameOverScreen.classList.add("hidden");

      /* Game-state flags */
      let gameState = "start"; // "start" | "playing" | "over"
      let isGameOver = false;
      let pendingGameOver = false; // wait until explosions finish

      /* Anti-cheat tracking */
      let eatenEvents = [];
      let currentSessionId = null;

      /*********************   IMAGES & SPRITES   ***************************/
      const fishTypeDefinitions = [
        { src: "img/fish1-5.png", minSize: 10, maxSize: 40, weight: 0.432 },
        { src: "img/fish2-5.png", minSize: 20, maxSize: 60, weight: 0.252 },
        { src: "img/fish3-5.png", minSize: 25, maxSize: 80, weight: 0.2 },
        { src: "img/fish4-5.png", minSize: 35, maxSize: 100, weight: 0.1 },
        { src: "img/fish5-5.png", minSize: 200, maxSize: 300, weight: 0.013 },
        { src: "img/fish6-5.png", minSize: 400, maxSize: 500, weight: 0.003 },
      ];
      const fishTypes = fishTypeDefinitions.map((def) => {
        const image = new Image();
        image.src = def.src;
        return {
          image,
          minSize: def.minSize,
          maxSize: def.maxSize,
          weight: def.weight,
        };
      });

      const frozenPlaceholderImg = new Image();
      frozenPlaceholderImg.src = "img/fish-frozen-placeholder.png";

      // ── preload & cache «frozen» skins ────────────────────────────
      fishTypes.forEach((ft) => {
        // start with the placeholder so we always have *something*
        ft.frozenSprite = frozenPlaceholderImg;

        const customSrc = ft.image.src.replace(/\.png$/, "-frozen.png");
        const custom = new Image();

        // If the custom image loads, use it; otherwise keep the placeholder.
        custom.onload = () => {
          ft.frozenSprite = custom;
        };
        custom.onerror = () => {
          /* leave placeholder in place */
        };

        custom.src = customSrc; // kicks off the request immediately
      });

      const playerImg = new Image();
      playerImg.src = "img/player_fish-5.png";

      // NEW: Additional player sprites for different states
      const playerPoweredUpImg = new Image();
      playerPoweredUpImg.src = "img/player_fish_powered.png"; // You'll need to create this
      playerPoweredUpImg.onerror = () =>
        console.warn(
          "player_fish_powered.png not found - using filters instead"
        );

      const playerParalyzedImg = new Image();
      playerParalyzedImg.src = "img/player_fish_paralyzed-5.png"; // You'll need to create this
      playerParalyzedImg.onerror = () =>
        console.warn(
          "player_fish_paralyzed-5.png not found - using filters instead"
        );

      const playerBorgyImg = new Image();
      playerBorgyImg.src = "img/player_fish_chippy-5.png"; // You'll need to create this
      playerBorgyImg.onerror = () =>
        console.warn(
          "player_fish_chippy-5.png not found - using filters instead"
        );

      const crabImg = new Image();
      crabImg.src = "img/crab-5.png";
      const jellyfishImg = new Image();
      jellyfishImg.src = "img/jellyfish-5.png";
      const electricJellyfishImg = new Image();
      electricJellyfishImg.src = "img/electric-jellyfish-5.png";
      const sushiImg = new Image();
      sushiImg.src = "img/sushi.png";
      const pufferImg = new Image();
      pufferImg.src = "img/pufferfish-5.png";
      const borgyImg = new Image();
      borgyImg.src = "img/chippy-5.png";
      const chipImg = new Image();
      chipImg.src = "img/chip-5.png";
      chipImg.onerror = () =>
        console.warn(
          "chip.png not found – enemies will keep their normal sprite"
        );

      const pollyImg = new Image();
      pollyImg.src = "img/polly-5.png"; // 35 × 35 fish («Polly»)

      const pollyHelperImg = new Image();
      pollyHelperImg.src = "img/polly-helper.png";

      const playerPollyImg = new Image();
      playerPollyImg.src = "img/player_fish_polly-5.png";

      // const frozenPlaceholderImg = new Image();
      // frozenPlaceholderImg.src = "img/fish-frozen-placeholder.png";

      // ── frozen versions ──────────────────────────────────────────────────────
      const jellyfishFrozenImg = new Image();
      jellyfishFrozenImg.src = "img/jellyfish-5-frozen.png";
      jellyfishFrozenImg.onerror = () =>
        (jellyfishFrozenImg.src = frozenPlaceholderImg.src);

      const electricJellyFrozenImg = new Image();
      electricJellyFrozenImg.src = "img/electric-jellyfish-5-frozen.png";
      electricJellyFrozenImg.onerror = () =>
        (electricJellyFrozenImg.src = frozenPlaceholderImg.src);

      /*********************   GAME VARIABLES   ****************************/
      let fishList = [],
        score = 0,
        nextMilestone = 100000,
        player,
        touchTarget = null;
      let bubbles = [],
        waterTrails = [],
        explosions = [];
      let gameTime = 0, // seconds
        gameTimeMs = 0; // milliseconds

      /* Game-wide timers (NEW) */
      let epochGameStartTime = null;
      let epochGameEndTime = null;

      /* Status effects */
      let playerParalyzeTime = 0;
      const PARALYZE_DURATION = 3;
      const EATING_LEEWAY = 1.18;
      const JELLY_SHRINK_FACTOR = 0.6;
      const MIN_PLAYER_SIZE = 25;
      const GROWTH_FACTOR = 0.04; // ↓ smaller than the old 0.05 means slower growth
      const GROWTH_CAP = 1.5; // (optional) lower the absolute cap too
      let sushiPowerUpTime = 0;
      let borgyPowerUpTime = 0;
      let playerIsPoweredUp = false;

      // <<< Polly power‑up globals & asset -------------------------------
      const POLLY_DURATION = 15; // seconds enemy stay frozen
      let pollyFreezeTime = 0; // counts down while active
      let pollyHelper = null;
      // >>> ----------------------------------------------------------------

      /* --------------- NEW: Debounce state flag ---------------- */
      let startInProgress = false;

      /*********************   AUDIO: HOWLER.JS   *****************************/

      const sounds = {
        backgroundMusic: new Howl({
          src: ["sounds/background5.mp3"],
          loop: true,
          volume: 0.2,
          html5: true, // Ensures streaming for longer music on mobile
        }),
        eat: new Howl({ src: ["sounds/eat.mp3"], volume: 0.5 }),
        gameover: new Howl({ src: ["sounds/gameover.mp3"], volume: 0.5 }),
        powerup: new Howl({ src: ["sounds/powerup.mp3"], volume: 0.5 }),
        borgyPowerUp: new Howl({
          src: ["sounds/borgy-powerup.mp3"],
          volume: 0.3,
        }),
        borgySpawn: new Howl({ src: ["sounds/chippy-spawn.mp3"], volume: 0.3 }),
        pollySpawn: new Howl({ src: ["sounds/polly-spawn.mp3"], volume: 0.3 }),
        pollyPowerUp: new Howl({
          src: ["sounds/polly-powerup.mp3"],
          volume: 0.3,
        }),
        achievement: new Howl({ src: ["sounds/achievement.mp3"], volume: 0.5 }),
        shrink: new Howl({ src: ["sounds/shrink.mp3"], volume: 0.3 }),
        electric: new Howl({ src: ["sounds/electric.mp3"], volume: 0.3 }),
        shock: new Howl({ src: ["sounds/shock.mp3"], volume: 0.5 }),
      };

      let isSfxEnabled = true;
      let isMusicEnabled = true;
      let isJoystickEnabled = true; // DEFAULT: on → joystick mode

      const joystick = {
        active: false,
        baseX: 0,
        baseY: 0,
        stickX: 0,
        stickY: 0,
        radius: 60,
        innerRadius: 24,
      };

      const startAudio = () => {
        if (isMusicEnabled && !sounds.backgroundMusic.playing()) {
          sounds.backgroundMusic.play();
          sounds.backgroundMusic.volume(0.2);
        }
      };

      const stopAudio = () => {
        sounds.backgroundMusic.stop();
      };

      function playSfx(howl) {
        if (!isSfxEnabled) return;
        howl.play();
      }

      const playEatSound = () => playSfx(sounds.eat);
      const playGameOverSound = () => playSfx(sounds.gameover);
      const playPowerUpSound = () => playSfx(sounds.powerup);
      const playBorgyPowerUpSound = () => playSfx(sounds.borgyPowerUp);
      const playBorgySpawnSound = () => playSfx(sounds.borgySpawn);
      const playAchvSound = () => playSfx(sounds.achievement);
      const playShrinkSound = () => playSfx(sounds.shrink);
      const playElectricSound = () => playSfx(sounds.electric);
      const playShockSound = () => playSfx(sounds.shock);
      const playPollySpawnSound = () => playSfx(sounds.pollySpawn);
      const playPollyPowerUpSound = () => playSfx(sounds.pollyPowerUp);

      const updateMusicButtons = () => {
        const txt = isMusicEnabled ? "🎵 Music On" : "🎵 Music Off";
        musicBtn.textContent = txt;
        musicBtnGameOver.textContent = txt;
      };

      const updateSfxButtons = () => {
        const txt = isSfxEnabled ? "🔊 SFX On" : "🔈 SFX Off";
        sfxBtn.textContent = txt;
        sfxBtnGameOver.textContent = txt;
      };

      const updateJoystickButtons = () => {
        const txt = isJoystickEnabled ? "🕹️ Joystick On" : "🕹️ Joystick Off";
        joystickBtn.textContent = txt;
        joystickBtnGameOver.textContent = txt;
      };

      const toggleMusic = () => {
        isMusicEnabled = !isMusicEnabled;
        if (isMusicEnabled) {
          if (!sounds.backgroundMusic.playing()) {
            sounds.backgroundMusic.play();
          }
          sounds.backgroundMusic.volume(0.2);
        } else {
          sounds.backgroundMusic.pause();
        }
        updateMusicButtons();
      };

      const toggleSFX = () => {
        isSfxEnabled = !isSfxEnabled;
        // Use Howler's mute globally for SFX (not music):
        // But to NOT mute music when SFX are off, we control each sound's volume
        // So instead, set SFX volume to 0 or back to original
        sounds.eat.volume(isSfxEnabled ? 0.5 : 0);
        sounds.gameover.volume(isSfxEnabled ? 0.5 : 0);
        sounds.powerup.volume(isSfxEnabled ? 0.5 : 0);
        sounds.borgyPowerUp.volume(isSfxEnabled ? 0.3 : 0);
        sounds.borgySpawn.volume(isSfxEnabled ? 0.3 : 0);
        sounds.achievement.volume(isSfxEnabled ? 0.5 : 0);
        sounds.shrink.volume(isSfxEnabled ? 0.3 : 0);
        sounds.electric.volume(isSfxEnabled ? 0.3 : 0);
        sounds.shock.volume(isSfxEnabled ? 0.5 : 0);
        updateSfxButtons();
      };

      const toggleJoystick = () => {
        isJoystickEnabled = !isJoystickEnabled;
        updateJoystickButtons();
        joystick.active = false;
        touchTarget = null;
      };

      /*********************   HELPERS   *****************************/
      /* ---------- off-screen hue / sat / lum tint ---------- */
      function drawTextWithBg(
        ctx,
        text,
        x,
        y,
        {
          padding = 8,
          radius = 8,
          bgColor = "rgba(0,0,0,0.55)",
          textColor = "#fff",
          font = null,
        } = {}
      ) {
        ctx.save();
        if (font) ctx.font = font;
        const metrics = ctx.measureText(text);
        const textHeight = parseInt(ctx.font.match(/\d+/)); // crude height
        const width = metrics.width + padding * 2;
        const height = textHeight + padding * 1.5;
        // Rounded rect
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fillStyle = bgColor;
        ctx.fill();
        // Text
        ctx.fillStyle = textColor;
        ctx.textBaseline = "top";
        ctx.fillText(text, x + padding, y + padding * 0.75);
        ctx.restore();
        return height;
      }

      const __tintCache = Object.create(null);
      /**
       * Returns a cached <canvas> with the sprite recoloured.
       * @param {HTMLImageElement} img  original sprite
       * @param {number} hueDeg         hue rotation, 0-360
       * @param {number} satMul         saturation multiplier (1 = unchanged)
       * @param {number} lumMul         luminance  multiplier (1 = unchanged)
       */
      function getTintedSprite(img, hueDeg = 0, satMul = 1, lumMul = 1) {
        const key = `${img.src}|${hueDeg}|${satMul}|${lumMul}`;
        if (__tintCache[key]) return __tintCache[key];

        const off = document.createElement("canvas");
        off.width = img.naturalWidth;
        off.height = img.naturalHeight;
        const oc = off.getContext("2d");
        oc.drawImage(img, 0, 0);

        const id = oc.getImageData(0, 0, off.width, off.height);
        const d = id.data;
        const H = (hueDeg % 360) / 360;

        // helpers
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        for (let i = 0; i < d.length; i += 4) {
          // --- RGB ➜ HSL ---
          let r = d[i] / 255,
            g = d[i + 1] / 255,
            b = d[i + 2] / 255;

          const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          let h,
            s,
            l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const diff = max - min;
            s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);
            switch (max) {
              case r:
                h = ((g - b) / diff + (g < b ? 6 : 0)) / 6;
                break;
              case g:
                h = ((b - r) / diff + 2) / 6;
                break;
              case b:
                h = ((r - g) / diff + 4) / 6;
                break;
            }
          }

          // --- shift hue / sat / lum ---
          h = (h + H) % 1;
          s = Math.min(s * satMul, 1);
          l = Math.min(l * lumMul, 1);

          // --- HSL ➜ RGB ---
          if (s === 0) {
            r = g = b = l; // grey
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }

          d[i] = r * 255;
          d[i + 1] = g * 255;
          d[i + 2] = b * 255; // alpha (d[i+3]) unchanged
        }
        oc.putImageData(id, 0, 0);

        return (__tintCache[key] = off);
      }

      const calculateFishScore = (sz) => Math.floor(sz);
      const totalFishWeight = fishTypes.reduce((s, f) => s + f.weight, 0);

      function getRandomWeightedFishType(arr, randFn = Rand) {
        let r = randFn() * totalFishWeight;
        for (const ft of arr) {
          if (r < ft.weight) return ft;
          r -= ft.weight;
        }
        return arr[arr.length - 1];
      }

      function tagEntity(ent, type, manualIdx = null) {
        ent.spawnIdx = manualIdx !== null ? manualIdx : globalSpawnIdx++;
        ent.spawnType = type;
        return ent;
      }

      /* ---------- canvas-filter capability ---------- */
      const CAN_FILTER = (() => {
        try {
          const testCtx = document.createElement("canvas").getContext("2d");
          testCtx.filter = "brightness(2)"; // will be ignored if unsupported
          return testCtx.filter === "brightness(2)";
        } catch (_) {
          return false;
        }
      })();

      /********************* NEW  — SPAWN SPEC GENERATOR ********************/
      const SPAWN_SPEC_WEIGHTS = [
        { kind: "fish", weight: 0.881 },
        { kind: "crab", weight: 0.00147 },
        { kind: "jelly", weight: 0.0294 },
        { kind: "electricJelly", weight: 0.0147 },
        // { kind: "sushi", weight: 0.0147 },
        { kind: "borgy", weight: 0.00735 },
        { kind: "polly", weight: 0.00735 }, // <<< NEW
        { kind: "puffer", weight: 0.0587 },
      ];
      const TOTAL_SPEC_WEIGHT = SPAWN_SPEC_WEIGHTS.reduce(
        (s, w) => s + w.weight,
        0
      );

      function nextSpawnSpec() {
        let r = specRand() * TOTAL_SPEC_WEIGHT;
        for (const w of SPAWN_SPEC_WEIGHTS) {
          if (r < w.weight) return generateSpecByKind(w.kind);
          r -= w.weight;
        }
        return generateSpecByKind("fish");
      }

      function generateSpecByKind(kind) {
        switch (kind) {
          case "fish":
            return generateFishSpec();
          case "crab":
            return { kind: "crab", size: getSpecRandom(50, 120) };
          case "jelly":
            return { kind: "jelly", size: getSpecRandom(30, 80) };
          case "electricJelly":
            return { kind: "electricJelly", size: getSpecRandom(40, 90) };
          case "sushi":
            return { kind: "sushi", fromLeft: specRand() < 0.5 };
          case "borgy":
            return { kind: "borgy", fromLeft: specRand() < 0.5 };
          case "puffer": {
            const baseSize = getSpecRandom(30, 60);
            const fromLeft = specRand() < 0.5;
            return { kind: "puffer", baseSize, fromLeft };
          }
          case "polly":
            return { kind: "polly", fromLeft: specRand() < 0.5 };
        }
      }

      function generateFishSpec() {
        const t = getRandomWeightedFishType(fishTypes, specRand);
        const size = getSpecRandom(t.minSize, t.maxSize);
        const fromLeft = specRand() < 0.5;
        const ultras = specRand();
        const ultra = ultras < 0.01;
        const fast = !ultra && ultras < 0.04;
        const sizeFactor = 1 - size / 500;
        const minSpd = 0.3 + 0.5 * sizeFactor;
        const maxSpd = 1.5 + 0.3 * sizeFactor;
        const baseSpeed = getSpecRandom(minSpd, maxSpd);
        return {
          kind: "fish",
          fishTypeIndex: fishTypes.indexOf(t),
          size,
          fromLeft,
          ultra,
          fast,
          baseSpeed,
        };
      }

      function spawnEntityFromSpec(spec, idx) {
        switch (spec.kind) {
          case "fish": {
            const t = fishTypes[spec.fishTypeIndex];
            const size = spec.size;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, Math.max(0, HEIGHT - size));
            // let spd = spec.baseSpeed * (0.4 + 0.6 * Math.min(score / 1000, 1));
            // if (spec.ultra) spd *= 5;
            // else if (spec.fast) spd *= 3;
            // spd = fromLeft ? spd : -spd;

            // ① Base ramp‑up (unchanged): 0 → 1× between 0‑1 000 pts
            const baseMult = 0.4 + 0.6 * Math.min(score / 1000, 1);

            /*
             * ② Extra ramp‑up: starts once the player is already at
             *    the “full” base speed (≥1 000 pts) and rises linearly
             *    to +25 % at 100 000 pts.
             *
             *    – We use the range 1 000 → 100 000 pts (Δ = 99 000).
             *    – Slope = 0.25 / 99 000  (≈ 2.53 e‑6 per point)
             *    – Continues past 100 000 pts with the same slope,
             *      so the reset-round at 100 k does **not** roll it back.
             */
            const extraMult = (Math.max(score - 1000, 0) / 99000) * 0.25; // linear 0 → 0.25 → …

            // ③ Total multiplier
            let spd = spec.baseSpeed * (baseMult + extraMult);

            // keep the existing “fast / ultra” modifiers & direction
            if (spec.ultra) spd *= 5;
            else if (spec.fast) spd *= 3;
            spd = fromLeft ? spd : -spd;

            const fish = tagEntity(
              new Fish(x, y, spd, 0, t.image, size, false),
              "fish",
              idx
            );
            fish.fishType = t;
            fish.isUltraFast = spec.ultra;
            fish.isFast = spec.fast;
            fishList.push(fish);
            break;
          }
          case "crab": {
            const size = spec.size;
            fishList.push(
              tagEntity(
                new Crab(getRandom(0, WIDTH - size), HEIGHT + size, size),
                "crab",
                idx
              )
            );
            break;
          }
          case "jelly": {
            const size = spec.size;
            fishList.push(
              tagEntity(
                new Jellyfish(getRandom(0, WIDTH - size), HEIGHT + size, size),
                "jelly",
                idx
              )
            );
            break;
          }
          case "electricJelly": {
            const size = spec.size;
            fishList.push(
              tagEntity(
                new ElectricJellyfish(
                  getRandom(0, WIDTH - size),
                  HEIGHT + size,
                  size
                ),
                "elecJelly",
                idx
              )
            );
            break;
          }
          case "sushi": {
            const size = 30;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, HEIGHT - size);
            const spd = (fromLeft ? 1 : -1) * 1.5;
            fishList.push(tagEntity(new Sushi(x, y, spd), "sushi", idx));
            break;
          }
          case "borgy": {
            const size = CHIPPY_SIZE;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, HEIGHT - size);
            const spd = (fromLeft ? 1 : -1) * 1.2;
            fishList.push(tagEntity(new Borgy(x, y, spd), "borgy", idx));
            playBorgySpawnSound();
            break;
          }
          case "puffer": {
            const baseSize = spec.baseSize;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -baseSize : WIDTH;
            const y = getRandom(0, HEIGHT - baseSize);
            const spd = getRandom(0.2, 1.2) * (fromLeft ? 1 : -1);
            fishList.push(
              tagEntity(new Pufferfish(x, y, spd, baseSize), "puffer", idx)
            );
            break;
          }
          case "polly": {
            const size = POLLY_SIZE;
            const fromLeft = spec.fromLeft;
            const x = fromLeft ? -size : WIDTH;
            const y = getRandom(0, HEIGHT - size);
            const spd = (fromLeft ? 1 : -1) * 1.2;
            fishList.push(tagEntity(new Polly(x, y, spd), "polly", idx));
            playPollySpawnSound(); // <-- add this
            break;
          }
        }
      }

      /*********************   SCHEDULED SPAWN PROCESSOR   *********************/
      function processScheduledSpawns() {
        ensureScheduleAhead();
        while (
          nextScheduleIdx < spawnSchedule.length &&
          spawnSchedule[nextScheduleIdx].spawnTime <= gameTime
        ) {
          const entry = spawnSchedule[nextScheduleIdx];
          const spec = entry.spec;

          /* Difficulty / cap rule checks */
          const maxEnemies = score < 1000 ? 20 : 30;
          const isEnemy =
            spec.kind !== "sushi" &&
            spec.kind !== "borgy" &&
            spec.kind !== "crab";
          if (isEnemy && fishList.length >= maxEnemies) {
            nextScheduleIdx++;
            continue;
          }
          if (spec.kind === "crab" && score < 2000) {
            nextScheduleIdx++;
            continue;
          }

          spawnEntityFromSpec(spec, entry.idx);
          nextScheduleIdx++;
        }

        /* Recycle old schedule entries */
        if (nextScheduleIdx > RETAIN_SCHEDULE_ENTRIES) {
          const removeCount = nextScheduleIdx - RETAIN_SCHEDULE_ENTRIES;
          spawnSchedule.splice(0, removeCount);
          nextScheduleIdx -= removeCount;
        }
      }

      /*********************    CLASS DEFINITIONS  *************************/
      /* ---- WaterTrail ---- */
      class WaterTrail {
        constructor(x, y, dir, fishSize, isUltra = false, colorRGB = null) {
          this.x = x;
          this.y = y;
          this.size = getRandom(
            Math.min(8, Math.max(2, fishSize * 0.1)) * 0.8,
            Math.min(8, Math.max(2, fishSize * 0.1)) * 1.2
          );
          this.life = 1;
          this.fadeSpeed = getRandom(0.02, 0.04);
          this.dir = dir;
          this.offsetX = getRandom(-3, 3);
          this.offsetY = getRandom(-3, 3);
          this.isUltra = isUltra;
          this.colorRGB = colorRGB;
          this.hue = Rand() * 360;
          this.hueSpeed = getRandom(2, 4);
        }
        update(dt) {
          this.life -= this.fadeSpeed * dt * 60;
          this.x += this.dir * 0.5 * dt * 60;
          if (this.isUltra) this.hue = (this.hue + this.hueSpeed) % 360;
        }
        draw(c) {
          // if (this.life <= 0) return;
          /* ---- safety: bail if any value is non‑finite ---- */
          if (
            !Number.isFinite(this.x) ||
            !Number.isFinite(this.y) ||
            !Number.isFinite(this.size)
          )
            return;
          c.beginPath();
          c.arc(
            this.x + this.offsetX,
            this.y + this.offsetY,
            this.size,
            0,
            Math.PI * 2
          );

          if (this.isUltra) {
            c.fillStyle = `hsla(${this.hue},100%,50%,${this.life * 0.3})`;
            c.shadowBlur = 10;
            c.shadowColor = `hsla(${this.hue},100%,50%,${this.life * 0.3})`;
          } else if (this.colorRGB) {
            const { r, g, b } = this.colorRGB;
            c.fillStyle = `rgba(${r},${g},${b},${this.life * 0.3})`;
            c.shadowBlur = 6;
            c.shadowColor = `rgba(${r},${g},${b},${this.life * 0.3})`;
          } else {
            c.fillStyle = `rgba(255,255,255,${this.life * 0.05})`;
            c.shadowBlur = 0;
          }
          c.fill();
          c.shadowBlur = 0;
        }
      }

      /* ---- Fish (base + player) ---- */
      class Fish {
        constructor(x, y, sx, sy, img, maxSide, isPlayer = false) {
          this.baseSprite = img;
          this.x = x;
          this.y = y;
          this.speedX = sx;
          this.speedY = sy;
          this.sprite = img;
          this.maxSide = maxSide;
          this.isPlayer = isPlayer;
          this.lastTrailTime = 0;
          this.isFast =
            this.isUltraFast =
            this.isCrab =
            this.isJellyfish =
            this.isSushi =
            this.isBorgy =
            this.isPuffer =
            this.isPolly =
            this.isPollyHelper =
              false;
          this.drawFullHeight = false;
          if (!isPlayer) {
            this.oscSpd = getRandom(0.005, 0.01);
            this.oscAmt = getRandom(0.05, 0.1);
            this.oscOff = getRandom(0, Math.PI * 2);
            this.accel = 0.05;
            this.maxSpd = Math.abs(sx) * 1.2;
          } else {
            this.vx = this.vy = 0;
            this.accel = 0.055;
            this.friction = 0.99;
            this.baseMaxSpd = 10;
            this.maxSpd = this.baseMaxSpd;
            this.facingLeft = false;
          }
          this.width = this.height = null;
        }
        calculateDimensions() {
          const w = this.sprite.naturalWidth,
            h = this.sprite.naturalHeight;
          if (!w || !h) {
            this.width = this.height = this.maxSide;
            return;
          }
          const asp = w / h;
          if (asp > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / asp;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * asp;
          }
        }
        draw(c) {
          if (!this.sprite.complete) return;
          // sprite finished downloading but failed? – also skip it
          if (!this.sprite.naturalWidth || !this.sprite.naturalHeight) return;
          if (this.width === null || this.height === null)
            this.calculateDimensions();

          if (this.isPlayer) {
            if (Math.abs(this.vx) > 0.1) this.facingLeft = this.vx < 0;
          }
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;

          const ultra =
            this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
          const boostRemaining =
            borgyPowerUpTime > 0
              ? borgyPowerUpTime
              : pollyFreezeTime > 0
              ? pollyFreezeTime
              : sushiPowerUpTime;
          const flickerActive =
            this.isPlayer && playerIsPoweredUp && boostRemaining <= 3;

          c.save();
          if (movingLeft) {
            c.translate(this.x + this.width / 2, this.y + this.height / 2);
            c.scale(-1, 1);
            c.translate(-this.width / 2, -this.height / 2);
          } else c.translate(this.x, this.y);

          // NEW: Select appropriate sprite for player based on state
          let imgToDraw = this.sprite;
          let useFilter = true; // Whether to apply CSS filters

          /* Enemy re‑skin while Borgy power‑up is active */
          if (
            !this.isPlayer &&
            !this.isPolly && // ⬅️  NEW
            !this.isBorgy && // ⬅️  NEW (Chippy itself)
            !this.isPollyHelper &&
            borgyPowerUpTime > 0 &&
            chipImg.complete &&
            chipImg.naturalWidth > 0
          ) {
            imgToDraw = chipImg;
            useFilter = false; // no colour tweaks on Chip sprite
            this.drawFullHeight = true;
          } else {
            // when the potion is gone, go back to normal drawing
            // Power‑up ended: clear the flag *only* for the Chip skin itself.
            // Frozen sprites (or anything else) keep their own setting.
            if (this.sprite === chipImg) {
              this.drawFullHeight = false;
            }
          }

          if (this.isPlayer) {
            if (
              playerParalyzedImg.complete &&
              playerParalyzedImg.naturalWidth > 0 &&
              playerParalyzeTime > 0
            ) {
              imgToDraw = playerParalyzedImg;
              useFilter = false; // Don't apply filter since we have a custom sprite
            } else if (
              playerBorgyImg.complete &&
              playerBorgyImg.naturalWidth > 0 &&
              borgyPowerUpTime > 0
            ) {
              imgToDraw = playerBorgyImg;
              useFilter = false;
            } else if (
              playerPoweredUpImg.complete &&
              playerPoweredUpImg.naturalWidth > 0 &&
              sushiPowerUpTime > 0
            ) {
              imgToDraw = playerPoweredUpImg;
              useFilter = false;
            } else if (
              playerPollyImg.complete &&
              playerPollyImg.naturalWidth > 0 &&
              pollyFreezeTime > 0
            ) {
              imgToDraw = playerPollyImg;
              useFilter = false;
            }
          }

          // Apply filters only if we're using the original sprite or for non-player entities
          if (useFilter) {
            if (this.isPlayer && playerParalyzeTime > 0) {
              c.filter = "hue-rotate(30deg) brightness(1.4) saturate(1.8)";
            } else if (this.isPlayer && borgyPowerUpTime > 0) {
              c.filter = "hue-rotate(100deg) brightness(2) saturate(3)";
            } else if (ultra) {
              c.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
            } else if (this.isFast) {
              c.filter = "hue-rotate(45deg) brightness(1.2)";
            }
          }

          if (flickerActive) {
            // Toggle every 100 ms → full opacity vs almost invisible
            const blinkVisible =
              (Math.floor(performance.now() / 100) & 1) === 0;
            c.globalAlpha = blinkVisible ? 1 : 0.15; // 0.15 ≈ "off" frame
            // keep the desaturate/brightness tweak so the colour shift remains
            if (useFilter) {
              c.filter =
                (c.filter ? c.filter + " " : "") +
                "brightness(0.7) contrast(0.9)";
            }
          }

          /* ---------- BEGIN filtered / fallback draw ---------- */
          if (!CAN_FILTER && useFilter) {
            // Decide which tint, mimicking the original filter stacks
            let tintParams = null; // [hueDeg, satMul, lumMul]
            if (this.isPlayer && playerParalyzeTime > 0)
              tintParams = [30, 1.8, 1.4]; // yellow-ish
            else if (this.isPlayer && borgyPowerUpTime > 0)
              tintParams = [100, 3.0, 2.0]; // green boost
            else if (ultra) tintParams = [180, 2.0, 1.5]; // rainbow-fish
            else if (this.isFast) tintParams = [45, 1.2, 1.2]; // quick fish

            if (tintParams) {
              const [h, s, l] = tintParams;
              imgToDraw = getTintedSprite(this.sprite, h, s, l);
            }
          }
          /* ---------- draw sprite (original or tinted) ---------- */

          // NEW  –  keep the sprite’s natural aspect‑ratio when requested
          let drawW = this.width; // logical width (physics)
          let drawH = this.height; // logical height
          let offset = 0; // centred shift if needed

          if (this.drawFullHeight && this.sprite.naturalHeight) {
            const scale = this.height / this.sprite.naturalHeight; // stretch to full height
            drawW = this.sprite.naturalWidth * scale; // preserve aspect
            offset = (this.width - drawW) / 2; // centre inside hit‑box
          }

          c.drawImage(imgToDraw, offset, 0, drawW, drawH);
          /* ---------- END patch ---------- */

          c.restore();
        }
        getBounds() {
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          const scale = 0.6,
            rX = (this.width * scale) / 2,
            rY = (this.height * scale) / 2;
          let cX = this.x + this.width / 2,
            cY = this.y + this.height / 2;
          const shift = this.width * 0.07;
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;
          if (movingLeft) cX -= shift;
          else cX += shift;
          return { centerX: cX, centerY: cY, radiusX: rX, radiusY: rY };
        }
        update(dt) {
          const df = dt * 60;
          if (this.isPlayer) {
            let speedMult = 1;
            if (borgyPowerUpTime > 0) speedMult = BORGY_SPEED_MULT;
            else if (pollyFreezeTime > 0) speedMult = POLLY_SPEED_MULT;
            this.maxSpd = this.baseMaxSpd * speedMult;

            const f = Math.pow(this.friction, df);
            this.vx *= f;
            this.vy *= f;
            this.x += this.vx * df;
            this.y += this.vy * df;
            if (this.width && this.height) {
              if (this.x < 0) {
                this.x = 0;
                this.vx = 0;
              }
              if (this.y < 0) {
                this.y = 0;
                this.vy = 0;
              }
              if (this.x + this.width > WIDTH) {
                this.x = WIDTH - this.width;
                this.vx = 0;
              }
              if (this.y + this.height > HEIGHT) {
                this.y = HEIGHT - this.height;
                this.vy = 0;
              }
            }
          } else {
            const osc =
              Math.sin(performance.now() * this.oscSpd + this.oscOff) *
              this.oscAmt;
            if (!this.isJellyfish && !this.isCrab && !this.isPollyHelper) {
              this.speedX +=
                this.accel *
                Math.sign(this.speedX) *
                df *
                (Math.abs(this.speedX) < this.maxSpd ? 1 : 0);
              if (Math.abs(this.speedX) > this.maxSpd)
                this.speedX = Math.sign(this.speedX) * this.maxSpd;
              this.x += this.speedX * df;
              this.y += osc * df;
            }
          }
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 50) return;
          this.lastTrailTime = now;
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;
          const speed = this.isPlayer
            ? Math.hypot(this.vx, this.vy)
            : Math.abs(this.speedX);
          if (speed > 0.5) {
            const ultra =
              this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
            const count = ultra ? 2 : Rand() < 0.3 ? 1 : 0;
            for (let i = 0; i < count; i++) {
              waterTrails.push(
                new WaterTrail(
                  this.x + (movingLeft ? this.width : 0),
                  this.y + this.height * 0.5,
                  movingLeft ? 1 : -1,
                  this.maxSide,
                  ultra
                )
              );
              if (waterTrails.length > MAX_WATER_TRAILS) {
                waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
              }
            }
          }
        }
      }

      /* ---- Crab ---- */
      class Crab extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, 0, crabImg, size, false);
          this.isCrab = true;
          this.entered = false;
          this.timeAlive = 0;
          this.remove = false;
        }
        update(dt, player) {
          if (this.remove) return;
          const df = dt * 60;
          if (!this.entered) {
            this.y -= 2 * df;
            if (this.y + this.height <= HEIGHT) this.entered = true;
            return;
          }
          this.timeAlive += dt;
          if (this.timeAlive > 15) {
            spawnExplosion(this);
            this.remove = true;
            return;
          }
          const c = this.getBounds(),
            p = player.getBounds();
          const dx = p.centerX - c.centerX,
            dy = p.centerY - c.centerY,
            dist = Math.hypot(dx, dy) || 1;
          const s = 1.5;
          if (c.radiusX > p.radiusX) {
            this.x += (dx / dist) * s * df;
            this.y += (dy / dist) * s * df;
          } else {
            this.x -= (dx / dist) * s * df;
            this.y -= (dy / dist) * s * df;
          }
          if (this.width && this.height) {
            this.x = Math.min(Math.max(0, this.x), WIDTH - this.width);
            this.y = Math.min(Math.max(0, this.y), HEIGHT - this.height);
          }
        }
      }

      /* ---- Jellyfish ---- */
      class Jellyfish extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, -1.2, jellyfishImg, size, false);
          this.frozenSprite = jellyfishFrozenImg;
          this.isJellyfish = true;
          this.oscS = getRandom(0.0008, 0.0015);
          this.oscA = getRandom(10, 15);
          this.oscO = Rand() * Math.PI * 2;
          this.baseX = x;
          this.vSpeed = getRandom(0.5, 1.2);
        }
        update(dt) {
          const df = dt * 60;
          this.y -= this.vSpeed * df;
          this.x =
            this.baseX +
            Math.sin(performance.now() * this.oscS + this.oscO) * this.oscA;
          if (this.y + this.height < -50) this.maxSide = 0;
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 80) return;
          this.lastTrailTime = now;
          waterTrails.push(
            new WaterTrail(
              this.x + this.width / 2,
              this.y + this.height,
              0,
              this.maxSide * 0.4,
              false,
              { r: 120, g: 0, b: 0 }
            )
          );
          if (waterTrails.length > MAX_WATER_TRAILS)
            waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
        }
      }

      /* ---- Electric Jellyfish ---- */
      class ElectricJellyfish extends Jellyfish {
        constructor(x, y, size) {
          super(x, y, size);
          this.frozenSprite = electricJellyFrozenImg;
          this.sprite = electricJellyfishImg;
          this.isElectric = true;
          this.pulseCooldown = getRandom(5, 12);
          this.pauseTimeRemaining = 0;
          this.pulseRadius = size * 2.3;
        }
        update(dt) {
          if (this.pauseTimeRemaining > 0) {
            this.pauseTimeRemaining -= dt;
            if (this.pauseTimeRemaining <= 0) {
              this.pauseTimeRemaining = 0;
              // thaw out frozen enemies
              const phase = Math.sin(performance.now() * this.oscS + this.oscO);
              this.baseX = this.x - phase * this.oscA;
              this.pulseCooldown = getRandom(5, 12);
            }
            return;
          }
          this.pulseCooldown -= dt;
          if (this.pulseCooldown <= 0) {
            this.performPulse();
            return;
          }
          super.update(dt);
        }
        performPulse() {
          this.pauseTimeRemaining = 1;
          this.pulseCooldown = getRandom(5, 12);
          playElectricSound();
          const p = player.getBounds();
          const b = this.getBounds();
          const dx = p.centerX - b.centerX;
          const dy = p.centerY - b.centerY;
          const dist = Math.hypot(dx, dy);
          if (dist <= this.pulseRadius && borgyPowerUpTime <= 0) {
            playerParalyzeTime = PARALYZE_DURATION;
            playShockSound();
          }
        }
        draw(c) {
          super.draw(c);
          if (this.pauseTimeRemaining > 0 && this.width && this.height) {
            const alpha = this.pauseTimeRemaining;
            const cx = this.x + this.width / 2;
            const cy = this.y + this.height / 2;
            const maxLen = this.pulseRadius * (1 - alpha * 0.25);
            const bolts = 10;
            const segmentsPerBolt = 3;
            c.save();
            for (let i = 0; i < bolts; i++) {
              const baseAngle = (i / bolts) * Math.PI * 2;
              let prevX = cx,
                prevY = cy;
              for (let s = 1; s <= segmentsPerBolt; s++) {
                const segLen = (maxLen / segmentsPerBolt) * s;
                const jitter = segLen * 0.25;
                const angle = baseAngle + getRandom(-0.2, 0.2);
                const x =
                  cx + Math.cos(angle) * segLen + getRandom(-jitter, jitter);
                const y =
                  cy + Math.sin(angle) * segLen + getRandom(-jitter, jitter);
                c.beginPath();
                c.moveTo(prevX, prevY);
                c.lineTo(x, y);
                c.strokeStyle = `rgba(255,255,0,${alpha})`;
                c.lineWidth = 2;
                c.shadowBlur = 8;
                c.shadowColor = `rgba(255,255,0,${alpha})`;
                c.stroke();
                prevX = x;
                prevY = y;
              }
            }
            c.restore();
          }
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 80) return;
          this.lastTrailTime = now;
          waterTrails.push(
            new WaterTrail(
              this.x + this.width / 2,
              this.y + this.height,
              0,
              this.maxSide * 0.4,
              false,
              { r: 255, g: 255, b: 0 }
            )
          );
          if (waterTrails.length > MAX_WATER_TRAILS)
            waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
        }
      }

      /* ---- Sushi ---- */
      class Sushi extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, sushiImg, 30, false);
          this.isSushi = true;
        }
      }

      /* ---- Borgy ---- */
      class Borgy extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, borgyImg, CHIPPY_SIZE, false);
          this.isBorgy = true;
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          // Create trail more frequently
          if (now - this.lastTrailTime < 25) return; // was 50ms for normal fish
          this.lastTrailTime = now;
          // Bigger, colored, and more persistent
          const movingLeft = this.speedX < 0;
          for (let i = 0; i < 3; i++) {
            // triple trail for visibility
            waterTrails.push(
              new WaterTrail(
                this.x + (movingLeft ? this.width : 0),
                this.y + this.height * (0.3 + 0.4 * Math.random()), // more spread
                movingLeft ? 1 : -1,
                this.maxSide * 1.2, // larger trail
                false,
                { r: 3, g: 176, b: 176 } // teal color #03b0b0
              )
            );
          }
          if (waterTrails.length > MAX_WATER_TRAILS) {
            waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
          }
        }
      }

      /* ---- Pufferfish ---- */
      class Pufferfish extends Fish {
        constructor(x, y, speedX, baseSize) {
          super(x, y, speedX, 0, pufferImg, baseSize, false);
          this.frozenSprite = frozenPlaceholderImg;
          this.isPuffer = true;
          this.baseSize = baseSize;
          this.inflating = false;
          this.inflateStart = 0;
          this.inflateDuration = 500;
        }
        update(dt) {
          super.update(dt);
          if (!this.inflating && this.maxSide < this.baseSize * 2.9) {
            if (Rand() < 0.0003 * dt * 60) {
              this.inflating = true;
              this.inflateStart = performance.now();
            }
          }
          if (this.inflating) {
            const elapsed = performance.now() - this.inflateStart;
            const p = Math.min(elapsed / this.inflateDuration, 1);
            const centreX = this.x + (this.width ?? this.maxSide) / 2;
            const centreY = this.y + (this.height ?? this.maxSide) / 2;
            this.maxSide = this.baseSize * (1 + 3 * p);
            this.width = this.height = null;
            this.calculateDimensions();
            this.x = centreX - this.width / 2;
            this.y = centreY - this.height / 2;
            if (p === 1) this.inflating = false;
          }
        }
      }

      /* ---- Polly (freeze power‑up) ---- */
      // <<< add directly after Borgy / Pufferfish classes ---------------
      class Polly extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, pollyImg, POLLY_SIZE, false);
          this.isPolly = true;
          // no extra behaviour – basic Fish flight path
        }
      }
      // >>> ----------------------------------------------------------------

      /* ---- PollyHelper ---- */
      class PollyHelper extends Fish {
        constructor(x, size) {
          super(x, -size, 0, 0, pollyHelperImg, size, false);
          this.isPollyHelper = true;
          this.speed = 2.5;
          this.timeAlive = 0;
          this.remove = false;
        }
        update(dt) {
          if (this.remove) return;
          const df = dt * 60;
          this.timeAlive += dt;
          let minDist = Infinity;
          let nearest = null;
          for (const f of fishList) {
            if (
              f === this ||
              f.isPlayer ||
              f.isPollyHelper ||
              f.remove ||
              f.maxSide <= 0
            )
              continue;
            const d = Math.hypot(f.x - this.x, f.y - this.y);
            if (d < minDist) {
              minDist = d;
              nearest = f;
            }
          }
          if (nearest) {
            const myB = this.getBounds();
            const eB = nearest.getBounds();
            const dx = eB.centerX - myB.centerX;
            const dy = eB.centerY - myB.centerY;
            const dist = Math.hypot(dx, dy) || 1;
            const s = this.speed;
            this.x += (dx / dist) * s * df;
            this.y += (dy / dist) * s * df;
            this.speedX = dx > 0 ? 2 : -2;
          }
          if (this.width && this.height) {
            this.x = Math.min(Math.max(0, this.x), WIDTH - this.width);
            this.y = Math.min(Math.max(0, this.y), HEIGHT - this.height);
          }
        }
      }

      /* ---- Bubble & Explosion ---- */
      class Bubble {
        constructor(baseX) {
          this.baseX = baseX;
          this.x = this.baseX + getRandom(-10, 10);
          this.y = HEIGHT + 20;
          this.size = getRandom(3, 8);
          this.speed = getRandom(2, 3.5);
          this.opacity = getRandom(0.2, 0.4);
          this.wobbleAmount = getRandom(0.1, 0.3);
          this.wobbleSpeed = getRandom(0.02, 0.05);
          this.wobbleOffset = Rand() * Math.PI * 2;
        }
        update(dt) {
          this.y -= this.speed * dt * 60;
          this.x +=
            Math.sin(this.wobbleOffset + performance.now() * this.wobbleSpeed) *
            this.wobbleAmount *
            dt *
            60;
        }
        draw(c) {
          c.beginPath();
          c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          c.fillStyle = `rgba(255,255,255,${this.opacity})`;
          c.fill();
        }
      }

      class Explosion {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.particles = [];
          this.life = 1;
          this.fadeSpeed = 0.02;
          const n = Math.floor(size * 0.5);
          for (let i = 0; i < n; i++) {
            const angle = (i / n) * Math.PI * 2,
              spd = getRandom(2, 4);
            this.particles.push({
              x: 0,
              y: 0,
              sx: Math.cos(angle) * spd,
              sy: Math.sin(angle) * spd,
              size: getRandom(3, 8),
              life: 1,
              fadeSpeed: getRandom(0.01, 0.03),
            });
          }
        }
        update(dt) {
          this.life -= this.fadeSpeed * dt * 60;
          for (const p of this.particles) {
            p.x += p.sx * dt * 60;
            p.y += p.sy * dt * 60;
            p.life -= p.fadeSpeed * dt * 60;
          }
        }
        isComplete() {
          return this.life <= 0;
        }
        draw(c) {
          if (this.isComplete()) return;
          if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;
          for (const p of this.particles) {
            if (p.life <= 0) continue;
            c.beginPath();
            c.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
            c.fillStyle = `rgba(255,255,255,${p.life * 0.8})`;
            c.fill();
          }
        }
      }

      /*********************      SPAWNERS      *****************************/
      function spawnExplosion(f) {
        if (f.width && f.height) {
          explosions.push(
            new Explosion(f.x + f.width / 2, f.y + f.height / 2, f.maxSide)
          );
          if (explosions.length > MAX_EXPLOSIONS)
            explosions.splice(0, explosions.length - MAX_EXPLOSIONS);
        }
      }

      /* Bubble helper */
      function spawnBubbleGroup() {
        const n = Math.floor(getRandom(3, 6));
        const baseX = getRandom(50, WIDTH - 50);
        for (let i = 0; i < n; i++) bubbles.push(new Bubble(baseX));
      }
      let bubbleTimer = 0;
      const BUBBLE_INTERVAL = 20;

      /*********************     RESET ROUND (size)     *********************/
      function resetRound() {
        fishList = [];
        bubbles = [];
        waterTrails = [];
        explosions = [];
        player.maxSide = 25;
        player.width = player.height = null;
        player.x = WIDTH / 2;
        player.y = HEIGHT / 2;
        player.vx = player.vy = 0;
        sushiPowerUpTime = 0;
        borgyPowerUpTime = 0;
        playerIsPoweredUp = false;
        playerParalyzeTime = 0;
        pollyFreezeTime = 0;
        pollyHelper = null;
        joystick.active = false;
        spawnBubbleGroup();
        bubbleTimer = 0;
      }

      /*********************      GAME LOOP LOGIC      *********************/
      function checkCollisionOval(a, b) {
        const A = a.getBounds();
        const B = b.getBounds();
        if (
          A.radiusX === 0 ||
          A.radiusY === 0 ||
          B.radiusX === 0 ||
          B.radiusY === 0
        )
          return false;
        const dx = A.centerX - B.centerX;
        const dy = A.centerY - B.centerY;
        return (
          (dx * dx) / (A.radiusX + B.radiusX) ** 2 +
            (dy * dy) / (A.radiusY + B.radiusY) ** 2 <=
          1
        );
      }

      function updateGame(dt) {
        /* explosions */
        for (let i = explosions.length - 1; i >= 0; i--) {
          explosions[i].update(dt);
          if (explosions[i].isComplete()) explosions.splice(i, 1);
        }
        if (pendingGameOver && explosions.length === 0) {
          showGameOverScreen(score);
          pendingGameOver = false;
        }
        if (gameState !== "playing") return;
        if (isGameOver) return;

        /* time */
        gameTime += dt;
        gameTimeMs = Math.round(gameTime * 1000);

        /* Polly timer --------------------------------------------------- */
        if (pollyFreezeTime > 0) {
          pollyFreezeTime -= dt;
          if (pollyFreezeTime <= 0) {
            pollyFreezeTime = 0;
            // thaw out frozen enemies
            fishList.forEach((f) => {
              if (f.isFrozen) {
                f.isFrozen = false;
                f.speedX = f.origSpeedX;
                f.speedY = f.origSpeedY;
                if (f.origSprite) f.sprite = f.origSprite;
                f.drawFullHeight = false;
              }
            });
            if (pollyHelper) {
              spawnExplosion(pollyHelper);
              const idx = fishList.indexOf(pollyHelper);
              if (idx !== -1) fishList.splice(idx, 1);
              pollyHelper = null;
            }
          }
        }

        /* power-up timers */
        if (sushiPowerUpTime > 0) {
          sushiPowerUpTime -= dt;
          if (sushiPowerUpTime <= 0) sushiPowerUpTime = 0;
        }
        if (borgyPowerUpTime > 0) {
          borgyPowerUpTime -= dt;
          if (borgyPowerUpTime <= 0) borgyPowerUpTime = 0;
        }
        // playerIsPoweredUp = sushiPowerUpTime > 0 || borgyPowerUpTime > 0;
        playerIsPoweredUp = pollyFreezeTime > 0 || borgyPowerUpTime > 0;

        /* status decrement */
        if (playerParalyzeTime > 0) {
          playerParalyzeTime -= dt;
          if (playerParalyzeTime < 0) playerParalyzeTime = 0;
        }

        /* spawn processing */
        processScheduledSpawns();

        /* bubbles */
        for (let i = bubbles.length - 1; i >= 0; i--) {
          bubbles[i].update(dt);
          if (bubbles[i].y < -20) bubbles.splice(i, 1);
        }
        bubbleTimer += dt;
        if (bubbleTimer >= BUBBLE_INTERVAL) {
          spawnBubbleGroup();
          bubbleTimer = 0;
        }

        /* water trails */
        for (let i = waterTrails.length - 1; i >= 0; i--) {
          waterTrails[i].update(dt);
          if (waterTrails[i].life <= 0) waterTrails.splice(i, 1);
        }
        if (waterTrails.length > MAX_WATER_TRAILS) {
          waterTrails.splice(0, waterTrails.length - MAX_WATER_TRAILS);
        }

        /* player input */
        const canMove = playerParalyzeTime <= 0;
        const accelMult =
          borgyPowerUpTime > 0
            ? BORGY_SPEED_MULT
            : pollyFreezeTime > 0
            ? POLLY_SPEED_MULT
            : 1;

        const a = player.accel * accelMult * dt * 60;

        if (canMove) {
          if (isJoystickEnabled && joystick.active) {
            const dx = joystick.stickX - joystick.baseX;
            const dy = joystick.stickY - joystick.baseY;
            const dist = Math.hypot(dx, dy);
            if (dist > 5) {
              const nx = dx / dist;
              const ny = dy / dist;
              const force = dist / joystick.radius;
              player.vx += nx * a * force;
              player.vy += ny * a * force;
            }
          } else {
            if (keys.left) player.vx -= a;
            if (keys.right) player.vx += a;
            if (keys.up) player.vy -= a;
            if (keys.down) player.vy += a;
            if (touchTarget && player.width && player.height) {
              const px = player.x + player.width / 2;
              const py = player.y + player.height / 2;
              const dx = touchTarget.x - px;
              const dy = touchTarget.y - py;
              const dist = Math.hypot(dx, dy);
              if (dist > 1) {
                player.vx += (dx / dist) * a;
                player.vy += (dy / dist) * a;
              }
            }
          }
        }

        const spd = Math.hypot(player.vx, player.vy);
        if (spd > player.maxSpd) {
          const r = player.maxSpd / spd;
          player.vx *= r;
          player.vy *= r;
        }

        /* update entities */
        player.update(dt);
        player.createWaterTrail();

        /* enemies & pickups */
        for (let i = fishList.length - 1; i >= 0; i--) {
          const e = fishList[i];
          /* honour freeze ------------------------------------------------ */
          if (!e.isPlayer && e.isFrozen) {
            // skip movement & AI – but still let player collide with it
          } else {
            if (e.remove) {
              fishList.splice(i, 1);
              continue;
            }
            if (e instanceof ElectricJellyfish) e.update(dt);
            else if (e.isCrab) e.update(dt, player);
            else if (e.isPollyHelper) e.update(dt);
            else e.update(dt);
          }
          e.createWaterTrail();

          const b = e.getBounds();
          if (
            e.maxSide <= 0 ||
            b.centerX + b.radiusX < -200 ||
            b.centerX - b.radiusX > WIDTH + 200 ||
            e.y > HEIGHT + 200
          ) {
            fishList.splice(i, 1);
            continue;
          }

          /* collision with player */
          if (checkCollisionOval(player, e)) {
            if (e.isPollyHelper) continue;
            /* --- Polly pickup ------------------------------------------ */
            if (e.isPolly) {
              score += 75;
              pollyFreezeTime = POLLY_DURATION;
              playPollyPowerUpSound();

              // freeze every enemy now on screen
              fishList.forEach((f) => {
                if (
                  !f.isPolly &&
                  !f.isSushi &&
                  !f.isCrab &&
                  !f.isFrozen &&
                  !f.isBorgy &&
                  !f.isPollyHelper
                ) {
                  /* --- physics --- */
                  f.isFrozen = true;
                  f.origSpeedX = f.speedX;
                  f.origSpeedY = f.speedY;
                  f.speedX = f.speedY = 0;

                  /* --- remember what sprite to restore after thaw --- */
                  f.origSprite = f.sprite; // may be a <canvas>, that’s OK

                  // /* --- build the frozen skin safely --- */
                  // const imgForSrc =
                  //   f.baseSprite instanceof HTMLImageElement
                  //     ? f.baseSprite
                  //     : null; // fallback if ever undefined

                  // const frozenImg = new Image();
                  // if (imgForSrc && imgForSrc.src.endsWith(".png")) {
                  //   frozenImg.src = imgForSrc.src.replace(
                  //     /\.png$/,
                  //     "-frozen.png"
                  //   );
                  // } else {
                  //   frozenImg.src = "img/fish-frozen-placeholder.png";
                  // }
                  // /* NEW: fallback if that -frozen file is 404 */
                  // frozenImg.onerror = () => {
                  //   frozenImg.src = "img/fish-frozen-placeholder.png";
                  // };

                  // f.frozenSprite = frozenImg;
                  // f.sprite = frozenImg;
                  /* swap to the pre‑cached frozen skin */
                  const frozenSkin = f.frozenSprite || f.fishType?.frozenSprite;
                  if (frozenSkin) f.sprite = frozenSkin;
                  f.drawFullHeight = true;
                }
              });
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: false,
              });
              if (!pollyHelper) {
                const size = POLLY_HELPER_SIZE;
                const x = getRandom(0, WIDTH - size);
                pollyHelper = new PollyHelper(x, size);
                fishList.push(pollyHelper);
              }
              fishList.splice(i, 1);
              continue;
            }
            /* --- sushi pickup --- */
            if (e.isSushi) {
              score += 50;
              sushiPowerUpTime = SUSHI_DURATION;
              playPowerUpSound();
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });
              fishList.splice(i, 1);
              continue;
            }

            /* --- borgy pickup --- */
            if (e.isBorgy) {
              score += 75;
              borgyPowerUpTime = BORGY_DURATION;
              playBorgyPowerUpSound();
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });
              fishList.splice(i, 1);
              continue;
            }

            if (e.isFrozen) {
              score += calculateFishScore(e.maxSide);

              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });

              // apply normal growth / side‑effects
              if (e.isJellyfish && !e.isElectric && borgyPowerUpTime <= 0) {
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }

              if (e.isElectric && borgyPowerUpTime <= 0) {
                // frozen electric still shocks!
                playerParalyzeTime = PARALYZE_DURATION;
                playShockSound();
              }

              player.width = player.height = null; // force dimension recalc
              fishList.splice(i, 1); // remove the enemy
              continue; // done with this entity
            }

            /* --- player is powered-up --- */
            if (playerIsPoweredUp) {
              score += calculateFishScore(e.maxSide);
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });

              if (e.isJellyfish && !e.isElectric && borgyPowerUpTime <= 0) {
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }

              if (e.isElectric && borgyPowerUpTime <= 0) {
                playerParalyzeTime = PARALYZE_DURATION;
                playShockSound();
              }

              player.width = player.height = null;
              // if (e.isUltraFast) {
              //   sushiPowerUpTime = SUSHI_DURATION;
              //   playPowerUpSound();
              // }
              fishList.splice(i, 1);
              continue;
            }

            /* --- no power-up, check size --- */
            const pR = player.getBounds().radiusX;
            const eR = e.getBounds().radiusX;
            if (pR * EATING_LEEWAY > eR) {
              /* player eats */
              score += calculateFishScore(e.maxSide);
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });

              if (e.isJellyfish && !e.isElectric) {
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }

              if (e.isElectric) {
                playerParalyzeTime = PARALYZE_DURATION;
                playShockSound();
              }

              player.width = player.height = null;
              // if (e.isUltraFast) {
              // sushiPowerUpTime = SUSHI_DURATION;
              // playPowerUpSound();
              // }
              fishList.splice(i, 1);
              continue;
            } else {
              /* player is eaten */
              isGameOver = true;
              touchTarget = null;
              joystick.active = false;
              gameState = "over";

              const eatenBy = e.spawnIdx ?? null;
              epochGameEndTime = Date.now();

              sendScoreToAPI(
                score,
                eatenEvents,
                currentSessionId,
                gameTimeMs,
                eatenBy,
                epochGameStartTime,
                epochGameEndTime
              );

              spawnExplosion(player);
              pendingGameOver = true;
              touchTarget = null;
              return;
            }
          }
        }

        /* Polly Helper collisions */
        if (pollyHelper) {
          for (let j = fishList.length - 1; j >= 0; j--) {
            const e = fishList[j];
            if (e === pollyHelper || e.isPlayer || e.isPollyHelper) continue;
            if (checkCollisionOval(pollyHelper, e)) {
              // Award points based on creature type (same logic as player eating)
              if (e.isSushi) {
                score += 50;
              } else if (e.isBorgy) {
                score += 75;
              } else if (e.isPolly) {
                score += 75;
              } else {
                score += calculateFishScore(e.maxSide);
              }
              eatenEvents.push({
                t: gameTimeMs,
                idx: e.spawnIdx,
                type: e.spawnType,
                size: e.maxSide,
                ultra: !!e.isUltraFast,
              });
              if (!(e.isJellyfish && !e.isElectric) && !e.isElectric) {
                player.maxSide += Math.min(
                  Math.sqrt(e.maxSide) * GROWTH_FACTOR,
                  GROWTH_CAP
                );
                playEatSound();
              }
              // if (e.isUltraFast) {
              //   sushiPowerUpTime = SUSHI_DURATION;
              //   playPowerUpSound();
              // }
              player.width = player.height = null;
              if (e.isBorgy) {
                // helper ate a Chippy
                borgyPowerUpTime = BORGY_DURATION;
                playBorgyPowerUpSound();
              } else if (e.isPolly) {
                // helper ate another Polly
                pollyFreezeTime = POLLY_DURATION;
                playPollyPowerUpSound();

                // re‑freeze (or keep frozen) all enemies
                fishList.forEach((f) => {
                  if (
                    !f.isPlayer &&
                    !f.isPolly &&
                    !f.isCrab &&
                    !f.isBorgy &&
                    !f.isPollyHelper &&
                    !f.isFrozen
                  ) {
                    f.isFrozen = true;
                    f.origSpeedX = f.speedX;
                    f.speedX = 0;
                    f.origSpeedY = f.speedY;
                    f.speedY = 0;
                    f.origSprite = f.sprite;

                    const frozen = new Image();
                    frozen.src = (f.baseSprite?.src ?? "").replace(
                      /\.png$/,
                      "-frozen.png"
                    );
                    frozen.onerror = () =>
                      (frozen.src = "img/fish-frozen-placeholder.png");
                    f.sprite = frozen;
                  }
                });
              }
              fishList.splice(j, 1);
            }
          }
        }

        if (score >= nextMilestone) {
          playAchvSound();
          resetRound();
          const diff = Math.floor((score - nextMilestone) / 100000) + 1;
          nextMilestone += diff * 100000;
        }
      }

      /*********************   RENDER LOOP & MASTER LOOP  *****************************/
      let cachedScoreText = "";
      function renderGame() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        bubbles.forEach((b) => b.draw(ctx));
        waterTrails.forEach((t) => t.draw(ctx));
        if (player && !(isGameOver && pendingGameOver)) player.draw(ctx);
        fishList.forEach((f) => f.draw(ctx));
        explosions.forEach((ex) => ex.draw(ctx));

        const scoreText = `Score: ${score}`;
        if (cachedScoreText !== scoreText) {
          cachedScoreText = scoreText;
        }
        ctx.fillStyle = playerParalyzeTime > 0 ? "#ffea00" : "#fff";
        ctx.font = "20px 'Londrina Solid', sans-serif";
        ctx.fillText(cachedScoreText, 20, 30);

        let y = 55;
        ctx.font = "16px 'Poppins', sans-serif";
        if (playerParalyzeTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `Paralyzed: ${playerParalyzeTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(40, 40, 0, 0.72)", // dark yellow
                textColor: "#ffea00",
                font: ctx.font,
              }
            ) + 4;
        }
        if (borgyPowerUpTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `Chippy Potion: ${borgyPowerUpTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(1, 60, 60, 0.72)", // dark teal
                textColor: "#03b0b0",
                font: ctx.font,
              }
            ) + 4;
        }
        if (sushiPowerUpTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `Power-Up: ${sushiPowerUpTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(30, 0, 20, 0.7)", // dark magenta
                textColor: "#ffaaff",
                font: ctx.font,
              }
            ) + 4;
        }

        if (pollyFreezeTime > 0) {
          y +=
            drawTextWithBg(
              ctx,
              `Freeze: ${pollyFreezeTime.toFixed(1)}s`,
              20,
              y,
              {
                bgColor: "rgba(0,40,80,0.72)",
                textColor: "#9cf",
                font: ctx.font,
              }
            ) + 4;
        }

        if (isJoystickEnabled && joystick.active) {
          ctx.save();
          ctx.globalAlpha = 0.4;
          ctx.fillStyle = "#ffffff22";
          ctx.beginPath();
          ctx.arc(
            joystick.baseX,
            joystick.baseY,
            joystick.radius,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.fillStyle = "#ffffff88";
          ctx.beginPath();
          ctx.arc(
            joystick.stickX,
            joystick.stickY,
            joystick.innerRadius,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.restore();
        }

        if (touchTarget && !isJoystickEnabled) {
          ctx.beginPath();
          ctx.arc(touchTarget.x, touchTarget.y, 15, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffffff88";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      /* ---- MASTER LOOP (update + render) ---- */
      let lastFrameTime = performance.now();
      let accumulator = 0;
      const FIXED_STEP = 1 / 60; // 60 FPS physics

      function masterLoop() {
        const now = performance.now();
        let dt = (now - lastFrameTime) / 1000;
        if (dt > 0.25) dt = 0.25;
        lastFrameTime = now;
        accumulator += dt;
        if (accumulator > FIXED_STEP * 5) {
          accumulator = FIXED_STEP * 5;
        }
        while (accumulator >= FIXED_STEP) {
          updateGame(FIXED_STEP);
          accumulator -= FIXED_STEP;
        }
        renderGame();
        requestAnimationFrame(masterLoop);
      }

      /*********************        INIT          *************************/
      function initGame() {
        resizeCanvas();
        score = 0;
        nextMilestone = 100000;
        gameTime = 0;
        gameTimeMs = 0;
        isGameOver = false;
        pendingGameOver = false;
        fishList = [];
        explosions = [];
        bubbles = [];
        waterTrails = [];
        player = new Fish(WIDTH / 2, HEIGHT / 2, 0, 0, playerImg, 25, true);
        sushiPowerUpTime = 0;
        borgyPowerUpTime = 0;
        playerIsPoweredUp = false;
        playerParalyzeTime = 0;
        pollyFreezeTime = 0;
        pollyHelper = null;
        clearKeys();
        joystick.active = false;
        spawnBubbleGroup();
        bubbleTimer = 0;
        updateMusicButtons();
        updateSfxButtons();
        updateJoystickButtons();
      }

      /*********************      UI EVENTS       *************************/
      const showOrHideArrowKeys = (show) => {
        controlsContainer.style.display = show ? "flex" : "none";
        const txt = show ? "🎮 Arrow Keys On" : "🎮 Arrow Keys Off";
        arrowKeysBtn.textContent = txt;
        arrowKeysBtnGameOver.textContent = txt;
        if (!show) clearKeys();
      };
      const syncGameOverUI = () => {
        showOrHideArrowKeys(controlsContainer.style.display !== "none");
        updateMusicButtons();
        updateSfxButtons();
        updateJoystickButtons();
      };

      /* ---- Start Game ---- */
      async function startNewRun() {
        if (!VALID_TEAMS.includes(userTeam)) {
          alert("Please pick a team first!");
          return;
        }

        if (startInProgress) return;
        startInProgress = true;
        startBtn.disabled = true;
        playAgainBtn.disabled = true;
        shareBtn.disabled = true;

        hideStartScreen();
        hideGameOverScreen();
        showOrHideArrowKeys(arrowKeysBtn.textContent.includes("On"));

        startAudio();

        let sessionInfo;
        try {
          const resp = await fetch("/api/session", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `tma ${initDataRaw}`,
              "x-api-password": getApiPassword(),
            },
          });
          sessionInfo = await resp.json();
        } catch (e) {
          alert("Cannot start game – session failed.");
          startInProgress = false;
          startBtn.disabled = false;
          playAgainBtn.disabled = false;
          window.location.reload();
          return;
        }

        rng = new Math.seedrandom(sessionInfo.seed);
        spawnSpecRng = new Math.seedrandom(sessionInfo.seed + ":spec");
        spawnTimingRng = new Math.seedrandom(sessionInfo.seed + ":timing");

        globalSpawnIdx = 0;

        spawnSchedule.length = 0;
        nextScheduleIdx = 0;
        scheduleCursorTime = 0;
        ensureScheduleAhead(120);

        currentSessionId = sessionInfo.sessionId;
        eatenEvents.length = 0;

        gameState = "playing";
        epochGameStartTime = Date.now();
        epochGameEndTime = null;

        initGame();
        startInProgress = false;
      }

      startBtn.onclick = startNewRun;
      playAgainBtn.onclick = startNewRun;

      musicBtn.onclick = toggleMusic;
      musicBtnGameOver.onclick = toggleMusic;
      sfxBtn.onclick = toggleSFX;
      sfxBtnGameOver.onclick = toggleSFX;
      arrowKeysBtn.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");
      arrowKeysBtnGameOver.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");
      joystickBtn.onclick = toggleJoystick;
      joystickBtnGameOver.onclick = toggleJoystick;

      /* hardware keyboard */
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = true;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });

      /* touch / mouse aiming & joystick */
      canvas.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        if (!t) return;
        const r = canvas.getBoundingClientRect();
        if (isJoystickEnabled) {
          joystick.baseX = joystick.stickX = t.clientX - r.left;
          joystick.baseY = joystick.stickY = t.clientY - r.top;
          joystick.active = true;
          e.preventDefault();
        } else {
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchmove", (e) => {
        const t = e.touches[0];
        if (!t) return;
        const r = canvas.getBoundingClientRect();
        if (isJoystickEnabled && joystick.active) {
          const rawX = t.clientX - r.left;
          const rawY = t.clientY - r.top;
          const dx = rawX - joystick.baseX;
          const dy = rawY - joystick.baseY;
          const dist = Math.hypot(dx, dy);
          if (dist > joystick.radius) {
            const ratio = joystick.radius / dist;
            joystick.stickX = joystick.baseX + dx * ratio;
            joystick.stickY = joystick.baseY + dy * ratio;
          } else {
            joystick.stickX = rawX;
            joystick.stickY = rawY;
          }
          e.preventDefault();
        } else if (!isJoystickEnabled) {
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchend", () => {
        if (isJoystickEnabled) {
          joystick.active = false;
        } else {
          touchTarget = null;
        }
      });

      /* Mouse (desktop dev) */
      canvas.addEventListener("mousedown", (e) => {
        const r = canvas.getBoundingClientRect();
        if (isJoystickEnabled) {
          joystick.baseX = joystick.stickX = e.clientX - r.left;
          joystick.baseY = joystick.stickY = e.clientY - r.top;
          joystick.active = true;
        } else {
          touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
        }
      });
      canvas.addEventListener("mousemove", (e) => {
        const r = canvas.getBoundingClientRect();
        if (e.buttons > 0) {
          if (isJoystickEnabled && joystick.active) {
            const rawX = e.clientX - r.left;
            const rawY = e.clientY - r.top;
            const dx = rawX - joystick.baseX;
            const dy = rawY - joystick.baseY;
            const dist = Math.hypot(dx, dy);
            if (dist > joystick.radius) {
              const ratio = joystick.radius / dist;
              joystick.stickX = joystick.baseX + dx * ratio;
              joystick.stickY = joystick.baseY + dy * ratio;
            } else {
              joystick.stickX = rawX;
              joystick.stickY = rawY;
            }
          } else if (!isJoystickEnabled) {
            touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
          }
        }
      });
      canvas.addEventListener("mouseup", () => {
        if (isJoystickEnabled) {
          joystick.active = false;
        } else {
          touchTarget = null;
        }
      });

      /* safety: clear keys on blur */
      window.addEventListener("blur", () => {
        clearKeys();
        joystick.active = false;
        touchTarget = null;
      });
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          clearKeys();
          joystick.active = false;
          touchTarget = null;
        }
      });

      // ─── TEAM‑SELECT HANDLERS ─────────────────────────────────────
      teamScreen.addEventListener("click", async (e) => {
        const btn = e.target.closest(".teamBtn");
        if (!btn) return;

        const chosen = btn.dataset.team;
        if (!VALID_TEAMS.includes(chosen)) return;

        btn.disabled = true; // optimistic UX
        try {
          // Only one chance – backend should reject changes later
          const resp = await fetch("/api/score/team", {
            method: "POST", // or PUT – match your API
            headers: {
              "Content-Type": "application/json",
              Authorization: `tma ${initDataRaw}`,
              "x-api-password": getApiPassword(),
            },
            body: JSON.stringify({ team: chosen }),
          });
          if (!resp.ok) throw new Error(await resp.text());
          userTeam = chosen;
          teamScreen.classList.add("hidden");
          showStartScreen();
        } catch (err) {
          console.error(err);
          alert("Couldn’t save team – try again?");
          btn.disabled = false;
        }
      });
      // ───────────────────────────────────────────────────────────────

      /*********************    PRELOAD & BOOT     **************************/
      Promise.all([
        loadImage("img/player_fish-5.png"),
        // These are optional - game will fall back to filters if they don't exist
        new Promise((resolve) => {
          playerPoweredUpImg.onload = resolve;
          playerPoweredUpImg.onerror = resolve;
        }),
        new Promise((resolve) => {
          playerParalyzedImg.onload = resolve;
          playerParalyzedImg.onerror = resolve;
        }),
        new Promise((resolve) => {
          playerBorgyImg.onload = resolve;
          playerBorgyImg.onerror = resolve;
        }),
        new Promise((resolve) => {
          playerPollyImg.onload = resolve;
          playerPollyImg.onerror = resolve;
        }),
        ...fishTypes.map(
          ({ image }) =>
            new Promise((resolve) => {
              if (image.complete) return resolve();
              image.addEventListener("load", resolve, { once: true });
              image.addEventListener("error", resolve, { once: true });
            })
        ),
        loadImage("img/crab-5.png"),
        loadImage("img/jellyfish-5.png"),
        loadImage("img/electric-jellyfish-5.png"),
        loadImage("img/sushi.png"),
        loadImage("img/chippy-5.png"),
        loadImage("img/pufferfish-5.png"),
        loadImage("img/chip-5.png"),
        loadImage("img/polly-5.png"),
        loadImage("img/polly-helper.png"),
      ]).then(() => {
        resizeCanvas();
        (async function initialiseTeam() {
          try {
            const scoreResp = await fetch("/api/score", {
              method: "GET",
              headers: {
                Authorization: `tma ${initDataRaw}`,
                "x-api-password": getApiPassword(),
              },
            });
            if (!scoreResp.ok) throw new Error("score fetch failed");
            const scoreDoc = await scoreResp.json();
            userTeam = scoreDoc?.team ?? null;
          } catch (e) {
            console.error(e);
            userTeam = null; // fall back
          }

          /* NEW — dismiss the loader */
          document.getElementById("loadingScreen").classList.add("hidden");

          if (!VALID_TEAMS.includes(userTeam)) {
            teamScreen.classList.remove("hidden"); // show picker
          } else {
            showStartScreen(); // carry on
          }
        })();
        let audioStarted = false;
        function kickAudio() {
          if (!audioStarted) {
            startAudio();
            audioStarted = true;
          }
        }
        startScreen.addEventListener("click", kickAudio, { once: true });
        document.addEventListener("mousemove", kickAudio, { once: true });
        requestAnimationFrame(masterLoop);
      });
    </script>
  </body>
</html>
