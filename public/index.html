<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <title>Nomu: Eat or Get Eaten</title>

    <!-- Fonts -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Londrina+Solid&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Audio -->
    <audio id="backgroundMusic" loop>
      <source src="sounds/background.mp3" type="audio/mpeg" />
    </audio>
    <audio id="eatSound">
      <source src="sounds/eat.mp3" type="audio/mpeg" />
    </audio>
    <audio id="gameOverSound">
      <source src="sounds/gameover.mp3" type="audio/mpeg" />
    </audio>
    <audio id="powerUpSound">
      <source src="sounds/powerup.mp3" type="audio/mpeg" />
    </audio>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <style>
      /* 
     * 1) Make page a column flex so #gameWrapper can flex to fill 
     *    all available space if the arrow keys (#controlsContainer) are hidden.
     */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex; /* column flex container */
        flex-direction: column; /* top: game, bottom: arrow keys */
        background: #222;
        font-family: "Poppins", sans-serif;
      }

      /* 2) The main game wrapper flexes to fill leftover space. */
      #gameWrapper {
        flex: 1; /* fill vertical space */
        width: 100%;
        position: relative;
        overflow: hidden;
        background: #222 url("img/bg.jpg") center center no-repeat;
        background-size: cover;
        display: flex; /* so its child (#gameCanvas) can size to 100% */
      }

      /* 
     * 3) On bigger/wider screens, impose a phone-like aspect ratio and max width. 
     *    This snippet means: if the screen is at least 700px wide, 
     *    #gameWrapper itself is pinned to ~450px width with 9:16 ratio. 
     *    That ensures it looks phone-shaped on large desktops. 
     *    Adjust numbers as desired.
     */
      @media (min-width: 700px) {
        #gameWrapper {
          margin: 0 auto; /* center horizontally */
          max-width: 450px;
          aspect-ratio: 9 / 16; /* forces height to match phone ratio */
        }
      }

      /* 4) Canvas always fills its parent (#gameWrapper). */
      #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      /* 
     * 5) The arrow keys container is the second flex child in <body>, 
     *    so if it's visible, it occupies some bottom space. 
     *    If hidden (display: none), #gameWrapper gets all the space. 
     */
      #controlsContainer {
        width: 100%;
        display: none; /* toggled ON if user wants arrow keys */
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        background: #222; /* or any color you want for arrow keys region */
        box-sizing: border-box;
        padding: 0;
      }
      .controlsRow {
        display: flex;
        width: 100%;
        max-width: 450px; /* match the game‚Äôs max width if desired */
        margin: 0 auto;
      }
      .arrowBtn {
        flex: 1;
        background-color: #f78719;
        border: none;
        color: #fff;
        font-family: "Londrina Solid", sans-serif;
        font-size: 20px;
        margin: 1px;
        cursor: pointer;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 60px;
      }
      .arrowBtn:active {
        transform: scale(0.95);
      }

      /* Overlays (start / game over) */
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .hidden {
        display: none;
      }
      .overlay h1,
      .overlay button,
      .overlay p {
        color: #fff;
        margin: 8px;
      }
      .overlay button {
        font-size: 18px;
        font-weight: bold;
        color: #fff;
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 40px;
        background-color: #f78719;
        font-family: "Londrina Solid", sans-serif;
      }
      .overlay p {
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <!-- 
     Top region: the main game 
     (flex:1) so it can grow/shrink 
     depending on whether arrow keys are hidden or displayed
  -->
    <div id="gameWrapper">
      <canvas id="gameCanvas"></canvas>

      <!-- START SCREEN OVERLAY -->
      <div id="startScreen" class="overlay">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <img
            src="img/title.png"
            alt="Eat or Get Eaten"
            style="max-width: 50%; height: auto; padding: 12px"
          />
          <div
            id="telegramStatus"
            style="
              color: white;
              font-family: 'Poppins', sans-serif;
              margin-bottom: 24px;
            "
          ></div>

          <p style="font-size: 24px; font-weight: bold; letter-spacing: 1px">
            Rules
          </p>
          <p>
            Use the touch screen or arrow keys (‚Üë‚Üí‚Üì‚Üê) to control Nomu. Eat the
            smaller fish to grow. Don't let the bigger fish eat you!
          </p>
          <p>The larger the fish, the more points you get.</p>
          <p>Your high score is <span id="highScore">0</span>.</p>

          <!-- Controls row -->
          <div
            style="
              display: flex;
              gap: 0;
              margin-bottom: 12px;
              justify-content: center;
            "
          >
            <button id="soundBtn">üîä Sound On</button>
            <button id="arrowKeysBtn">üéÆ Arrow Keys Off</button>
          </div>

          <!-- START -->
          <button
            id="startBtn"
            style="font-size: 24px; padding: 12px 24px; margin-top: 12px"
          >
            Start Game
          </button>
        </div>
      </div>

      <!-- GAME OVER OVERLAY -->
      <div id="gameOverScreen" class="overlay hidden">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <h1
            style="font-family: 'Londrina Solid', sans-serif; font-size: 44px"
          >
            GAME OVER!
          </h1>
          <p id="finalScore"></p>

          <!-- Controls row -->
          <div
            style="
              display: flex;
              gap: 0;
              margin-bottom: 12px;
              justify-content: center;
            "
          >
            <button id="soundBtnGameOver">üîä Sound On</button>
            <button id="arrowKeysBtnGameOver">üéÆ Arrow Keys Off</button>
          </div>

          <button
            id="playAgainBtn"
            style="font-size: 24px; padding: 12px 24px; margin-top: 12px"
          >
            Play Again
          </button>
        </div>
      </div>
    </div>

    <!-- 
     Bottom region: arrow keys. 
     By default, display is none. If the user toggles them on, 
     we set #controlsContainer.style.display = "flex".
  -->
    <div id="controlsContainer">
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowUp">‚Üë</button>
      </div>
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowLeft">‚Üê</button>
        <button class="arrowBtn" id="arrowDown">‚Üì</button>
        <button class="arrowBtn" id="arrowRight">‚Üí</button>
      </div>
    </div>

    <script>
      /* TELEGRAM INIT */
      let tg;
      let userData;
      let userId;
      try {
        tg = window.Telegram.WebApp;
        userData = tg.initDataUnsafe?.user;
        userId = userData?.id;
        tg.expand();
        tg.setupBackButton(false);
        tg.setupMainButton(false);
        tg.setupSettingsButton(false);
        tg.setupClosingBehavior(false);
        tg.setupSwipeBehavior(false);
      } catch (error) {
        console.error("Telegram initialization error:", error);
      }

      const statusDiv = document.getElementById("telegramStatus");
      if (userId) {
        statusDiv.textContent = `Telegram connected ‚úì (User: ${
          userData?.username || userData?.first_name || "Anonymous"
        })`;
        statusDiv.style.color = "lightgreen";
      } else {
        statusDiv.textContent =
          "‚ö†Ô∏è Not tracking scores - Please access via Telegram bot";
        statusDiv.style.color = "red";
      }

      /* SCORE SUBMISSION */
      async function sendScoreToAPI(score) {
        if (!userId) return;
        try {
          const response = await fetch("/api/scores", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              userId,
              username:
                userData?.username || userData?.first_name || "Anonymous",
              score,
            }),
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to send score: ${errorText}`);
          }
          const result = await response.json();
          console.log("Score sent successfully:", result);
        } catch (error) {
          console.error("Error sending score:", error);
        }
      }

      /* CANVAS SETUP */
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      let WIDTH = 800;
      let HEIGHT = 600;
      function resizeCanvas() {
        // The canvas fills #gameWrapper (which has an optional aspect ratio).
        // Just match clientWidth/clientHeight each time.
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        WIDTH = canvas.width;
        HEIGHT = canvas.height;
      }
      window.addEventListener("resize", resizeCanvas);

      /* OVERLAYS */
      const startScreen = document.getElementById("startScreen");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const startBtn = document.getElementById("startBtn");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const finalScoreElem = document.getElementById("finalScore");

      function showStartScreen() {
        startScreen.classList.remove("hidden");
      }
      function hideStartScreen() {
        startScreen.classList.add("hidden");
      }
      function showGameOverScreen(score) {
        finalScoreElem.textContent = `Your Score: ${score}`;
        gameOverScreen.classList.remove("hidden");
        playGameOverSound();
        syncGameOverUI();
      }
      function hideGameOverScreen() {
        gameOverScreen.classList.add("hidden");
      }

      let gameState = "start";
      let isGameOver = false;

      /* FISH DEFINITIONS */
      const fishTypeDefinitions = [
        { src: "img/fish1.png", minSize: 10, maxSize: 40, weight: 0.43 },
        { src: "img/fish2.png", minSize: 20, maxSize: 60, weight: 0.25 },
        { src: "img/fish3.png", minSize: 25, maxSize: 80, weight: 0.2 },
        { src: "img/fish4.png", minSize: 35, maxSize: 100, weight: 0.1 },
        { src: "img/fish6.png", minSize: 200, maxSize: 300, weight: 0.015 },
        { src: "img/fish5.png", minSize: 400, maxSize: 500, weight: 0.005 },
      ];

      /* PRELOAD IMAGES */
      const fishTypes = fishTypeDefinitions.map((def) => {
        const image = new Image();
        image.src = def.src;
        return {
          image,
          minSize: def.minSize,
          maxSize: def.maxSize,
          weight: def.weight,
        };
      });
      const playerImg = new Image();
      playerImg.src = "img/player_fish.png";
      const crabImg = new Image();
      crabImg.src = "img/crab.png";
      const jellyfishImg = new Image();
      jellyfishImg.src = "img/jellyfish.png";

      /* GAME VARIABLES */
      let fishList = [];
      let score = 0;
      let player;
      let touchTarget = null;
      const keys = { left: false, right: false, up: false, down: false };
      let bubbles = [];
      let waterTrails = [];
      let backgroundMusic;
      let eatSound;
      let gameOverSound;
      let powerUpSound;
      let isSoundEnabled = true;
      let explosion = null;

      /* POWER-UP */
      let playerPowerUpTime = 0;
      const POWER_UP_DURATION = 10;
      let playerIsPoweredUp = false;

      /* DOM CONTROLS */
      const soundBtn = document.getElementById("soundBtn");
      const arrowKeysBtn = document.getElementById("arrowKeysBtn");
      const controlsContainer = document.getElementById("controlsContainer");
      const arrowUp = document.getElementById("arrowUp");
      const arrowDown = document.getElementById("arrowDown");
      const arrowLeft = document.getElementById("arrowLeft");
      const arrowRight = document.getElementById("arrowRight");

      const soundBtnGameOver = document.getElementById("soundBtnGameOver");
      const arrowKeysBtnGameOver = document.getElementById(
        "arrowKeysBtnGameOver"
      );

      /* AUDIO SETUP */
      function initAudio() {
        backgroundMusic = document.getElementById("backgroundMusic");
        eatSound = document.getElementById("eatSound");
        gameOverSound = document.getElementById("gameOverSound");
        powerUpSound = document.getElementById("powerUpSound");
        backgroundMusic.volume = 0.05;
        eatSound.volume = 0.3;
        gameOverSound.volume = 0.3;
        powerUpSound.volume = 0.3;
      }
      function startAudio() {
        if (backgroundMusic && isSoundEnabled) {
          try {
            backgroundMusic.play();
          } catch (error) {
            console.log("Audio playback failed:", error);
          }
        }
      }
      function toggleSound() {
        isSoundEnabled = !isSoundEnabled;
        if (backgroundMusic) {
          if (isSoundEnabled) {
            startAudio();
            backgroundMusic.volume = 0.3;
            eatSound.volume = 0.5;
            gameOverSound.volume = 0.5;
          } else {
            backgroundMusic.pause();
            backgroundMusic.volume = 0;
            eatSound.volume = 0;
            gameOverSound.volume = 0;
          }
        }
        soundBtn.textContent = isSoundEnabled ? "üîä Sound On" : "üîà Sound Off";
      }
      function toggleSoundGameOver() {
        toggleSound();
        soundBtnGameOver.textContent = isSoundEnabled
          ? "üîä Sound On"
          : "üîà Sound Off";
      }
      function playEatSound() {
        if (!isSoundEnabled) return;
        eatSound.currentTime = 0;
        eatSound.play().catch(() => {});
      }
      function playGameOverSound() {
        if (!isSoundEnabled) return;
        gameOverSound.currentTime = 0;
        gameOverSound.play().catch(() => {});
      }
      function playPowerUpSound() {
        if (!isSoundEnabled) return;
        powerUpSound.currentTime = 0;
        powerUpSound.play().catch(() => {});
      }

      /* UTILITY */
      function getRandom(min, max) {
        return Math.random() * (max - min) + min;
      }
      function calculateFishScore(fishSize) {
        return Math.floor(fishSize);
      }
      function getRandomWeightedFishType(fishTypes) {
        const totalWeight = fishTypes.reduce((sum, ft) => sum + ft.weight, 0);
        let randomVal = Math.random() * totalWeight;
        for (const ft of fishTypes) {
          if (randomVal < ft.weight) return ft;
          randomVal -= ft.weight;
        }
        return fishTypes[fishTypes.length - 1];
      }

      /* CLASSES (Fish, Crab, Jellyfish, Bubble, Explosion) */
      class WaterTrail {
        constructor(x, y, direction, fishSize, isUltraFast = false) {
          this.x = x;
          this.y = y;
          const baseSize = Math.min(8, Math.max(2, fishSize * 0.1));
          this.size = getRandom(baseSize * 0.8, baseSize * 1.2);
          this.life = 1.0;
          this.fadeSpeed = getRandom(0.02, 0.04);
          this.direction = direction;
          const offsetScale = Math.min(3, Math.max(1, fishSize * 0.03));
          this.offsetX = getRandom(-offsetScale, offsetScale);
          this.offsetY = getRandom(-offsetScale, offsetScale);
          this.isUltraFast = isUltraFast;
          this.hue = Math.random() * 360;
          this.hueSpeed = getRandom(2, 4);
        }
        update(deltaTime) {
          this.life -= this.fadeSpeed * deltaTime * 60;
          this.x += this.direction * 0.5 * deltaTime * 60;
          if (this.isUltraFast) {
            this.hue = (this.hue + this.hueSpeed) % 360;
          }
        }
        draw(ctx) {
          if (this.life <= 0) return;
          ctx.beginPath();
          ctx.arc(
            this.x + this.offsetX,
            this.y + this.offsetY,
            this.size,
            0,
            Math.PI * 2
          );
          if (this.isUltraFast) {
            ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, ${this.life * 0.3})`;
            ctx.shadowBlur = 10;
            ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, ${
              this.life * 0.3
            })`;
          } else {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.05})`;
          }
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      class Fish {
        constructor(x, y, speedX, speedY, sprite, maxSide, isPlayer = false) {
          this.x = x;
          this.y = y;
          this.speedX = speedX;
          this.speedY = speedY;
          this.sprite = sprite;
          this.maxSide = maxSide;
          this.isPlayer = isPlayer;
          this.lastTrailTime = 0;
          this.isFast = false;
          this.isUltraFast = false;
          this.isCrab = false;
          this.isJellyfish = false;

          if (!isPlayer) {
            this.oscillationSpeed = getRandom(0.005, 0.01);
            this.oscillationAmount = getRandom(0.05, 0.1);
            this.oscillationOffset = getRandom(0, Math.PI * 2);
            this.acceleration = 0.05;
            this.maxSpeed = Math.abs(speedX) * 1.2;
          } else {
            this.velocityX = 0;
            this.velocityY = 0;
            this.acceleration = 0.055;
            this.friction = 0.99;
            this.maxSpeed = 10;
          }
          this.width = null;
          this.height = null;
        }
        calculateDimensions() {
          const w = this.sprite.naturalWidth;
          const h = this.sprite.naturalHeight;
          if (w === 0 || h === 0) {
            this.width = this.maxSide;
            this.height = this.maxSide;
            return;
          }
          const aspect = w / h;
          if (aspect > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / aspect;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * aspect;
          }
        }
        draw(ctx) {
          if (!this.sprite.complete) return;
          if (this.width === null || this.height === null) {
            this.calculateDimensions();
          }
          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;
          const applyUltraFastFilter =
            this.isUltraFast || (this.isPlayer && playerIsPoweredUp);

          ctx.save();
          if (isMovingLeft) {
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(-1, 1);
            ctx.translate(-this.width / 2, -this.height / 2);
          } else {
            ctx.translate(this.x, this.y);
          }
          if (applyUltraFastFilter) {
            ctx.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
          } else if (this.isFast) {
            ctx.filter = "hue-rotate(45deg) brightness(1.2)";
          }
          ctx.drawImage(this.sprite, 0, 0, this.width, this.height);
          ctx.restore();
        }
        getBounds() {
          const collisionScale = 0.6;
          const radiusX = ((this.width || 0) * collisionScale) / 2;
          const radiusY = ((this.height || 0) * collisionScale) / 2;
          let centerX = this.x + (this.width || 0) / 2;
          let centerY = this.y + (this.height || 0) / 2;
          const shiftAmount = (this.width || 0) * 0.07;
          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;
          if (isMovingLeft) centerX -= shiftAmount;
          else centerX += shiftAmount;
          return { centerX, centerY, radiusX, radiusY };
        }
        update(deltaTime) {
          const deltaFrames = deltaTime * 60;
          if (this.isPlayer) {
            const frictionFactor = Math.pow(this.friction, deltaFrames);
            this.velocityX *= frictionFactor;
            this.velocityY *= frictionFactor;
            this.x += this.velocityX * deltaFrames;
            this.y += this.velocityY * deltaFrames;

            if (this.width && this.height) {
              if (this.x < 0) {
                this.x = 0;
                this.velocityX = 0;
              }
              if (this.y < 0) {
                this.y = 0;
                this.velocityY = 0;
              }
              if (this.x + this.width > WIDTH) {
                this.x = WIDTH - this.width;
                this.velocityX = 0;
              }
              if (this.y + this.height > HEIGHT) {
                this.y = HEIGHT - this.height;
                this.velocityY = 0;
              }
            }
          } else {
            const oscillation =
              Math.sin(
                performance.now() * this.oscillationSpeed +
                  this.oscillationOffset
              ) * this.oscillationAmount;
            if (!this.isJellyfish && !this.isCrab) {
              if (Math.abs(this.speedX) < this.maxSpeed) {
                this.speedX +=
                  this.acceleration * Math.sign(this.speedX) * deltaFrames;
              }
              this.x += this.speedX * deltaFrames;
              this.y += oscillation * deltaFrames;
            }
          }
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 50) return;
          this.lastTrailTime = now;

          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;
          const speed = this.isPlayer
            ? Math.sqrt(this.velocityX ** 2 + this.velocityY ** 2)
            : Math.abs(this.speedX);
          if (speed > 0.5) {
            const ultra =
              this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
            const count = ultra ? 3 : Math.random() < 0.3 ? 2 : 1;
            for (let i = 0; i < count; i++) {
              waterTrails.push(
                new WaterTrail(
                  this.x + (isMovingLeft ? this.width : 0),
                  this.y + this.height * 0.5,
                  isMovingLeft ? 1 : -1,
                  this.maxSide,
                  ultra
                )
              );
            }
          }
        }
      }

      class Crab extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, 0, crabImg, size, false);
          this.isCrab = true;
          this.hasEnteredScreen = false;
          this.timeAlive = 0;
        }
        update(deltaTime, player) {
          const deltaFrames = deltaTime * 60;
          if (!this.hasEnteredScreen) {
            this.y -= 2 * deltaFrames;
            if (this.y + this.height <= HEIGHT) {
              this.hasEnteredScreen = true;
            }
            return;
          }
          this.timeAlive += deltaTime;
          if (this.timeAlive > 15) {
            spawnExplosion(this);
            this.maxSide = 0;
            return;
          }
          const crabRadius = this.getBounds().radiusX;
          const playerRadius = player.getBounds().radiusX;
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const speedFactor = 1.5;
          if (crabRadius > playerRadius) {
            this.x += (dx / dist) * (speedFactor * deltaFrames);
            this.y += (dy / dist) * (speedFactor * deltaFrames);
          } else {
            this.x -= (dx / dist) * (speedFactor * deltaFrames);
            this.y -= (dy / dist) * (speedFactor * deltaFrames);
          }
          if (this.width && this.height) {
            if (this.x < 0) this.x = 0;
            if (this.y < 0) this.y = 0;
            if (this.x + this.width > WIDTH) this.x = WIDTH - this.width;
            if (this.y + this.height > HEIGHT) this.y = HEIGHT - this.height;
          }
        }
      }

      class Jellyfish extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, -1.2, jellyfishImg, size, false);
          this.isJellyfish = true;
          this.oscSpeed = getRandom(0.0008, 0.0015);
          this.oscAmplitude = getRandom(10, 15);
          this.oscOffset = Math.random() * Math.PI * 2;
          this.baseX = x;
          this.verticalSpeed = getRandom(0.5, 1.2);
        }
        update(deltaTime) {
          const deltaFrames = deltaTime * 60;
          this.y -= this.verticalSpeed * deltaFrames;
          const oscValue =
            Math.sin(performance.now() * this.oscSpeed + this.oscOffset) *
            this.oscAmplitude;
          this.x = this.baseX + oscValue;
          if (this.y + (this.height || 0) < -50) {
            this.maxSide = 0;
          }
        }
      }

      class Bubble {
        constructor(baseX) {
          this.reset(baseX);
        }
        reset(baseX) {
          this.x = baseX + getRandom(-10, 10);
          this.y = HEIGHT + 20;
          this.size = getRandom(3, 8);
          this.speed = getRandom(2, 3.5);
          this.opacity = getRandom(0.2, 0.4);
          this.wobbleAmount = getRandom(0.1, 0.3);
          this.wobbleSpeed = getRandom(0.02, 0.05);
          this.wobbleOffset = getRandom(0, Math.PI * 2);
        }
        update(deltaTime) {
          this.y -= this.speed * deltaTime * 60;
          this.x +=
            Math.sin(this.wobbleOffset + performance.now() * this.wobbleSpeed) *
            this.wobbleAmount *
            deltaTime *
            60;
          if (this.y < -20) {
            this.reset();
          }
        }
        draw(ctx) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.fill();
        }
      }

      class Explosion {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.particles = [];
          this.life = 1.0;
          this.fadeSpeed = 0.02;
          this.isComplete = false;

          const particleCount = Math.floor(size * 0.5);
          for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const speed = getRandom(2, 4);
            this.particles.push({
              x: 0,
              y: 0,
              speedX: Math.cos(angle) * speed,
              speedY: Math.sin(angle) * speed,
              size: getRandom(3, 8),
              life: 1.0,
              fadeSpeed: getRandom(0.01, 0.03),
            });
          }
        }
        update(deltaTime) {
          if (this.isComplete) return;
          this.life -= this.fadeSpeed * deltaTime * 60;
          for (const p of this.particles) {
            p.x += p.speedX * deltaTime * 60;
            p.y += p.speedY * deltaTime * 60;
            p.life -= p.fadeSpeed * deltaTime * 60;
          }
          if (this.life <= 0) {
            this.isComplete = true;
          }
        }
        draw(ctx) {
          if (this.life <= 0) return;
          for (const p of this.particles) {
            if (p.life <= 0) continue;
            ctx.beginPath();
            ctx.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${p.life * 0.8})`;
            ctx.fill();
          }
        }
      }

      /* SPAWN FUNCTIONS */
      function spawnExplosion(fish) {
        if (fish.width && fish.height) {
          explosion = new Explosion(
            fish.x + fish.width / 2,
            fish.y + fish.height / 2,
            fish.maxSide
          );
        }
      }
      function spawnFish() {
        const chosenType = getRandomWeightedFishType(fishTypes);
        const fishSize = getRandom(chosenType.minSize, chosenType.maxSize);
        const fromLeft = Math.random() < 0.5;
        const x = fromLeft ? -fishSize : WIDTH;
        const y = getRandom(0, HEIGHT - fishSize);

        const sizeFactor = 1 - fishSize / 500;
        const minSpeed = 0.3 + 0.5 * sizeFactor;
        const maxSpeed = 1.5 + 0.3 * sizeFactor;
        let baseSpeed = getRandom(minSpeed, maxSpeed);

        const isUltraFast = Math.random() < 0.01;
        const isFast = !isUltraFast && Math.random() < 0.03;

        if (isUltraFast) baseSpeed *= 5;
        else if (isFast) baseSpeed *= 3;

        const speedX = fromLeft ? baseSpeed : -baseSpeed;
        const enemy = new Fish(x, y, speedX, 0, chosenType.image, fishSize);
        enemy.isFast = isFast;
        enemy.isUltraFast = isUltraFast;
        fishList.push(enemy);
      }
      function spawnCrab() {
        const size = getRandom(50, 120);
        const x = getRandom(0, WIDTH - size);
        const y = HEIGHT + size;
        const crab = new Crab(x, y, size);
        fishList.push(crab);
      }
      function spawnJellyfish() {
        const size = getRandom(30, 120);
        const x = getRandom(0, WIDTH - size);
        const y = HEIGHT + size;
        const jelly = new Jellyfish(x, y, size);
        fishList.push(jelly);
      }
      function spawnBubbleGroup() {
        const groupSize = Math.floor(getRandom(3, 5));
        const baseX = getRandom(50, WIDTH - 50);
        for (let i = 0; i < groupSize; i++) {
          if (bubbles.length < 8) {
            bubbles.push(new Bubble(baseX));
          }
        }
      }

      /* GAME LOOP */
      function updateGame(deltaTime) {
        if (explosion) {
          explosion.update(deltaTime);
          if (explosion.isComplete) {
            explosion = null;
            if (isGameOver) {
              showGameOverScreen(score);
            }
          }
        }
        if (gameState !== "playing") return;
        if (isGameOver && !explosion) return;

        // power-up
        if (playerPowerUpTime > 0) {
          playerPowerUpTime -= deltaTime;
          if (playerPowerUpTime <= 0) {
            playerPowerUpTime = 0;
            playerIsPoweredUp = false;
          }
        }

        // bubbles
        for (const bubble of bubbles) {
          bubble.update(deltaTime);
        }
        // water trails
        for (let i = waterTrails.length - 1; i >= 0; i--) {
          const trail = waterTrails[i];
          trail.update(deltaTime);
          if (trail.life <= 0) waterTrails.splice(i, 1);
        }

        // occasionally spawn new bubbles
        if (Math.random() < 0.002 * deltaTime * 60 && bubbles.length < 5) {
          spawnBubbleGroup();
        }

        // player movement (keys)
        const accel = player.acceleration * deltaTime * 60;
        if (keys.left) player.velocityX -= accel;
        if (keys.right) player.velocityX += accel;
        if (keys.up) player.velocityY -= accel;
        if (keys.down) player.velocityY += accel;

        // touch/mouse
        if (touchTarget && player.width && player.height) {
          const px = player.x + player.width / 2;
          const py = player.y + player.height / 2;
          const dx = touchTarget.x - px;
          const dy = touchTarget.y - py;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 1) {
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;
            player.velocityX += ax;
            player.velocityY += ay;
          }
        }

        // limit speed
        const spd = Math.sqrt(player.velocityX ** 2 + player.velocityY ** 2);
        if (spd > player.maxSpeed) {
          const ratio = player.maxSpeed / spd;
          player.velocityX *= ratio;
          player.velocityY *= ratio;
        }

        // update player
        player.update(deltaTime);

        // update enemies
        for (let i = fishList.length - 1; i >= 0; i--) {
          const enemy = fishList[i];
          if (enemy.isCrab) {
            enemy.update(deltaTime, player);
            if (enemy.maxSide <= 0) {
              fishList.splice(i, 1);
              continue;
            }
          } else if (enemy.isJellyfish) {
            enemy.update(deltaTime);
            if (enemy.maxSide <= 0) {
              fishList.splice(i, 1);
              continue;
            }
          } else {
            enemy.update(deltaTime);
            const bounds = enemy.getBounds();
            if (
              bounds.centerX + bounds.radiusX < -200 ||
              bounds.centerX - bounds.radiusX > WIDTH + 200
            ) {
              fishList.splice(i, 1);
              continue;
            }
          }

          // collision with player
          if (checkCollisionOval(player, enemy)) {
            if (playerIsPoweredUp) {
              score += calculateFishScore(enemy.maxSide);
              player.maxSide += Math.min(Math.sqrt(enemy.maxSide) * 0.05, 1.5);
              player.width = null;
              player.height = null;
              playEatSound();
              if (enemy.isUltraFast) {
                playerPowerUpTime = POWER_UP_DURATION;
                playerIsPoweredUp = true;
                playPowerUpSound();
              }
              fishList.splice(i, 1);
            } else {
              const pR = player.getBounds().radiusX;
              const eR = enemy.getBounds().radiusX;
              if (pR > eR) {
                score += calculateFishScore(enemy.maxSide);
                player.maxSide += Math.min(
                  Math.sqrt(enemy.maxSide) * 0.05,
                  1.5
                );
                player.width = null;
                player.height = null;
                playEatSound();
                if (enemy.isUltraFast) {
                  playerPowerUpTime = POWER_UP_DURATION;
                  playerIsPoweredUp = true;
                  playPowerUpSound();
                }
                fishList.splice(i, 1);
              } else {
                isGameOver = true;
                gameState = "over";
                sendScoreToAPI(score);
                if (player.width && player.height) {
                  explosion = new Explosion(
                    player.x + player.width / 2,
                    player.y + player.height / 2,
                    player.maxSide
                  );
                }
                return;
              }
            }
          }
        }

        // spawn fish
        if (Math.random() < 0.03 * deltaTime * 60 && fishList.length < 30) {
          spawnFish();
        }
        // occasionally spawn crab
        if (Math.random() < 0.00005 * deltaTime * 60 && fishList.length < 30) {
          spawnCrab();
        }
        // occasionally spawn jellyfish
        if (Math.random() < 0.0001 * deltaTime * 60 && fishList.length < 30) {
          spawnJellyfish();
        }
      }

      function checkCollisionOval(a, b) {
        const A = a.getBounds();
        const B = b.getBounds();
        const dx = A.centerX - B.centerX;
        const dy = A.centerY - B.centerY;
        const sumRadiiX = A.radiusX + B.radiusX;
        const sumRadiiY = A.radiusY + B.radiusY;
        return (
          (dx * dx) / (sumRadiiX * sumRadiiX) +
            (dy * dy) / (sumRadiiY * sumRadiiY) <=
          1
        );
      }

      function renderGame() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        // bubbles
        for (const bubble of bubbles) {
          bubble.draw(ctx);
        }
        // trails
        for (const trail of waterTrails) {
          trail.draw(ctx);
        }

        // player
        if (player && !(isGameOver && explosion)) {
          player.draw(ctx);
        }
        // enemies
        for (const fish of fishList) {
          fish.draw(ctx);
        }
        // explosion
        if (explosion) {
          explosion.draw(ctx);
        }

        // score
        ctx.fillStyle = "#fff";
        ctx.font = "20px Londrina Solid, sans-serif";
        ctx.fillText("Score: " + score, 20, 30);

        // touch indicator
        if (touchTarget) {
          ctx.beginPath();
          ctx.arc(touchTarget.x, touchTarget.y, 15, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffffff88";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      /* GAME LOOP */
      let lastTime = 0;
      function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        updateGame(deltaTime);
        renderGame();
        requestAnimationFrame(gameLoop);
      }

      /* INIT LOGIC */
      function initGame() {
        resizeCanvas();
        score = 0;
        isGameOver = false;
        fishList = [];
        bubbles = [];
        waterTrails = [];
        player = new Fish(WIDTH / 2, HEIGHT / 2, 0, 0, playerImg, 25, true);

        playerPowerUpTime = 0;
        playerIsPoweredUp = false;

        initAudio();
        for (let i = 0; i < 3; i++) {
          spawnFish();
        }
        spawnBubbleGroup();
      }

      // Show/hide the on-screen arrow keys at the bottom
      function showOrHideArrowKeys(shouldShow) {
        controlsContainer.style.display = shouldShow ? "flex" : "none";
        arrowKeysBtn.textContent = shouldShow
          ? "üéÆ Arrow Keys On"
          : "üéÆ Arrow Keys Off";
        if (arrowKeysBtnGameOver) {
          arrowKeysBtnGameOver.textContent = shouldShow
            ? "üéÆ Arrow Keys On"
            : "üéÆ Arrow Keys Off";
        }
      }

      function syncGameOverUI() {
        // Reflect whether the arrow keys are currently visible
        const isCurrentlyVisible = controlsContainer.style.display !== "none";
        showOrHideArrowKeys(isCurrentlyVisible);
        // Sound
        soundBtnGameOver.textContent = isSoundEnabled
          ? "üîä Sound On"
          : "üîà Sound Off";
      }

      /* EVENT HANDLERS */
      startBtn.onclick = () => {
        hideStartScreen();
        showOrHideArrowKeys(arrowKeysBtn.textContent.includes("On"));
        gameState = "playing";
        initGame();
      };

      playAgainBtn.onclick = () => {
        hideGameOverScreen();
        showOrHideArrowKeys(arrowKeysBtnGameOver.textContent.includes("On"));
        gameState = "playing";
        initGame();
      };

      // Start screen: Toggle sound
      soundBtn.onclick = () => {
        toggleSound();
      };

      // Start screen: Toggle arrow keys
      arrowKeysBtn.onclick = () => {
        const currentlyVisible = controlsContainer.style.display !== "none";
        showOrHideArrowKeys(!currentlyVisible);
      };

      // Game Over: Toggle sound
      soundBtnGameOver.onclick = () => {
        toggleSoundGameOver();
      };

      // Game Over: Toggle arrow keys
      arrowKeysBtnGameOver.onclick = () => {
        const currentlyVisible = controlsContainer.style.display !== "none";
        showOrHideArrowKeys(!currentlyVisible);
      };

      // On-screen arrow buttons
      function pressKey(key, isDown) {
        if (key === "left") keys.left = isDown;
        if (key === "right") keys.right = isDown;
        if (key === "up") keys.up = isDown;
        if (key === "down") keys.down = isDown;
      }
      arrowUp.addEventListener("mousedown", () => pressKey("up", true));
      arrowUp.addEventListener("mouseup", () => pressKey("up", false));
      arrowUp.addEventListener("touchstart", () => pressKey("up", true));
      arrowUp.addEventListener("touchend", () => pressKey("up", false));

      arrowDown.addEventListener("mousedown", () => pressKey("down", true));
      arrowDown.addEventListener("mouseup", () => pressKey("down", false));
      arrowDown.addEventListener("touchstart", () => pressKey("down", true));
      arrowDown.addEventListener("touchend", () => pressKey("down", false));

      arrowLeft.addEventListener("mousedown", () => pressKey("left", true));
      arrowLeft.addEventListener("mouseup", () => pressKey("left", false));
      arrowLeft.addEventListener("touchstart", () => pressKey("left", true));
      arrowLeft.addEventListener("touchend", () => pressKey("left", false));

      arrowRight.addEventListener("mousedown", () => pressKey("right", true));
      arrowRight.addEventListener("mouseup", () => pressKey("right", false));
      arrowRight.addEventListener("touchstart", () => pressKey("right", true));
      arrowRight.addEventListener("touchend", () => pressKey("right", false));

      // Keyboard events
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = true;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });

      // Touch / mouse for the canvas
      canvas.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        if (touch) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("touchmove", (e) => {
        const touch = e.touches[0];
        if (touch) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("touchend", () => {
        touchTarget = null;
      });
      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        touchTarget = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      });
      canvas.addEventListener("mousemove", (e) => {
        if (e.buttons > 0) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("mouseup", () => {
        touchTarget = null;
      });

      /* PRELOAD IMAGES THEN START */
      Promise.all([
        new Promise((resolve) => (playerImg.onload = resolve)),
        ...fishTypes.map(
          ({ image }) => new Promise((resolve) => (image.onload = resolve))
        ),
        new Promise((resolve) => (crabImg.onload = resolve)),
        new Promise((resolve) => (jellyfishImg.onload = resolve)),
      ]).then(() => {
        resizeCanvas();
        showStartScreen();
        initAudio();

        // Start music on first interaction
        startScreen.addEventListener("click", function firstInteraction() {
          startAudio();
          startScreen.removeEventListener("click", firstInteraction);
        });
        document.addEventListener("mousemove", function firstInteraction() {
          startAudio();
          document.removeEventListener("mousemove", firstInteraction);
        });

        requestAnimationFrame(gameLoop);
      });
    </script>
  </body>
</html>
