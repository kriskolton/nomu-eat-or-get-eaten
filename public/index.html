<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <title>Nomu: Eat¬†or¬†Get¬†Eaten</title>

    <!-- Fonts -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Londrina+Solid&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Audio -->
    <audio id="backgroundMusic" loop>
      <source src="sounds/background2.mp3" type="audio/mpeg" />
    </audio>
    <audio id="eatSound">
      <source src="sounds/eat.mp3" type="audio/mpeg" />
    </audio>
    <audio id="gameOverSound">
      <source src="sounds/gameover.mp3" type="audio/mpeg" />
    </audio>
    <audio id="powerUpSound">
      <source src="sounds/powerup.mp3" type="audio/mpeg" />
    </audio>
    <audio id="achievementSound">
      <source src="sounds/achievement.mp3" type="audio/mpeg" />
    </audio>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <style>
      /* --- layout (unchanged) --- */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: #222;
        font-family: "Poppins", sans-serif;
      }
      #gameWrapper {
        flex: 1;
        width: 100%;
        position: relative;
        overflow: hidden;
        background: #222 url("img/bg2.png") center/cover no-repeat;
        display: flex;
        margin: 0 auto;
        max-width: 430px;
        max-height: 935px;
      }
      #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }
      #controlsContainer {
        width: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        background: #222;
      }
      .controlsRow {
        display: flex;
        width: 100%;
        max-width: 450px;
        margin: 0 auto;
      }
      .arrowBtn {
        flex: 1;
        background: #f78719;
        border: none;
        color: #fff;
        font-family: "Londrina Solid", sans-serif;
        font-size: 20px;
        margin: 1px;
        cursor: pointer;
        border-radius: 4px;
        height: 60px;
        user-select: none;
      }
      .arrowBtn:active {
        transform: scale(0.95);
      }
      .overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .hidden {
        display: none;
      }
      .overlay h1,
      .overlay button,
      .overlay p {
        color: #fff;
        margin: 8px;
      }
      .overlay button {
        font-size: 18px;
        font-weight: bold;
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 40px;
        background: #f78719;
        font-family: "Londrina Solid", sans-serif;
      }
      .overlay p {
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <!-- ---------- Top: main game ---------- -->
    <div id="gameWrapper">
      <canvas id="gameCanvas"></canvas>

      <!-- Start overlay -->
      <div id="startScreen" class="overlay">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <img
            src="img/title.png"
            alt="Eat or Get Eaten"
            style="
              max-width: 50%;
              height: auto;
              padding: 12px;
              padding-bottom: 0;
              margin-bottom: -8px;
              max-height: 30vh;
            "
          />
          <p
            style="
              font-size: 28px;
              color: #65c0f5;
              font-family: 'Londrina Solid', sans-serif;
              letter-spacing: 2px;
            "
          >
            SEASON¬†2
          </p>
          <p style="font-size: 12px; color: #fff; opacity: 0.5">v1.2</p>
          <div
            id="telegramStatus"
            style="
              color: white;
              font-family: 'Poppins', sans-serif;
              margin-bottom: 24px;
            "
          ></div>

          <p style="font-size: 24px; font-weight: bold; letter-spacing: 1px">
            Rules
          </p>
          <p>
            Use the touch screen or arrow keys (‚Üë‚Üí‚Üì‚Üê) to control Nomu. Eat the
            smaller fish to grow. Don't let the bigger fish eat you!
          </p>
          <p>The larger the fish, the more points you get.</p>

          <div
            style="
              display: flex;
              gap: 0;
              margin-bottom: 0;
              justify-content: center;
            "
          >
            <button id="soundBtn">üîä¬†Sound¬†On</button>
            <button id="arrowKeysBtn">üéÆ¬†Arrow¬†Keys¬†Off</button>
          </div>

          <button id="startBtn" style="font-size: 24px; padding: 12px 24px">
            Start¬†Game
          </button>
        </div>
      </div>

      <!-- Game‚Äëover overlay -->
      <div id="gameOverScreen" class="overlay hidden">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <h1
            style="font-family: 'Londrina Solid', sans-serif; font-size: 44px"
          >
            GAME¬†OVER!
          </h1>
          <p id="finalScore"></p>
          <div
            style="
              display: flex;
              gap: 0;
              margin-bottom: 12px;
              justify-content: center;
            "
          >
            <button id="soundBtnGameOver">üîä¬†Sound¬†On</button>
            <button id="arrowKeysBtnGameOver">üéÆ¬†Arrow¬†Keys¬†Off</button>
          </div>
          <button
            id="playAgainBtn"
            style="font-size: 24px; padding: 12px 24px; margin-top: 12px"
          >
            Play¬†Again
          </button>
        </div>
      </div>
    </div>

    <!-- ---------- Bottom: arrow keys ---------- -->
    <div id="controlsContainer">
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowUp">‚Üë</button>
      </div>
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowLeft">‚Üê</button>
        <button class="arrowBtn" id="arrowDown">‚Üì</button>
        <button class="arrowBtn" id="arrowRight">‚Üí</button>
      </div>
    </div>

    <script>
      /* --------------------------- CONSTANTS & INIT --------------------------- */
      window.API_PASSWORD = "10a619ef-ce0d-4da6-ada4-49ae4a11fb0d";

      /* Telegram */
      let tg, userData, userId;
      try {
        tg = window.Telegram.WebApp;
        userData = tg.initDataUnsafe?.user;
        userId = userData?.id;
        tg.expand();
        tg.ready();
        tg.setSwipeEnabled(false);
      } catch (e) {
        console.error("Telegram init error:", e);
      }
      const statusDiv = document.getElementById("telegramStatus");
      if (userId) {
        statusDiv.textContent = `Telegram connected ‚úì (User: ${
          userData?.username || userData?.first_name || "Anonymous"
        })`;
        statusDiv.style.color = "lightgreen";
      } else {
        statusDiv.textContent =
          "‚ö†Ô∏è¬†Not tracking scores¬†‚Äì open via Telegram bot";
        statusDiv.style.color = "red";
      }

      /* Arrow‚Äëkey fix */
      const keys = { left: false, right: false, up: false, down: false };
      function clearKeys() {
        keys.left = keys.right = keys.up = keys.down = false;
      }
      window.addEventListener("mouseup", clearKeys);
      window.addEventListener("touchend", clearKeys, { passive: true });
      window.addEventListener("touchcancel", clearKeys, { passive: true });

      /* Score submission */
      async function sendScoreToAPI(score) {
        if (!userId) return;
        try {
          await fetch("/api/scores", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-password": window.API_PASSWORD,
              "x-telegram-init-data": window.Telegram.WebApp.initData,
            },
            body: JSON.stringify({
              userId,
              username:
                userData?.username || userData?.first_name || "Anonymous",
              score,
              gameTime,
            }),
          });
        } catch (e) {
          console.error("Score send error:", e);
        }
      }

      /* Canvas */
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      let WIDTH = 800,
        HEIGHT = 600;
      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        WIDTH = canvas.width;
        HEIGHT = canvas.height;
        if (player && player.width && player.height) {
          player.x = Math.min(Math.max(0, player.x), WIDTH - player.width);
          player.y = Math.min(Math.max(0, player.y), HEIGHT - player.height);
        }
        [...fishList, ...bubbles].forEach((ent) => {
          if (ent.width && ent.height) {
            ent.x = Math.min(Math.max(0, ent.x), WIDTH - ent.width);
            ent.y = Math.min(Math.max(0, ent.y), HEIGHT - ent.height);
          }
        });
      }
      window.addEventListener("resize", resizeCanvas);

      /* Overlays / controls */
      const startScreen = document.getElementById("startScreen");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const startBtn = document.getElementById("startBtn");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const finalScoreElem = document.getElementById("finalScore");
      const soundBtn = document.getElementById("soundBtn");
      const arrowKeysBtn = document.getElementById("arrowKeysBtn");
      const soundBtnGameOver = document.getElementById("soundBtnGameOver");
      const arrowKeysBtnGameOver = document.getElementById(
        "arrowKeysBtnGameOver"
      );
      const controlsContainer = document.getElementById("controlsContainer");
      const arrowUp = document.getElementById("arrowUp");
      const arrowDown = document.getElementById("arrowDown");
      const arrowLeft = document.getElementById("arrowLeft");
      const arrowRight = document.getElementById("arrowRight");
      function showStartScreen() {
        startScreen.classList.remove("hidden");
      }
      function hideStartScreen() {
        startScreen.classList.add("hidden");
      }
      function showGameOverScreen(score) {
        finalScoreElem.textContent = `Your¬†Score:¬†${score}`;
        gameOverScreen.classList.remove("hidden");
        playGameOverSound();
        syncGameOverUI();
      }
      function hideGameOverScreen() {
        gameOverScreen.classList.add("hidden");
      }
      let gameState = "start",
        isGameOver = false;

      /* --------------------------- IMAGES & SPRITES --------------------------- */
      const fishTypeDefinitions = [
        { src: "img/fish1.png", minSize: 10, maxSize: 40, weight: 0.43 },
        { src: "img/fish2.png", minSize: 20, maxSize: 60, weight: 0.25 },
        { src: "img/fish10.png", minSize: 25, maxSize: 80, weight: 0.2 },
        { src: "img/fish7.png", minSize: 35, maxSize: 100, weight: 0.1 },
        { src: "img/fish9.png", minSize: 200, maxSize: 300, weight: 0.015 },
        { src: "img/fish8.png", minSize: 400, maxSize: 500, weight: 0.005 },
      ];

      const fishTypes = fishTypeDefinitions.map((def) => {
        const image = new Image();
        image.src = def.src;
        return {
          image,
          minSize: def.minSize,
          maxSize: def.maxSize,
          weight: def.weight,
        };
      });

      const playerImg = new Image();
      playerImg.src = "img/player_fish.png";
      const crabImg = new Image();
      crabImg.src = "img/crab.png";
      const jellyfishImg = new Image();
      jellyfishImg.src = "img/jellyfish.png";

      /* --- NEW: sushi power‚Äëup sprite --- */
      const sushiImg = new Image();
      sushiImg.src = "img/sushi.png";

      /* --------------------------- GAME VARIABLES --------------------------- */
      let fishList = [],
        score = 0,
        nextMilestone = 100000,
        player,
        touchTarget = null;
      let bubbles = [],
        waterTrails = [],
        backgroundMusic,
        eatSound,
        gameOverSound,
        powerUpSound,
        achievementSound,
        isSoundEnabled = true,
        explosion = null;
      let gameStartTime = 0,
        gameTime = 0;

      /* Tunables */
      const EATING_LEEWAY = 1.15;
      const JELLY_SHRINK_FACTOR = 0.6;
      let playerPowerUpTime = 0,
        playerIsPoweredUp = false;
      const POWER_UP_DURATION = 10;

      /* --------------------------- AUDIO --------------------------- */
      function initAudio() {
        backgroundMusic = document.getElementById("backgroundMusic");
        eatSound = document.getElementById("eatSound");
        gameOverSound = document.getElementById("gameOverSound");
        powerUpSound = document.getElementById("powerUpSound");
        achievementSound = document.getElementById("achievementSound");
        backgroundMusic.volume = 0.05;
        eatSound.volume = 0.3;
        gameOverSound.volume = 0.3;
        powerUpSound.volume = 0.3;
        achievementSound.volume = 0.3;
      }
      function startAudio() {
        if (backgroundMusic && isSoundEnabled)
          backgroundMusic.play().catch(() => {});
      }
      function updateSoundButtons() {
        const txt = isSoundEnabled ? "üîä¬†Sound¬†On" : "üîà¬†Sound¬†Off";
        soundBtn.textContent = txt;
        soundBtnGameOver.textContent = txt;
      }
      function toggleSound() {
        isSoundEnabled = !isSoundEnabled;
        if (backgroundMusic) {
          if (isSoundEnabled) {
            startAudio();
            backgroundMusic.volume = 0.3;
            eatSound.volume = 0.5;
            gameOverSound.volume = 0.5;
            powerUpSound.volume = 0.5;
            achievementSound.volume = 0.5;
          } else {
            backgroundMusic.pause();
            backgroundMusic.volume = 0;
            eatSound.volume = 0;
            gameOverSound.volume = 0;
            powerUpSound.volume = 0;
            achievementSound.volume = 0;
          }
        }
        updateSoundButtons();
      }
      const playEatSound = () => {
        if (isSoundEnabled) {
          eatSound.currentTime = 0;
          eatSound.play().catch(() => {});
        }
      };
      const playGameOverSound = () => {
        if (isSoundEnabled) {
          gameOverSound.currentTime = 0;
          gameOverSound.play().catch(() => {});
        }
      };
      const playPowerUpSound = () => {
        if (isSoundEnabled) {
          powerUpSound.currentTime = 0;
          powerUpSound.play().catch(() => {});
        }
      };
      const playAchvSound = () => {
        if (isSoundEnabled) {
          achievementSound.currentTime = 0;
          achievementSound.play().catch(() => {});
        }
      };

      /* --------------------------- HELPERS --------------------------- */
      function getRandom(min, max) {
        return Math.random() * (max - min) + min;
      }
      function calculateFishScore(sz) {
        return Math.floor(sz);
      }
      const totalFishWeight = fishTypes.reduce((s, f) => s + f.weight, 0);
      function getRandomWeightedFishType(arr) {
        let r = Math.random() * totalFishWeight;
        for (const ft of arr) {
          if (r < ft.weight) return ft;
          r -= ft.weight;
        }
        return arr[arr.length - 1];
      }

      /* --------------------------- CLASSES --------------------------- */
      class WaterTrail {
        constructor(x, y, dir, fishSize, isUltra = false) {
          (this.x = x),
            (this.y = y),
            (this.size = getRandom(
              Math.min(8, Math.max(2, fishSize * 0.1)) * 0.8,
              Math.min(8, Math.max(2, fishSize * 0.1)) * 1.2
            ));
          this.life = 1;
          this.fadeSpeed = getRandom(0.02, 0.04);
          this.dir = dir;
          this.offsetX = getRandom(-3, 3);
          this.offsetY = getRandom(-3, 3);
          this.isUltra = isUltra;
          this.hue = Math.random() * 360;
          this.hueSpeed = getRandom(2, 4);
        }
        update(dt) {
          this.life -= this.fadeSpeed * dt * 60;
          this.x += this.dir * 0.5 * dt * 60;
          if (this.isUltra) this.hue = (this.hue + this.hueSpeed) % 360;
        }
        draw(c) {
          if (this.life <= 0) return;
          c.beginPath();
          c.arc(
            this.x + this.offsetX,
            this.y + this.offsetY,
            this.size,
            0,
            Math.PI * 2
          );
          if (this.isUltra) {
            c.fillStyle = `hsla(${this.hue},100%,50%,${this.life * 0.3})`;
            c.shadowBlur = 10;
            c.shadowColor = `hsla(${this.hue},100%,50%,${this.life * 0.3})`;
          } else c.fillStyle = `rgba(255,255,255,${this.life * 0.05})`;
          c.fill();
          c.shadowBlur = 0;
        }
      }

      class Fish {
        constructor(x, y, sx, sy, img, maxSide, isPlayer = false) {
          this.x = x;
          this.y = y;
          this.speedX = sx;
          this.speedY = sy;
          this.sprite = img;
          this.maxSide = maxSide;
          this.isPlayer = isPlayer;
          this.lastTrailTime = 0;
          this.isFast = false;
          this.isUltraFast = false;
          this.isCrab = false;
          this.isJellyfish = false;
          this.isSushi = false;
          if (!isPlayer) {
            this.oscSpd = getRandom(0.005, 0.01);
            this.oscAmt = getRandom(0.05, 0.1);
            this.oscOff = getRandom(0, Math.PI * 2);
            this.accel = 0.05;
            this.maxSpd = Math.abs(sx) * 1.2;
          } else {
            this.vx = 0;
            this.vy = 0;
            this.accel = 0.055;
            this.friction = 0.99;
            this.maxSpd = 10;
          }
          this.width = null;
          this.height = null;
        }
        calculateDimensions() {
          const w = this.sprite.naturalWidth,
            h = this.sprite.naturalHeight;
          if (!w || !h) {
            this.width = this.height = this.maxSide;
            return;
          }
          const asp = w / h;
          if (asp > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / asp;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * asp;
          }
        }
        draw(c) {
          if (!this.sprite.complete) return;
          if (this.width === null || this.height === null)
            this.calculateDimensions();
          const movingLeft = this.isPlayer ? this.vx < 0 : this.speedX < 0;
          const ultra =
            this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
          c.save();
          if (movingLeft) {
            c.translate(this.x + this.width / 2, this.y + this.height / 2);
            c.scale(-1, 1);
            c.translate(-this.width / 2, -this.height / 2);
          } else c.translate(this.x, this.y);

          if (ultra)
            c.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
          else if (this.isFast) c.filter = "hue-rotate(45deg) brightness(1.2)";
          c.drawImage(this.sprite, 0, 0, this.width, this.height);
          c.restore();
        }
        getBounds() {
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          const scale = 0.6,
            rX = (this.width * scale) / 2,
            rY = (this.height * scale) / 2;
          let cX = this.x + this.width / 2,
            cY = this.y + this.height / 2;
          const shift = this.width * 0.07;
          const movingLeft = this.isPlayer ? this.vx < 0 : this.speedX < 0;
          if (movingLeft) cX -= shift;
          else cX += shift;
          return { centerX: cX, centerY: cY, radiusX: rX, radiusY: rY };
        }
        update(dt) {
          const df = dt * 60;
          if (this.isPlayer) {
            const f = Math.pow(this.friction, df);
            this.vx *= f;
            this.vy *= f;
            this.x += this.vx * df;
            this.y += this.vy * df;
            if (this.width && this.height) {
              if (this.x < 0) {
                this.x = 0;
                this.vx = 0;
              }
              if (this.y < 0) {
                this.y = 0;
                this.vy = 0;
              }
              if (this.x + this.width > WIDTH) {
                this.x = WIDTH - this.width;
                this.vx = 0;
              }
              if (this.y + this.height > HEIGHT) {
                this.y = HEIGHT - this.height;
                this.vy = 0;
              }
            }
          } else {
            const osc =
              Math.sin(performance.now() * this.oscSpd + this.oscOff) *
              this.oscAmt;
            if (!this.isJellyfish && !this.isCrab) {
              this.speedX +=
                this.accel *
                Math.sign(this.speedX) *
                df *
                (Math.abs(this.speedX) < this.maxSpd ? 1 : 0);
              if (Math.abs(this.speedX) > this.maxSpd)
                this.speedX = Math.sign(this.speedX) * this.maxSpd;
              this.x += this.speedX * df;
              this.y += osc * df;
            }
          }
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 50) return;
          this.lastTrailTime = now;
          const movingLeft = this.isPlayer ? this.vx < 0 : this.speedX < 0;
          const speed = this.isPlayer
            ? Math.hypot(this.vx, this.vy)
            : Math.abs(this.speedX);
          if (speed > 0.5) {
            const ultra =
              this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
            const count = ultra ? 3 : Math.random() < 0.3 ? 2 : 1;
            for (let i = 0; i < count; i++)
              waterTrails.push(
                new WaterTrail(
                  this.x + (movingLeft ? this.width : 0),
                  this.y + this.height * 0.5,
                  movingLeft ? 1 : -1,
                  this.maxSide,
                  ultra
                )
              );
          }
        }
      }

      class Crab extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, 0, crabImg, size, false);
          this.isCrab = true;
          this.entered = false;
          this.timeAlive = 0;
        }
        update(dt, player) {
          const df = dt * 60;
          if (!this.entered) {
            this.y -= 2 * df;
            if (this.y + this.height <= HEIGHT) this.entered = true;
            return;
          }
          this.timeAlive += dt;
          if (this.timeAlive > 15) {
            spawnExplosion(this);
            this.maxSide = 0;
            return;
          }
          const c = this.getBounds(),
            p = player.getBounds();
          const dx = p.centerX - c.centerX,
            dy = p.centerY - c.centerY,
            dist = Math.hypot(dx, dy) || 1;
          const s = 1.5;
          if (c.radiusX > p.radiusX) {
            this.x += (dx / dist) * s * df;
            this.y += (dy / dist) * s * df;
          } else {
            this.x -= (dx / dist) * s * df;
            this.y -= (dy / dist) * s * df;
          }
          if (this.width && this.height) {
            this.x = Math.min(Math.max(0, this.x), WIDTH - this.width);
            this.y = Math.min(Math.max(0, this.y), HEIGHT - this.height);
          }
        }
      }

      class Jellyfish extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, -1.2, jellyfishImg, size, false);
          this.isJellyfish = true;
          this.oscS = getRandom(0.0008, 0.0015);
          this.oscA = getRandom(10, 15);
          this.oscO = Math.random() * Math.PI * 2;
          this.baseX = x;
          this.vSpeed = getRandom(0.5, 1.2);
        }
        update(dt) {
          const df = dt * 60;
          this.y -= this.vSpeed * df;
          this.x =
            this.baseX +
            Math.sin(performance.now() * this.oscS + this.oscO) * this.oscA;
          if (this.y + this.height < -50) this.maxSide = 0;
        }
      }

      /* --- NEW: Sushi power‚Äëup (inherits Fish) --- */
      class Sushi extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, sushiImg, 30, false);
          this.isSushi = true;
        }
      }

      /* Bubbles & Explosion (unchanged) */
      class Bubble {
        constructor(baseX) {
          this.baseX = baseX;
          this.x = this.baseX + getRandom(-10, 10);
          this.y = HEIGHT + 20;
          this.size = getRandom(3, 8);
          this.speed = getRandom(2, 3.5);
          this.opacity = getRandom(0.2, 0.4);
          this.wobbleAmount = getRandom(0.1, 0.3);
          this.wobbleSpeed = getRandom(0.02, 0.05);
          this.wobbleOffset = getRandom(0, Math.PI * 2);
        }
        update(dt) {
          this.y -= this.speed * dt * 60;
          this.x +=
            Math.sin(this.wobbleOffset + performance.now() * this.wobbleSpeed) *
            this.wobbleAmount *
            dt *
            60;
        }
        draw(c) {
          c.beginPath();
          c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          c.fillStyle = `rgba(255,255,255,${this.opacity})`;
          c.fill();
        }
      }

      class Explosion {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.particles = [];
          this.life = 1;
          this.fadeSpeed = 0.02;
          this.isComplete = false;
          const n = Math.floor(size * 0.5);
          for (let i = 0; i < n; i++) {
            const angle = (i / n) * Math.PI * 2,
              spd = getRandom(2, 4);
            this.particles.push({
              x: 0,
              y: 0,
              sx: Math.cos(angle) * spd,
              sy: Math.sin(angle) * spd,
              size: getRandom(3, 8),
              life: 1,
              fadeSpeed: getRandom(0.01, 0.03),
            });
          }
        }
        update(dt) {
          if (this.isComplete) return;
          this.life -= this.fadeSpeed * dt * 60;
          for (const p of this.particles) {
            p.x += p.sx * dt * 60;
            p.y += p.sy * dt * 60;
            p.life -= p.fadeSpeed * dt * 60;
          }
          if (this.life <= 0) this.isComplete = true;
        }
        draw(c) {
          if (this.life <= 0) return;
          for (const p of this.particles) {
            if (p.life <= 0) continue;
            c.beginPath();
            c.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
            c.fillStyle = `rgba(255,255,255,${p.life * 0.8})`;
            c.fill();
          }
        }
      }

      /* --------------------------- SPAWNERS --------------------------- */
      function spawnExplosion(f) {
        if (f.width && f.height)
          explosion = new Explosion(
            f.x + f.width / 2,
            f.y + f.height / 2,
            f.maxSide
          );
      }

      function spawnFish() {
        const t = getRandomWeightedFishType(fishTypes);
        const size = getRandom(t.minSize, t.maxSize);
        const fromLeft = Math.random() < 0.5;
        const x = fromLeft ? -size : WIDTH,
          y = getRandom(0, HEIGHT - size);
        const sizeFactor = 1 - size / 500,
          minSpd = 0.3 + 0.5 * sizeFactor,
          maxSpd = 1.5 + 0.3 * sizeFactor;
        let spd = getRandom(minSpd, maxSpd);
        const ultra = Math.random() < 0.01,
          fast = !ultra && Math.random() < 0.03;
        if (ultra) spd *= 5;
        else if (fast) spd *= 3;
        const fish = new Fish(x, y, fromLeft ? spd : -spd, 0, t.image, size);
        fish.isFast = fast;
        fish.isUltraFast = ultra;
        fishList.push(fish);
      }
      function spawnCrab() {
        const size = getRandom(50, 120);
        const crab = new Crab(getRandom(0, WIDTH - size), HEIGHT + size, size);
        fishList.push(crab);
      }
      function spawnJellyfish() {
        const size = getRandom(30, 120);
        fishList.push(
          new Jellyfish(getRandom(0, WIDTH - size), HEIGHT + size, size)
        );
      }
      /* --- NEW: sushi spawner --- */
      function spawnSushi() {
        const size = 30,
          fromLeft = Math.random() < 0.5,
          x = fromLeft ? -size : WIDTH,
          y = getRandom(0, HEIGHT - size),
          spd = (fromLeft ? 1 : -1) * 1.5;
        fishList.push(new Sushi(x, y, spd));
      }

      /* Bubble groups */
      function spawnBubbleGroup() {
        const n = Math.floor(getRandom(3, 6)),
          baseX = getRandom(50, WIDTH - 50);
        for (let i = 0; i < n; i++) bubbles.push(new Bubble(baseX));
      }
      let bubbleTimer = 0;
      const BUBBLE_INTERVAL = 20;

      /* --------------------------- ROUND RESET --------------------------- */
      function resetRound() {
        fishList = [];
        bubbles = [];
        waterTrails = [];
        explosion = null;
        player.maxSide = 25;
        player.width = null;
        player.height = null;
        player.x = WIDTH / 2;
        player.y = HEIGHT / 2;
        player.vx = player.vy = 0;
        playerPowerUpTime = 0;
        playerIsPoweredUp = false;
        for (let i = 0; i < 3; i++) spawnFish();
        spawnBubbleGroup();
        bubbleTimer = 0;
      }

      /* --------------------------- GAME LOOP --------------------------- */
      function updateGame(dt) {
        if (explosion) {
          explosion.update(dt);
          if (explosion.isComplete) {
            explosion = null;
            if (isGameOver) showGameOverScreen(score);
          }
        }
        if (gameState !== "playing") return;
        if (isGameOver && !explosion) return;
        gameTime += dt;
        /* power‚Äëup timer */
        if (playerPowerUpTime > 0) {
          playerPowerUpTime -= dt;
          if (playerPowerUpTime <= 0) {
            playerPowerUpTime = 0;
            playerIsPoweredUp = false;
          }
        }

        /* bubbles */
        for (let i = bubbles.length - 1; i >= 0; i--) {
          bubbles[i].update(dt);
          if (bubbles[i].y < -20) bubbles.splice(i, 1);
        }

        /* trails */
        for (let i = waterTrails.length - 1; i >= 0; i--) {
          waterTrails[i].update(dt);
          if (waterTrails[i].life <= 0) waterTrails.splice(i, 1);
        }

        /* bubble wave */
        bubbleTimer += dt;
        if (bubbleTimer >= BUBBLE_INTERVAL) {
          spawnBubbleGroup();
          bubbleTimer = 0;
        }

        /* keyboard movement */
        const a = player.accel * dt * 60;
        if (keys.left) player.vx -= a;
        if (keys.right) player.vx += a;
        if (keys.up) player.vy -= a;
        if (keys.down) player.vy += a;

        /* touch target */
        if (touchTarget && player.width && player.height) {
          const px = player.x + player.width / 2,
            py = player.y + player.height / 2,
            dx = touchTarget.x - px,
            dy = touchTarget.y - py,
            dist = Math.hypot(dx, dy);
          if (dist > 1) {
            const ax = (dx / dist) * a,
              ay = (dy / dist) * a;
            player.vx += ax;
            player.vy += ay;
          }
        }

        /* speed cap */
        const spd = Math.hypot(player.vx, player.vy);
        if (spd > player.maxSpd) {
          const r = player.maxSpd / spd;
          player.vx *= r;
          player.vy *= r;
        }

        /* update player */
        player.update(dt);
        player.createWaterTrail();

        /* update enemies & collisions */
        for (let i = fishList.length - 1; i >= 0; i--) {
          const e = fishList[i];
          if (e.isCrab) e.update(dt, player);
          else e.update(dt);
          e.createWaterTrail();

          /* remove off‚Äëscreen/dead */
          const b = e.getBounds();
          if (
            e.maxSide <= 0 ||
            b.centerX + b.radiusX < -200 ||
            b.centerX - b.radiusX > WIDTH + 200 ||
            e.y > HEIGHT + 200
          ) {
            fishList.splice(i, 1);
            continue;
          }

          /* collision */
          if (checkCollisionOval(player, e)) {
            /* --- Sushi: always edible, grants power‚Äëup --- */
            if (e.isSushi) {
              score += 50;
              playerPowerUpTime = POWER_UP_DURATION;
              playerIsPoweredUp = true;
              playPowerUpSound();
              fishList.splice(i, 1);
              continue;
            }

            if (playerIsPoweredUp) {
              score += calculateFishScore(e.maxSide);
              if (e.isJellyfish)
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  10
                );
              else player.maxSide += Math.min(Math.sqrt(e.maxSide) * 0.05, 1.5);
              player.width = player.height = null;
              playEatSound();
              if (e.isUltraFast) {
                playerPowerUpTime = POWER_UP_DURATION;
                playerIsPoweredUp = true;
                playPowerUpSound();
              }
              fishList.splice(i, 1);
              continue;
            }

            const pR = player.getBounds().radiusX,
              eR = e.getBounds().radiusX;
            if (pR * EATING_LEEWAY > eR) {
              /* player eats */
              score += calculateFishScore(e.maxSide);
              if (e.isJellyfish)
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  10
                );
              else player.maxSide += Math.min(Math.sqrt(e.maxSide) * 0.05, 1.5);
              player.width = player.height = null;
              playEatSound();
              if (e.isUltraFast) {
                playerPowerUpTime = POWER_UP_DURATION;
                playerIsPoweredUp = true;
                playPowerUpSound();
              }
              fishList.splice(i, 1);
            } else {
              /* player gets eaten */
              isGameOver = true;
              gameState = "over";
              sendScoreToAPI(score);
              explosion = new Explosion(
                player.x + (player.width ?? player.maxSide) / 2,
                player.y + (player.height ?? player.maxSide) / 2,
                player.maxSide
              );
              touchTarget = null;
              return;
            }
          }
        }

        /* spawns */
        if (Math.random() < 0.03 * dt * 60 && fishList.length < 30) spawnFish();
        if (Math.random() < 0.00005 * dt * 60 && fishList.length < 30)
          spawnCrab();
        if (Math.random() < 0.0001 * dt * 60 && fishList.length < 30)
          spawnJellyfish();
        /* --- Sushi: very rare --- */
        if (Math.random() < 0.0001 * dt * 60 && fishList.length < 30)
          spawnSushi();

        /* achievement reset */
        if (score >= nextMilestone) {
          playAchvSound();
          resetRound();
          while (score >= nextMilestone) nextMilestone += 100000;
        }
      }

      function checkCollisionOval(a, b) {
        const A = a.getBounds(),
          B = b.getBounds(),
          dx = A.centerX - B.centerX,
          dy = A.centerY - B.centerY;
        return (
          (dx * dx) / (A.radiusX + B.radiusX) ** 2 +
            (dy * dy) / (A.radiusY + B.radiusY) ** 2 <=
          1
        );
      }

      function renderGame() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        bubbles.forEach((b) => b.draw(ctx));
        waterTrails.forEach((t) => t.draw(ctx));
        if (player && !(isGameOver && explosion)) player.draw(ctx);
        fishList.forEach((f) => f.draw(ctx));
        if (explosion) explosion.draw(ctx);
        ctx.fillStyle = "#fff";
        ctx.font = "20px 'Londrina Solid',sans-serif";
        ctx.fillText("Score:¬†" + score, 20, 30);
        if (touchTarget) {
          ctx.beginPath();
          ctx.arc(touchTarget.x, touchTarget.y, 15, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffffff88";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      let lastTime = 0;
      function gameLoop(ts) {
        const dt = (ts - lastTime) / 1000;
        lastTime = ts;
        updateGame(dt);
        renderGame();
        requestAnimationFrame(gameLoop);
      }

      /* --------------------------- INIT --------------------------- */
      function initGame() {
        resizeCanvas();
        score = 0;
        nextMilestone = 100000;
        gameTime = 0;
        gameStartTime = performance.now();
        isGameOver = false;
        fishList = [];
        bubbles = [];
        waterTrails = [];
        player = new Fish(WIDTH / 2, HEIGHT / 2, 0, 0, playerImg, 25, true);
        playerPowerUpTime = 0;
        playerIsPoweredUp = false;
        clearKeys();
        initAudio();
        for (let i = 0; i < 3; i++) spawnFish();
        spawnBubbleGroup();
        bubbleTimer = 0;
      }

      function showOrHideArrowKeys(show) {
        controlsContainer.style.display = show ? "flex" : "none";
        const txt = show ? "üéÆ¬†Arrow¬†Keys¬†On" : "üéÆ¬†Arrow¬†Keys¬†Off";
        arrowKeysBtn.textContent = txt;
        arrowKeysBtnGameOver.textContent = txt;
        if (!show) clearKeys();
      }
      function syncGameOverUI() {
        showOrHideArrowKeys(controlsContainer.style.display !== "none");
        updateSoundButtons();
      }

      /* --------------------------- EVENTS --------------------------- */
      startBtn.onclick = () => {
        hideStartScreen();
        showOrHideArrowKeys(arrowKeysBtn.textContent.includes("On"));
        gameState = "playing";
        initGame();
      };
      playAgainBtn.onclick = () => {
        hideGameOverScreen();
        showOrHideArrowKeys(arrowKeysBtnGameOver.textContent.includes("On"));
        gameState = "playing";
        initGame();
      };
      soundBtn.onclick = toggleSound;
      soundBtnGameOver.onclick = toggleSound;
      arrowKeysBtn.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");
      arrowKeysBtnGameOver.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");

      /* arrow buttons */
      function pressKey(key, down) {
        if (key === "left") keys.left = down;
        if (key === "right") keys.right = down;
        if (key === "up") keys.up = down;
        if (key === "down") keys.down = down;
      }
      arrowUp.onmousedown = () => pressKey("up", true);
      arrowUp.onmouseup = () => pressKey("up", false);
      arrowUp.onmouseleave = () => pressKey("up", false);
      arrowUp.ontouchstart = () => pressKey("up", true);
      arrowUp.ontouchend = () => pressKey("up", false);
      arrowDown.onmousedown = () => pressKey("down", true);
      arrowDown.onmouseup = () => pressKey("down", false);
      arrowDown.onmouseleave = () => pressKey("down", false);
      arrowDown.ontouchstart = () => pressKey("down", true);
      arrowDown.ontouchend = () => pressKey("down", false);
      arrowLeft.onmousedown = () => pressKey("left", true);
      arrowLeft.onmouseup = () => pressKey("left", false);
      arrowLeft.onmouseleave = () => pressKey("left", false);
      arrowLeft.ontouchstart = () => pressKey("left", true);
      arrowLeft.ontouchend = () => pressKey("left", false);
      arrowRight.onmousedown = () => pressKey("right", true);
      arrowRight.onmouseup = () => pressKey("right", false);
      arrowRight.onmouseleave = () => pressKey("right", false);
      arrowRight.ontouchstart = () => pressKey("right", true);
      arrowRight.ontouchend = () => pressKey("right", false);

      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = true;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });

      /* touch & mouse aiming */
      canvas.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        if (t) {
          const r = canvas.getBoundingClientRect();
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchmove", (e) => {
        const t = e.touches[0];
        if (t) {
          const r = canvas.getBoundingClientRect();
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchend", () => {
        touchTarget = null;
      });
      canvas.addEventListener("mousedown", (e) => {
        const r = canvas.getBoundingClientRect();
        touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
      });
      canvas.addEventListener("mousemove", (e) => {
        if (e.buttons > 0) {
          const r = canvas.getBoundingClientRect();
          touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
        }
      });
      canvas.addEventListener("mouseup", () => {
        touchTarget = null;
      });

      /* --------------------------- PRELOAD & START --------------------------- */
      Promise.all([
        new Promise((r) => (playerImg.onload = r)),
        ...fishTypes.map(({ image }) => new Promise((r) => (image.onload = r))),
        new Promise((r) => (crabImg.onload = r)),
        new Promise((r) => (jellyfishImg.onload = r)),
        /* sushi image */
        new Promise((r) => (sushiImg.onload = r)),
      ]).then(() => {
        resizeCanvas();
        showStartScreen();
        initAudio();
        startScreen.addEventListener("click", function first() {
          startAudio();
          startScreen.removeEventListener("click", first);
        });
        document.addEventListener("mousemove", function first() {
          startAudio();
          document.removeEventListener("mousemove", first);
        });
        requestAnimationFrame(gameLoop);
      });
    </script>
  </body>
</html>
