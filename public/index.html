<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <title>Nomu: Eat or Get Eaten</title>

    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Londrina+Solid&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Audio -->
    <audio id="backgroundMusic" loop>
      <source src="sounds/background.mp3" type="audio/mpeg" />
    </audio>
    <audio id="eatSound">
      <source src="sounds/eat.mp3" type="audio/mpeg" />
    </audio>
    <audio id="gameOverSound">
      <source src="sounds/gameover.mp3" type="audio/mpeg" />
    </audio>
    <audio id="powerUpSound">
      <source src="sounds/powerup.mp3" type="audio/mpeg" />
    </audio>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
      /* 1) Zero out everything */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        font-family: "Londrina Solid", sans-serif;
      }

      /* 2) Body becomes our background and a flex container
            to center the #gameWrapper "phone area" */
      body {
        background: #222;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      /* 3) The wrapper that enforces a phone-like shape */
      #gameWrapper {
        width: 100%;
        height: 100%;
        aspect-ratio: 9 / 16;
        max-width: 550px;
        max-height: 978px;

        position: relative;
        overflow: hidden;
        background: #222 url("img/bg.jpg") center center no-repeat;
        background-size: cover;
      }

      /* 4) The canvas now simply fills the wrapper */
      #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
        background: transparent;
        touch-action: none;
      }

      /* 5) Overlays must be absolutely positioned inside #gameWrapper */
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .hidden {
        display: none;
      }
      .overlay h1,
      .overlay button,
      .overlay p {
        color: #fff;
        margin: 8px;
      }
      .overlay button {
        font-size: 18px;
        font-weight: bold;
        color: #fff;
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 40px;
        background-color: #f78719;
        font-family: "Londrina Solid", sans-serif;
      }
      p {
        font-family: "Poppins", sans-serif;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div id="gameWrapper">
      <canvas id="gameCanvas"></canvas>

      <!-- Start Screen Overlay -->
      <div id="startScreen" class="overlay">
        <img
          src="img/title.png"
          alt="Eat or Get Eaten"
          style="max-width: 90%; height: auto; padding: 12px"
        />
        <div
          id="telegramStatus"
          style="
            color: white;
            font-family: 'Poppins', sans-serif;
            max-width: 90%;
            margin-bottom: 24px;
          "
        ></div>
        <p style="font-size: 24px; font-weight: bold; letter-spacing: 1px">
          Rules
        </p>
        <p>
          Use the touch screen or arrow keys (‚Üë‚Üí‚Üì‚Üê) to control Nomu. Eat the
          smaller fish to grow. Don't let the bigger fish eat you!
        </p>
        <p>The larger the fish the more points you get.</p>
        <p>Your high score is <span id="highScore">0</span>.</p>
        <button id="startBtn">Start Game</button>
        <button id="soundBtn" style="margin-top: 12px">üîä Sound On</button>
      </div>

      <!-- Game Over Overlay -->
      <div id="gameOverScreen" class="overlay hidden">
        <h1>GAME OVER!</h1>
        <p id="finalScore"></p>
        <button id="playAgainBtn">Play Again</button>
      </div>
    </div>
    <!-- end #gameWrapper -->

    <script>
      // Initialize Telegram Web App
      let tg;
      let userData;
      let userId;

      try {
        tg = window.Telegram.WebApp;
        userData = tg.initDataUnsafe?.user;
        userId = userData?.id;
        tg.expand();
      } catch (error) {
        console.error("Telegram initialization error:", error);
      }

      const statusDiv = document.getElementById("telegramStatus");
      if (userId) {
        statusDiv.textContent = `Telegram connected ‚úì (User: ${
          userData?.username || userData?.first_name || "Anonymous"
        })`;
        statusDiv.style.color = "lightgreen";
      } else {
        statusDiv.textContent =
          "‚ö†Ô∏è Not tracking scores - Please access via Telegram bot";
        statusDiv.style.color = "red";
      }

      async function sendScoreToAPI(score) {
        if (!userId) return;
        try {
          const response = await fetch("/api/scores", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              userId,
              username:
                userData?.username || userData?.first_name || "Anonymous",
              score,
            }),
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to send score: ${errorText}`);
          }
          const result = await response.json();
          console.log("Score sent successfully:", result);
        } catch (error) {
          console.error("Error sending score:", error);
        }
      }

      // Canvas setup
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      let WIDTH = 800;
      let HEIGHT = 600;

      function resizeCanvas() {
        const wrapper = document.getElementById("gameWrapper");
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        WIDTH = canvas.width;
        HEIGHT = canvas.height;
      }
      window.addEventListener("resize", resizeCanvas);

      // Overlays
      const startScreen = document.getElementById("startScreen");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const startBtn = document.getElementById("startBtn");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const finalScoreElem = document.getElementById("finalScore");

      function showStartScreen() {
        startScreen.classList.remove("hidden");
      }
      function hideStartScreen() {
        startScreen.classList.add("hidden");
      }
      function showGameOverScreen(score) {
        finalScoreElem.textContent = `Your Score: ${score}`;
        gameOverScreen.classList.remove("hidden");
        playGameOverSound();
      }
      function hideGameOverScreen() {
        gameOverScreen.classList.add("hidden");
      }

      let gameState = "start";
      let isGameOver = false;

      // Weighted fish definitions
      const fishTypeDefinitions = [
        { src: "img/fish1.png", minSize: 10, maxSize: 40, weight: 0.43 },
        { src: "img/fish2.png", minSize: 20, maxSize: 60, weight: 0.25 },
        { src: "img/fish3.png", minSize: 25, maxSize: 80, weight: 0.2 },
        { src: "img/fish4.png", minSize: 35, maxSize: 100, weight: 0.1 },
        { src: "img/fish6.png", minSize: 200, maxSize: 300, weight: 0.015 },
        { src: "img/fish5.png", minSize: 400, maxSize: 500, weight: 0.005 },
      ];

      // Preload fish images
      const fishTypes = fishTypeDefinitions.map((def) => {
        const image = new Image();
        image.src = def.src;
        return {
          image,
          minSize: def.minSize,
          maxSize: def.maxSize,
          weight: def.weight,
        };
      });

      // Load player image
      const playerImg = new Image();
      playerImg.src = "img/player_fish.png";

      // [NEW] Load crab image
      const crabImg = new Image();
      crabImg.src = "img/crab.png";

      // [NEW] Load jellyfish image
      const jellyfishImg = new Image();
      jellyfishImg.src = "img/jellyfish.png"; // Provide your own jellyfish sprite here

      // Game variables
      let fishList = [];
      let score = 0;
      let player;
      let touchTarget = null;
      const keys = { left: false, right: false, up: false, down: false };
      let bubbles = [];
      let waterTrails = [];
      let backgroundMusic;
      let eatSound;
      let gameOverSound;
      let powerUpSound;
      let isSoundEnabled = true;
      let explosion = null;

      // Player power-up variables
      let playerPowerUpTime = 0;
      const POWER_UP_DURATION = 10;
      let playerIsPoweredUp = false;

      // Initialize audio
      function initAudio() {
        backgroundMusic = document.getElementById("backgroundMusic");
        eatSound = document.getElementById("eatSound");
        gameOverSound = document.getElementById("gameOverSound");
        powerUpSound = document.getElementById("powerUpSound");
        backgroundMusic.volume = 0.05;
        eatSound.volume = 0.3;
        gameOverSound.volume = 0.3;
        powerUpSound.volume = 0.3;
      }

      function startAudio() {
        if (backgroundMusic && isSoundEnabled) {
          try {
            backgroundMusic.play();
          } catch (error) {
            console.log("Audio playback failed:", error);
          }
        }
      }

      function toggleSound() {
        isSoundEnabled = !isSoundEnabled;
        if (backgroundMusic) {
          if (isSoundEnabled) {
            startAudio();
            backgroundMusic.volume = 0.3;
            eatSound.volume = 0.5;
            gameOverSound.volume = 0.5;
          } else {
            backgroundMusic.pause();
            backgroundMusic.volume = 0;
            eatSound.volume = 0;
            gameOverSound.volume = 0;
          }
        }
        const soundBtn = document.getElementById("soundBtn");
        soundBtn.textContent = isSoundEnabled ? "üîä Sound On" : "üîà Sound Off";
      }

      function playEatSound() {
        if (!isSoundEnabled) return;
        eatSound.currentTime = 0;
        try {
          eatSound.play();
        } catch (error) {
          console.log("Eat sound playback failed:", error);
        }
      }

      function playGameOverSound() {
        if (!isSoundEnabled) return;
        gameOverSound.currentTime = 0;
        try {
          gameOverSound.play();
        } catch (error) {
          console.log("Game over sound playback failed:", error);
        }
      }

      function playPowerUpSound() {
        if (!isSoundEnabled) return;
        powerUpSound.currentTime = 0;
        try {
          powerUpSound.play();
        } catch (error) {
          console.log("Power-up sound playback failed:", error);
        }
      }

      function getRandom(min, max) {
        return Math.random() * (max - min) + min;
      }
      function calculateFishScore(fishSize) {
        return Math.floor(fishSize);
      }
      function getRandomWeightedFishType(fishTypes) {
        const totalWeight = fishTypes.reduce((sum, ft) => sum + ft.weight, 0);
        let randomVal = Math.random() * totalWeight;
        for (const ft of fishTypes) {
          if (randomVal < ft.weight) return ft;
          randomVal -= ft.weight;
        }
        return fishTypes[fishTypes.length - 1];
      }

      // WaterTrail
      class WaterTrail {
        constructor(x, y, direction, fishSize, isUltraFast = false) {
          this.x = x;
          this.y = y;
          const baseSize = Math.min(8, Math.max(2, fishSize * 0.1));
          this.size = getRandom(baseSize * 0.8, baseSize * 1.2);
          this.life = 1.0;
          this.fadeSpeed = getRandom(0.02, 0.04);
          this.direction = direction;
          const offsetScale = Math.min(3, Math.max(1, fishSize * 0.03));
          this.offsetX = getRandom(-offsetScale, offsetScale);
          this.offsetY = getRandom(-offsetScale, offsetScale);
          this.isUltraFast = isUltraFast;
          this.hue = Math.random() * 360;
          this.hueSpeed = getRandom(2, 4);
        }

        update(deltaTime) {
          this.life -= this.fadeSpeed * deltaTime * 60;
          this.x += this.direction * 0.5 * deltaTime * 60;
          if (this.isUltraFast) {
            this.hue = (this.hue + this.hueSpeed) % 360;
          }
        }

        draw(ctx) {
          if (this.life <= 0) return;

          ctx.beginPath();
          ctx.arc(
            this.x + this.offsetX,
            this.y + this.offsetY,
            this.size,
            0,
            Math.PI * 2
          );

          if (this.isUltraFast) {
            ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, ${this.life * 0.3})`;
            ctx.shadowBlur = 10;
            ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, ${
              this.life * 0.3
            })`;
          } else {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.05})`;
          }
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // Fish class
      class Fish {
        constructor(x, y, speedX, speedY, sprite, maxSide, isPlayer = false) {
          this.x = x;
          this.y = y;
          this.speedX = speedX;
          this.speedY = speedY;
          this.sprite = sprite;
          this.maxSide = maxSide;
          this.isPlayer = isPlayer;
          this.lastTrailTime = 0;
          this.isFast = false;
          this.isUltraFast = false;
          this.isCrab = false;
          this.isJellyfish = false;

          if (!isPlayer) {
            this.oscillationSpeed = getRandom(0.005, 0.01);
            this.oscillationAmount = getRandom(0.05, 0.1);
            this.oscillationOffset = getRandom(0, Math.PI * 2);
            this.acceleration = 0.05;
            this.maxSpeed = Math.abs(speedX) * 1.2;
          } else {
            this.velocityX = 0;
            this.velocityY = 0;
            this.acceleration = 0.055;
            this.friction = 0.99;
            this.maxSpeed = 10;
          }

          this.width = null;
          this.height = null;
        }

        calculateDimensions() {
          const w = this.sprite.naturalWidth;
          const h = this.sprite.naturalHeight;
          if (w === 0 || h === 0) {
            this.width = this.maxSide;
            this.height = this.maxSide;
            return;
          }
          const aspect = w / h;
          if (aspect > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / aspect;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * aspect;
          }
        }

        draw(ctx) {
          if (!this.sprite.complete) return;
          if (this.width === null || this.height === null) {
            this.calculateDimensions();
          }
          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;

          // Apply color-shift if needed (fast / ultra-fast / powered up)
          const applyUltraFastFilter =
            this.isUltraFast || (this.isPlayer && playerIsPoweredUp);

          // Flip if moving left
          if (isMovingLeft) {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(-1, 1);
            if (applyUltraFastFilter) {
              ctx.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
            } else if (this.isFast) {
              ctx.filter = "hue-rotate(45deg) brightness(1.2)";
            }
            ctx.drawImage(
              this.sprite,
              -this.width / 2,
              -this.height / 2,
              this.width,
              this.height
            );
            ctx.restore();
          } else {
            if (applyUltraFastFilter) {
              ctx.save();
              ctx.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
              ctx.drawImage(
                this.sprite,
                this.x,
                this.y,
                this.width,
                this.height
              );
              ctx.restore();
            } else if (this.isFast) {
              ctx.save();
              ctx.filter = "hue-rotate(45deg) brightness(1.2)";
              ctx.drawImage(
                this.sprite,
                this.x,
                this.y,
                this.width,
                this.height
              );
              ctx.restore();
            } else {
              ctx.drawImage(
                this.sprite,
                this.x,
                this.y,
                this.width,
                this.height
              );
            }
          }
        }

        getBounds() {
          const collisionScale = 0.6;
          const radiusX = ((this.width || 0) * collisionScale) / 2;
          const radiusY = ((this.height || 0) * collisionScale) / 2;
          let centerX = this.x + (this.width || 0) / 2;
          let centerY = this.y + (this.height || 0) / 2;
          const shiftAmount = (this.width || 0) * 0.07;
          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;
          if (isMovingLeft) centerX -= shiftAmount;
          else centerX += shiftAmount;
          return { centerX, centerY, radiusX, radiusY };
        }

        // Regular fish update
        update(deltaTime) {
          const deltaFrames = deltaTime * 60;
          if (this.isPlayer) {
            // Player movement
            const frictionFactor = Math.pow(this.friction, deltaFrames);
            this.velocityX *= frictionFactor;
            this.velocityY *= frictionFactor;
            this.x += this.velocityX * deltaFrames;
            this.y += this.velocityY * deltaFrames;

            if (this.width && this.height) {
              if (this.x < 0) {
                this.x = 0;
                this.velocityX = 0;
              }
              if (this.y < 0) {
                this.y = 0;
                this.velocityY = 0;
              }
              if (this.x + this.width > WIDTH) {
                this.x = WIDTH - this.width;
                this.velocityX = 0;
              }
              if (this.y + this.height > HEIGHT) {
                this.y = HEIGHT - this.height;
                this.velocityY = 0;
              }
            }
          } else {
            // Normal enemy fish "wandering" with oscillation
            const oscillation =
              Math.sin(
                performance.now() * this.oscillationSpeed +
                  this.oscillationOffset
              ) * this.oscillationAmount;
            if (!this.isJellyfish && !this.isCrab) {
              // Only fish use X for direction
              if (Math.abs(this.speedX) < this.maxSpeed) {
                this.speedX +=
                  this.acceleration * Math.sign(this.speedX) * deltaFrames;
              }
              this.x += this.speedX * deltaFrames;
              this.y += oscillation * deltaFrames;
            }
          }
        }

        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 50) return;
          this.lastTrailTime = now;

          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;
          const speed = this.isPlayer
            ? Math.sqrt(this.velocityX ** 2 + this.velocityY ** 2)
            : Math.abs(this.speedX);

          if (speed > 0.5) {
            const ultra =
              this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
            const count = ultra ? 3 : Math.random() < 0.3 ? 2 : 1;
            for (let i = 0; i < count; i++) {
              waterTrails.push(
                new WaterTrail(
                  this.x + (isMovingLeft ? this.width : 0),
                  this.y + this.height * 0.5,
                  isMovingLeft ? 1 : -1,
                  this.maxSide,
                  ultra
                )
              );
            }
          }
        }
      }

      // [NEW] Crab class
      class Crab extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, 0, crabImg, size, false);
          this.isCrab = true;
          this.hasEnteredScreen = false;
          this.timeAlive = 0;
        }

        update(deltaTime, player) {
          const deltaFrames = deltaTime * 60;

          // Entry phase: Move upwards until fully on screen
          if (!this.hasEnteredScreen) {
            this.y -= 2 * deltaFrames; // move upward
            if (this.y + this.height <= HEIGHT) {
              this.hasEnteredScreen = true;
            }
            return;
          }

          this.timeAlive += deltaTime;

          // Explode after time limit
          if (this.timeAlive > 15) {
            spawnExplosion(this);
            this.maxSide = 0;
            return;
          }

          const crabRadius = this.getBounds().radiusX;
          const playerRadius = player.getBounds().radiusX;

          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          let speedFactor = 1.5;
          if (crabRadius > playerRadius) {
            // Move toward player
            this.x += (dx / dist) * (speedFactor * deltaFrames);
            this.y += (dy / dist) * (speedFactor * deltaFrames);
          } else {
            // Move away from player
            this.x -= (dx / dist) * (speedFactor * deltaFrames);
            this.y -= (dy / dist) * (speedFactor * deltaFrames);
          }

          // Stay in bounds
          if (this.width && this.height) {
            if (this.x < 0) this.x = 0;
            if (this.y < 0) this.y = 0;
            if (this.x + this.width > WIDTH) this.x = WIDTH - this.width;
            if (this.y + this.height > HEIGHT) this.y = HEIGHT - this.height;
          }
        }
      }

      // [NEW] Jellyfish class
      class Jellyfish extends Fish {
        constructor(x, y, size) {
          // Start with speedY = -something so it moves upward
          super(x, y, 0, -1.2, jellyfishImg, size, false);
          this.isJellyfish = true;

          // Horizontal oscillation specifics
          this.oscSpeed = getRandom(0.0008, 0.0015); // speed of the wave
          this.oscAmplitude = getRandom(10, 15); // amplitude in px
          this.oscOffset = Math.random() * Math.PI * 2;
          this.baseX = x;

          // Adjust vertical speed a bit
          this.verticalSpeed = getRandom(0.5, 1.2);
        }

        update(deltaTime) {
          const deltaFrames = deltaTime * 60;

          // Move upward
          this.y -= this.verticalSpeed * deltaFrames;

          // Horizontal oscillation
          const oscValue =
            Math.sin(performance.now() * this.oscSpeed + this.oscOffset) *
            this.oscAmplitude;
          this.x = this.baseX + oscValue;

          // Remove if it goes above the screen
          if (this.y + (this.height || 0) < -50) {
            this.maxSide = 0;
          }
        }
      }

      // Bubble
      class Bubble {
        constructor(baseX) {
          this.reset(baseX);
        }
        reset(baseX) {
          this.x = baseX + getRandom(-10, 10);
          this.y = HEIGHT + 20;
          this.size = getRandom(3, 8);
          this.speed = getRandom(2, 3.5);
          this.opacity = getRandom(0.2, 0.4);
          this.wobbleAmount = getRandom(0.1, 0.3);
          this.wobbleSpeed = getRandom(0.02, 0.05);
          this.wobbleOffset = getRandom(0, Math.PI * 2);
        }
        update(deltaTime) {
          this.y -= this.speed * deltaTime * 60;
          this.x +=
            Math.sin(this.wobbleOffset + performance.now() * this.wobbleSpeed) *
            this.wobbleAmount *
            deltaTime *
            60;
          if (this.y < -20) {
            this.reset();
          }
        }
        draw(ctx) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.fill();
        }
      }

      // Explosion
      class Explosion {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.particles = [];
          this.life = 1.0;
          this.fadeSpeed = 0.02;
          this.isComplete = false;

          const particleCount = Math.floor(size * 0.5);
          for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const speed = getRandom(2, 4);
            this.particles.push({
              x: 0,
              y: 0,
              speedX: Math.cos(angle) * speed,
              speedY: Math.sin(angle) * speed,
              size: getRandom(3, 8),
              life: 1.0,
              fadeSpeed: getRandom(0.01, 0.03),
            });
          }
        }
        update(deltaTime) {
          if (this.isComplete) return;
          this.life -= this.fadeSpeed * deltaTime * 60;
          for (const p of this.particles) {
            p.x += p.speedX * deltaTime * 60;
            p.y += p.speedY * deltaTime * 60;
            p.life -= p.fadeSpeed * deltaTime * 60;
          }
          if (this.life <= 0) {
            this.isComplete = true;
          }
        }
        draw(ctx) {
          if (this.life <= 0) return;
          for (const p of this.particles) {
            if (p.life <= 0) continue;
            ctx.beginPath();
            ctx.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${p.life * 0.8})`;
            ctx.fill();
          }
        }
      }

      // Helper to create an explosion at a fish's position
      function spawnExplosion(fish) {
        if (fish.width && fish.height) {
          const e = new Explosion(
            fish.x + fish.width / 2,
            fish.y + fish.height / 2,
            fish.maxSide
          );
          explosion = e;
        }
      }

      function spawnFish() {
        const chosenType = getRandomWeightedFishType(fishTypes);
        const fishSize = getRandom(chosenType.minSize, chosenType.maxSize);
        const fromLeft = Math.random() < 0.5;
        const x = fromLeft ? -fishSize : WIDTH;
        const y = getRandom(0, HEIGHT - fishSize);

        const sizeFactor = 1 - fishSize / 500;
        const minSpeed = 0.3 + 0.5 * sizeFactor;
        const maxSpeed = 1.5 + 0.3 * sizeFactor;
        let baseSpeed = getRandom(minSpeed, maxSpeed);

        const isUltraFast = Math.random() < 0.01; // 1% chance
        const isFast = !isUltraFast && Math.random() < 0.03;

        if (isUltraFast) baseSpeed *= 5;
        else if (isFast) baseSpeed *= 3;

        const speedX = fromLeft ? baseSpeed : -baseSpeed;
        const enemy = new Fish(x, y, speedX, 0, chosenType.image, fishSize);
        enemy.isFast = isFast;
        enemy.isUltraFast = isUltraFast;
        fishList.push(enemy);
      }

      // [NEW] spawnCrab
      function spawnCrab() {
        const size = getRandom(50, 120);
        const x = getRandom(0, WIDTH - size); // random horizontal position
        const y = HEIGHT + size; // spawn below the screen
        const crab = new Crab(x, y, size);
        fishList.push(crab);
      }

      // [NEW] spawnJellyfish
      function spawnJellyfish() {
        const size = getRandom(30, 120);
        const x = getRandom(0, WIDTH - size);
        const y = HEIGHT + size; // Start below screen
        const jelly = new Jellyfish(x, y, size);
        fishList.push(jelly);
      }

      function spawnBubbleGroup() {
        const groupSize = Math.floor(getRandom(3, 5));
        const baseX = getRandom(50, WIDTH - 50);
        for (let i = 0; i < groupSize; i++) {
          if (bubbles.length < 8) {
            bubbles.push(new Bubble(baseX));
          }
        }
      }

      // updateGame
      function updateGame(deltaTime) {
        // Always update the main explosion
        if (explosion) {
          explosion.update(deltaTime);
          if (explosion.isComplete) {
            explosion = null;
            if (isGameOver) {
              showGameOverScreen(score);
            }
          }
        }

        if (gameState !== "playing") return;
        if (isGameOver && !explosion) return;

        // Update power-up timer
        if (playerPowerUpTime > 0) {
          playerPowerUpTime -= deltaTime;
          if (playerPowerUpTime <= 0) {
            playerPowerUpTime = 0;
            playerIsPoweredUp = false;
          }
        }

        // Update bubbles
        for (const bubble of bubbles) {
          bubble.update(deltaTime);
        }
        // Update water trails
        for (let i = waterTrails.length - 1; i >= 0; i--) {
          const trail = waterTrails[i];
          trail.update(deltaTime);
          if (trail.life <= 0) waterTrails.splice(i, 1);
        }

        // Player water trail
        if (player) player.createWaterTrail();

        // Enemy water trails
        for (const fish of fishList) {
          fish.createWaterTrail();
        }

        // Spawn new bubble groups occasionally
        if (Math.random() < 0.002 * deltaTime * 60 && bubbles.length < 5) {
          spawnBubbleGroup();
        }

        // Player movement
        const accel = player.acceleration * deltaTime * 60;
        if (keys.left) player.velocityX -= accel;
        if (keys.right) player.velocityX += accel;
        if (keys.up) player.velocityY -= accel;
        if (keys.down) player.velocityY += accel;

        // Touch/mouse movement
        if (touchTarget && player.width && player.height) {
          const px = player.x + player.width / 2;
          const py = player.y + player.height / 2;
          const dx = touchTarget.x - px;
          const dy = touchTarget.y - py;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 1) {
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;
            player.velocityX += ax;
            player.velocityY += ay;
          }
        }

        // Limit player speed
        const spd = Math.sqrt(player.velocityX ** 2 + player.velocityY ** 2);
        if (spd > player.maxSpeed) {
          const ratio = player.maxSpeed / spd;
          player.velocityX *= ratio;
          player.velocityY *= ratio;
        }

        // Update player
        player.update(deltaTime);

        // Update enemies
        for (let i = fishList.length - 1; i >= 0; i--) {
          const enemy = fishList[i];

          // If it's a crab, it needs to track the player
          if (enemy.isCrab) {
            enemy.update(deltaTime, player);
            // If the crab has exploded or is done => remove
            if (enemy.maxSide <= 0) {
              fishList.splice(i, 1);
              continue;
            }
          }
          // If it's a Jellyfish
          else if (enemy.isJellyfish) {
            enemy.update(deltaTime);
            if (enemy.maxSide <= 0) {
              fishList.splice(i, 1);
              continue;
            }
          }
          // Otherwise it's a normal fish
          else {
            enemy.update(deltaTime);
            // Remove if off-screen
            const bounds = enemy.getBounds();
            if (
              bounds.centerX + bounds.radiusX < -200 ||
              bounds.centerX - bounds.radiusX > WIDTH + 200
            ) {
              fishList.splice(i, 1);
              continue;
            }
          }

          // Collision check with player
          if (checkCollisionOval(player, enemy)) {
            // If player is powered up, always eats
            if (playerIsPoweredUp) {
              score += calculateFishScore(enemy.maxSide);
              player.maxSide += Math.min(Math.sqrt(enemy.maxSide) * 0.05, 1.5);
              player.width = null;
              player.height = null;
              playEatSound();

              // If enemy was ultra-fast, refresh the power-up
              if (enemy.isUltraFast) {
                playerPowerUpTime = POWER_UP_DURATION;
                playerIsPoweredUp = true;
                playPowerUpSound();
              }
              fishList.splice(i, 1);
            } else {
              // Check bounding sizes to see who eats whom
              if (
                player.getBounds().radiusX > enemy.getBounds().radiusX &&
                !enemy.isCrab &&
                !enemy.isJellyfish
              ) {
                // Player eats smaller fish
                score += calculateFishScore(enemy.maxSide);
                player.maxSide += Math.min(
                  Math.sqrt(enemy.maxSide) * 0.05,
                  1.5
                );
                player.width = null;
                player.height = null;
                playEatSound();

                if (enemy.isUltraFast) {
                  playerPowerUpTime = POWER_UP_DURATION;
                  playerIsPoweredUp = true;
                  playPowerUpSound();
                }
                fishList.splice(i, 1);
              } else if (
                // Player can also eat smaller Crab/Jellyfish
                player.getBounds().radiusX > enemy.getBounds().radiusX &&
                (enemy.isCrab || enemy.isJellyfish)
              ) {
                score += calculateFishScore(enemy.maxSide);
                player.maxSide += Math.min(
                  Math.sqrt(enemy.maxSide) * 0.05,
                  1.5
                );
                player.width = null;
                player.height = null;
                playEatSound();
                fishList.splice(i, 1);
              } else {
                // Player is eaten => game over
                isGameOver = true;
                gameState = "over";
                sendScoreToAPI(score);
                // Spawn explosion at player's position
                if (player.width && player.height) {
                  explosion = new Explosion(
                    player.x + player.width / 2,
                    player.y + player.height / 2,
                    player.maxSide
                  );
                }
                return;
              }
            }
          }
        }

        // Spawn fish
        if (Math.random() < 0.03 * deltaTime * 60 && fishList.length < 30) {
          spawnFish();
        }
        // Occasionally spawn a crab
        if (Math.random() < 0.00005 * deltaTime * 60 && fishList.length < 30) {
          spawnCrab();
        }
        // [NEW] Occasionally spawn a jellyfish
        if (Math.random() < 0.0001 * deltaTime * 60 && fishList.length < 30) {
          spawnJellyfish();
        }
      }

      function checkCollisionOval(a, b) {
        const A = a.getBounds();
        const B = b.getBounds();
        const dx = A.centerX - B.centerX;
        const dy = A.centerY - B.centerY;
        const sumRadiiX = A.radiusX + B.radiusX;
        const sumRadiiY = A.radiusY + B.radiusY;
        return (
          (dx * dx) / (sumRadiiX * sumRadiiX) +
            (dy * dy) / (sumRadiiY * sumRadiiY) <=
          1
        );
      }

      // renderGame
      function renderGame() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        // Bubbles
        for (const bubble of bubbles) {
          bubble.draw(ctx);
        }
        // Water trails
        for (const trail of waterTrails) {
          trail.draw(ctx);
        }

        // Draw player (only hide if game over AND explosion is active)
        if (player && !(isGameOver && explosion)) {
          player.draw(ctx);
        }

        // Enemies (fish + crabs + jellyfish)
        for (const fish of fishList) {
          fish.draw(ctx);
        }

        // Explosion
        if (explosion) {
          explosion.draw(ctx);
        }

        ctx.fillStyle = "#fff";
        ctx.font = "20px Londrina Solid, sans-serif";
        ctx.fillText("Score: " + score, 20, 30);

        // Touch indicator
        if (touchTarget) {
          ctx.beginPath();
          ctx.arc(touchTarget.x, touchTarget.y, 15, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffffff88";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      let lastTime = 0;
      function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        updateGame(deltaTime);
        renderGame();
        requestAnimationFrame(gameLoop);
      }

      function initGame() {
        resizeCanvas();
        score = 0;
        isGameOver = false;
        fishList = [];
        bubbles = [];
        waterTrails = [];
        player = new Fish(WIDTH / 2, HEIGHT / 2, 0, 0, playerImg, 25, true);

        // Reset power-up
        playerPowerUpTime = 0;
        playerIsPoweredUp = false;

        initAudio();
        for (let i = 0; i < 3; i++) {
          spawnFish();
        }
        spawnBubbleGroup();
      }

      startBtn.onclick = () => {
        hideStartScreen();
        gameState = "playing";
        initGame();
      };
      playAgainBtn.onclick = () => {
        hideGameOverScreen();
        gameState = "playing";
        initGame();
      };

      // Touch events
      canvas.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        if (touch) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("touchmove", (e) => {
        const touch = e.touches[0];
        if (touch) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("touchend", () => {
        touchTarget = null;
      });

      // Mouse events
      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        touchTarget = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      });
      canvas.addEventListener("mousemove", (e) => {
        if (e.buttons > 0) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("mouseup", () => {
        touchTarget = null;
      });

      // Keyboard
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = true;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });

      // Preload images & then start the game
      Promise.all([
        new Promise((resolve) => (playerImg.onload = resolve)),
        ...fishTypes.map(
          ({ image }) => new Promise((resolve) => (image.onload = resolve))
        ),
        new Promise((resolve) => (crabImg.onload = resolve)),
        new Promise((resolve) => (jellyfishImg.onload = resolve)),
      ]).then(() => {
        resizeCanvas();
        showStartScreen();
        initAudio();

        document.getElementById("soundBtn").onclick = toggleSound;
        document
          .getElementById("startScreen")
          .addEventListener("click", function firstInteraction() {
            startAudio();
            this.removeEventListener("click", firstInteraction);
          });
        document.addEventListener("mousemove", function firstInteraction() {
          startAudio();
          document.removeEventListener("mousemove", firstInteraction);
        });

        requestAnimationFrame(gameLoop);
      });
    </script>
  </body>
</html>
