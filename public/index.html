<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://telegram.org/js/telegram-web-app.js?57"></script>

    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <title>Nomu: Eat or Get Eaten</title>

    <!-- ----------------------------------------------------------------- -->
    <!--                       FONTS & AUDIO ASSETS                         -->
    <!-- ----------------------------------------------------------------- -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Londrina+Solid&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <audio id="backgroundMusic" loop>
      <source src="sounds/background3.mp3" type="audio/mpeg" />
    </audio>
    <audio id="eatSound">
      <source src="sounds/eat.mp3" type="audio/mpeg" />
    </audio>
    <audio id="gameOverSound">
      <source src="sounds/gameover.mp3" type="audio/mpeg" />
    </audio>
    <audio id="powerUpSound">
      <source src="sounds/powerup.mp3" type="audio/mpeg" />
    </audio>
    <audio id="achievementSound">
      <source src="sounds/achievement.mp3" type="audio/mpeg" />
    </audio>
    <!-- NEW: shrink sound -->
    <audio id="shrinkSound">
      <source src="sounds/shrink.mp3" type="audio/mpeg" />
    </audio>
    <!-- NEW: electric pulse sound -->
    <audio id="electricSound">
      <source src="sounds/electric.mp3" type="audio/mpeg" />
    </audio>
    <!-- NEW: shock sound played when the player is actually hit -->
    <audio id="shockSound">
      <source src="sounds/shock.mp3" type="audio/mpeg" />
    </audio>

    <!-- ----------------------------------------------------------------- -->
    <!--                              STYLES                               -->
    <!-- ----------------------------------------------------------------- -->
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: #222;
        font-family: "Poppins", sans-serif;
      }
      #gameWrapper {
        flex: 1;
        width: 100%;
        position: relative;
        overflow: hidden;
        background: #222 url("img/bg6.png") center/cover no-repeat;
        display: flex;
        margin: 0 auto;
        max-width: 430px;
        max-height: 935px;
      }
      #gameCanvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }
      #controlsContainer {
        width: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        background: #222;
      }
      .controlsRow {
        display: flex;
        width: 100%;
        max-width: 450px;
        margin: 0 auto;
      }
      .arrowBtn {
        flex: 1;
        background: #f78719;
        border: none;
        color: #fff;
        font-family: "Londrina Solid", sans-serif;
        font-size: 20px;
        margin: 1px;
        cursor: pointer;
        border-radius: 4px;
        height: 60px;
        user-select: none;
        touch-action: none; /* important for multi-touch */
      }
      .arrowBtn:active {
        transform: scale(0.95);
      }
      .overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .hidden {
        display: none;
      }
      .overlay h1,
      .overlay button,
      .overlay p {
        color: #fff;
        margin: 8px;
      }
      .overlay button {
        font-size: 16px;
        font-weight: bold;
        padding: 8px 10px;
        cursor: pointer;
        border-radius: 40px;
        background: #f78719;
        font-family: "Londrina Solid", sans-serif;
        margin: 4px;
      }
      .overlay p {
        font-size: 14px;
      }
    </style>
  </head>

  <body>
    <!-- ----------------------------------------------------------------- -->
    <!--                            MARK-UP                                -->
    <!-- ----------------------------------------------------------------- -->
    <div id="gameWrapper">
      <canvas id="gameCanvas"></canvas>

      <!-- ---------- Start overlay ---------- -->
      <div id="startScreen" class="overlay">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <img
            src="img/title.png"
            alt="Eat or Get Eaten"
            style="
              max-width: 50%;
              height: auto;
              padding: 12px;
              padding-bottom: 0;
              margin-bottom: -8px;
              max-height: 30vh;
            "
          />
          <p
            style="
              font-size: 28px;
              background: linear-gradient(to top, #ff0000, #ff6600, #ffcc00);
              -webkit-background-clip: text;
              background-clip: text;
              color: transparent;
              font-family: 'Londrina Solid', sans-serif;
              letter-spacing: 2px;
            "
          >
            SEASON 3
          </p>
          <p style="font-size: 12px; color: #fff; opacity: 0.5">v3.0</p>

          <div
            id="telegramStatus"
            style="
              color: white;
              font-family: 'Poppins', sans-serif;
              margin-bottom: 24px;
            "
          ></div>

          <p style="font-size: 24px; font-weight: bold; letter-spacing: 1px">
            Rules
          </p>
          <p>
            Use the touch screen or arrow keys (‚Üë‚Üí‚Üì‚Üê) to control Nomu. Eat the
            smaller fish to grow. Don't let the bigger fish eat you!
          </p>
          <p>The larger the fish, the more points you get.</p>

          <div
            style="
              display: flex;
              gap: 0px;
              margin-bottom: 0px;
              justify-content: center;
            "
          >
            <button id="musicBtn">üéµ Music On</button>
            <button id="sfxBtn">üîä SFX On</button>
            <button id="arrowKeysBtn">üéÆ Arrow Keys Off</button>
          </div>
          <!-- <div
            style="
              display: flex;
              gap: 0;
              margin-bottom: 0;
              justify-content: center;
            "
          >
          </div> -->

          <button id="startBtn" style="font-size: 24px; padding: 12px 24px">
            Start Game
          </button>
        </div>
      </div>

      <!-- ---------- Game-over overlay ---------- -->
      <div id="gameOverScreen" class="overlay hidden">
        <div style="max-width: 90%; margin: 0 auto; text-align: center">
          <h1
            style="font-family: 'Londrina Solid', sans-serif; font-size: 44px"
          >
            GAME OVER!
          </h1>
          <p id="finalScore"></p>
          <div style="display: flex; gap: 0; justify-content: center">
            <button id="musicBtnGameOver">üéµ Music On</button>
            <button id="sfxBtnGameOver">üîä SFX On</button>
            <button id="arrowKeysBtnGameOver">üéÆ Arrow Keys Off</button>
          </div>
          <!-- <div style="display: flex; gap: 0; justify-content: center">
          </div> -->
          <button
            id="playAgainBtn"
            style="font-size: 24px; padding: 12px 24px; margin-top: 12px"
          >
            Play Again
          </button>
        </div>
      </div>
    </div>

    <!-- ---------- Bottom: on-screen arrow keys ---------- -->
    <div id="controlsContainer">
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowUp">‚Üë</button>
      </div>
      <div class="controlsRow">
        <button class="arrowBtn" id="arrowLeft">‚Üê</button>
        <button class="arrowBtn" id="arrowDown">‚Üì</button>
        <button class="arrowBtn" id="arrowRight">‚Üí</button>
      </div>
    </div>

    <!-- ----------------------------------------------------------------- -->
    <!--                          GAME SCRIPT                               -->
    <!-- ----------------------------------------------------------------- -->
    <script>
      /********************* CONSTANTS & GLOBALS ***************************/

      /* -------- Telegram initialisation -------- */
      let tg, userData, userId, initDataRaw;
      try {
        tg = window.Telegram.WebApp;
        initDataRaw = tg.initData;
        userData = tg.initDataUnsafe?.user;
        userId = userData?.id;
        tg.expand();
        tg.ready();
        tg.disableVerticalSwipes();
      } catch (e) {
        console.error("Telegram init error:", e);
      }

      const statusDiv = document.getElementById("telegramStatus");
      if (userId) {
        statusDiv.textContent = `Telegram connected ‚úì (User: ${
          userData?.username || userData?.first_name || "Anonymous"
        })`;
        statusDiv.style.color = "lightgreen";
      } else {
        statusDiv.textContent =
          "‚ö†Ô∏è Not tracking scores ‚Äì open via Telegram bot";
        statusDiv.style.color = "red";
      }

      /* -------- Keyboard state -------- */
      const keys = { left: false, right: false, up: false, down: false };
      const clearKeys = () => {
        keys.left = keys.right = keys.up = keys.down = false;
      };

      /* ------------------------------------------------------------------
         IMPROVED ON-SCREEN BUTTON HANDLING
      ------------------------------------------------------------------ */
      const pointerDirMap = Object.create(null); // pointerId ‚Üí dir

      function pressKey(dir, down) {
        keys[dir] = down;
      }

      function setupArrowButton(btn, dir) {
        btn.addEventListener(
          "pointerdown",
          (e) => {
            pressKey(dir, true);
            btn.setPointerCapture(e.pointerId);
            pointerDirMap[e.pointerId] = dir;
            e.preventDefault();
          },
          { passive: false }
        );

        function release(e) {
          const d = pointerDirMap[e.pointerId] ?? dir;
          pressKey(d, false);
          delete pointerDirMap[e.pointerId];
        }

        btn.addEventListener("pointerup", release);
        btn.addEventListener("pointercancel", release);
        btn.addEventListener("pointerleave", (e) => {
          if (e.buttons === 0) release(e);
        });
      }

      ["Up", "Left", "Down", "Right"].forEach((dir) => {
        setupArrowButton(
          document.getElementById(`arrow${dir}`),
          dir.toLowerCase()
        );
      });

      /* -------- Score submission -------- */
      /**
       * Send the player's score to the back-end.
       */
      async function sendScoreToAPI(score) {
        if (!userId) return; // not running inside Telegram ‚Üí skip

        try {
          await fetch("/api/scores", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              // **Only** Telegram signature ‚Äì no shared secret in the client!
              // "x-telegram-init-data": window.Telegram.WebApp.initData,
              Authorization: `tma ${initDataRaw}`,
            },
            body: JSON.stringify({
              score,
              gameTime,
              event: "Season 3",
            }),
          });
        } catch (e) {
          console.error("Score send error:", e);
        }
      }

      /* Canvas & resize --------------------------------------------------- */
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      let WIDTH = 800,
        HEIGHT = 600;

      /* --------------  UPDATED FOR HIGH-DPI SCREENS ------------------ */
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;

        /* physical backing-store size */
        const cssW = canvas.clientWidth;
        const cssH = canvas.clientHeight;
        canvas.width = cssW * dpr;
        canvas.height = cssH * dpr;

        /* reset any previous transform, then scale once */
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        /* logical game-space size (CSS pixels) */
        WIDTH = cssW;
        HEIGHT = cssH;

        /* keep everything inside the new bounds */
        if (player && player.width && player.height) {
          player.x = Math.min(Math.max(0, player.x), WIDTH - player.width);
          player.y = Math.min(Math.max(0, player.y), HEIGHT - player.height);
        }
        [...fishList, ...bubbles].forEach((ent) => {
          if (ent.width && ent.height) {
            ent.x = Math.min(Math.max(0, ent.x), WIDTH - ent.width);
            ent.y = Math.min(Math.max(0, ent.y), HEIGHT - ent.height);
          }
        });
      }
      /* ------------------------------------------------------------------ */

      window.addEventListener("resize", resizeCanvas);

      /* Overlay / control DOM elements ----------------------------------- */
      const startScreen = document.getElementById("startScreen");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const startBtn = document.getElementById("startBtn");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const finalScoreElem = document.getElementById("finalScore");
      const musicBtn = document.getElementById("musicBtn");
      const sfxBtn = document.getElementById("sfxBtn");
      const arrowKeysBtn = document.getElementById("arrowKeysBtn");
      const musicBtnGameOver = document.getElementById("musicBtnGameOver");
      const sfxBtnGameOver = document.getElementById("sfxBtnGameOver");
      const arrowKeysBtnGameOver = document.getElementById(
        "arrowKeysBtnGameOver"
      );
      const controlsContainer = document.getElementById("controlsContainer");
      const arrowUp = document.getElementById("arrowUp");
      const arrowDown = document.getElementById("arrowDown");
      const arrowLeft = document.getElementById("arrowLeft");
      const arrowRight = document.getElementById("arrowRight");

      const showStartScreen = () => startScreen.classList.remove("hidden");
      const hideStartScreen = () => startScreen.classList.add("hidden");
      const showGameOverScreen = (score) => {
        finalScoreElem.textContent = `Your Score: ${score}`;
        gameOverScreen.classList.remove("hidden");
        playGameOverSound();
        syncGameOverUI();
      };
      const hideGameOverScreen = () => gameOverScreen.classList.add("hidden");

      /* Game-state flags -------------------------------------------------- */
      let gameState = "start"; // "start" | "playing" | "over"
      let isGameOver = false;

      /*********************   IMAGES & SPRITES   ***************************/
      const fishTypeDefinitions = [
        { src: "img/fish1-3.png", minSize: 10, maxSize: 40, weight: 0.432 },
        { src: "img/fish2-3.png", minSize: 20, maxSize: 60, weight: 0.252 },
        { src: "img/fish3-3.png", minSize: 25, maxSize: 80, weight: 0.2 },
        { src: "img/fish4-3.png", minSize: 35, maxSize: 100, weight: 0.1 },
        { src: "img/fish5-3.png", minSize: 200, maxSize: 300, weight: 0.013 },
        { src: "img/fish6-3.png", minSize: 400, maxSize: 500, weight: 0.003 },
      ];
      const fishTypes = fishTypeDefinitions.map((def) => {
        const image = new Image();
        image.src = def.src;
        return {
          image,
          minSize: def.minSize,
          maxSize: def.maxSize,
          weight: def.weight,
        };
      });

      const playerImg = new Image();
      playerImg.src = "img/player_fish.png";
      const crabImg = new Image();
      crabImg.src = "img/crab.png";
      const jellyfishImg = new Image();
      jellyfishImg.src = "img/jellyfish-3.png";
      /* NEW: dedicated electric-jellyfish sprite */
      const electricJellyfishImg = new Image();
      electricJellyfishImg.src = "img/electric-jellyfish-c.png";
      const sushiImg = new Image();
      sushiImg.src = "img/sushi.png";
      const pufferImg = new Image();
      pufferImg.src = "img/pufferfish-3.png";

      /*********************   GAME VARIABLES   ****************************/
      let fishList = [],
        score = 0,
        nextMilestone = 100000,
        player,
        touchTarget = null;
      let bubbles = [],
        waterTrails = [],
        backgroundMusic,
        eatSound,
        gameOverSound,
        powerUpSound,
        achievementSound,
        shrinkSound,
        electricSound,
        shockSound /* NEW */,
        isSfxEnabled = true,
        isMusicEnabled = true,
        explosion = null;
      let gameStartTime = 0,
        gameTime = 0;

      /* NEW: paralysis */
      let playerParalyzeTime = 0;
      const PARALYZE_DURATION = 3; // seconds

      /* Balance / tuning constants */
      const EATING_LEEWAY = 1.15;
      const JELLY_SHRINK_FACTOR = 0.6;
      const MIN_PLAYER_SIZE = 25;
      let playerPowerUpTime = 0,
        playerIsPoweredUp = false;
      const POWER_UP_DURATION = 10;

      /*********************   AUDIO HELPERS   *****************************/
      function initAudio() {
        backgroundMusic = document.getElementById("backgroundMusic");
        eatSound = document.getElementById("eatSound");
        gameOverSound = document.getElementById("gameOverSound");
        powerUpSound = document.getElementById("powerUpSound");
        achievementSound = document.getElementById("achievementSound");
        shrinkSound = document.getElementById("shrinkSound");
        electricSound = document.getElementById("electricSound");
        shockSound = document.getElementById("shockSound"); /* NEW */
        backgroundMusic.volume = 0.2;
        eatSound.volume =
          gameOverSound.volume =
          powerUpSound.volume =
          achievementSound.volume =
          electricSound.volume =
          shockSound.volume =
            0.5;
        shrinkSound.volume = 0.3;
      }
      const startAudio = () => {
        if (backgroundMusic && isMusicEnabled)
          backgroundMusic.play().catch(() => {});
      };

      /* ----------  MUSIC / SFX TOGGLES ---------- */
      const updateMusicButtons = () => {
        const txt = isMusicEnabled ? "üéµ Music On" : "üéµ Music Off";
        musicBtn.textContent = txt;
        musicBtnGameOver.textContent = txt;
      };
      const updateSfxButtons = () => {
        const txt = isSfxEnabled ? "üîä SFX On" : "üîà SFX Off";
        sfxBtn.textContent = txt;
        sfxBtnGameOver.textContent = txt;
      };
      const toggleMusic = () => {
        isMusicEnabled = !isMusicEnabled;
        if (backgroundMusic) {
          if (isMusicEnabled) {
            startAudio();
            backgroundMusic.volume = 0.2;
          } else {
            backgroundMusic.pause();
            backgroundMusic.volume = 0;
          }
        }
        updateMusicButtons();
      };
      const toggleSFX = () => {
        isSfxEnabled = !isSfxEnabled;
        const v = isSfxEnabled ? 0.5 : 0;
        eatSound.volume =
          gameOverSound.volume =
          powerUpSound.volume =
          achievementSound.volume =
          electricSound.volume =
          shockSound.volume =
            v;
        shrinkSound.volume = isSfxEnabled ? 0.3 : 0;
        updateSfxButtons();
      };

      /* helpers that respect SFX flag */
      const playEatSound = () =>
        isSfxEnabled && eatSound.play().catch(() => {});
      const playGameOverSound = () =>
        isSfxEnabled &&
        ((gameOverSound.currentTime = 0), gameOverSound.play().catch(() => {}));
      const playPowerUpSound = () =>
        isSfxEnabled &&
        ((powerUpSound.currentTime = 0), powerUpSound.play().catch(() => {}));
      const playAchvSound = () =>
        isSfxEnabled &&
        ((achievementSound.currentTime = 0),
        achievementSound.play().catch(() => {}));
      const playShrinkSound = () =>
        isSfxEnabled &&
        ((shrinkSound.currentTime = 0), shrinkSound.play().catch(() => {}));
      const playElectricSound = () =>
        isSfxEnabled &&
        ((electricSound.currentTime = 0), electricSound.play().catch(() => {}));
      /* NEW: sound when player is shocked */
      const playShockSound = () =>
        isSfxEnabled &&
        ((shockSound.currentTime = 0), shockSound.play().catch(() => {}));

      /*********************   UTILITY HELPERS   ***************************/
      const getRandom = (min, max) => Math.random() * (max - min) + min;
      const calculateFishScore = (sz) => Math.floor(sz);
      const totalFishWeight = fishTypes.reduce((s, f) => s + f.weight, 0);
      function getRandomWeightedFishType(arr) {
        let r = Math.random() * totalFishWeight;
        for (const ft of arr) {
          if (r < ft.weight) return ft;
          r -= ft.weight;
        }
        return arr[arr.length - 1];
      }

      /*********************    CLASS DEFINITIONS  *************************/
      /* ---- WaterTrail ---- */
      class WaterTrail {
        constructor(
          x,
          y,
          dir,
          fishSize,
          isUltra = false,
          colorRGB = null /* NEW */
        ) {
          this.x = x;
          this.y = y;
          this.size = getRandom(
            Math.min(8, Math.max(2, fishSize * 0.1)) * 0.8,
            Math.min(8, Math.max(2, fishSize * 0.1)) * 1.2
          );
          this.life = 1;
          this.fadeSpeed = getRandom(0.02, 0.04);
          this.dir = dir;
          this.offsetX = getRandom(-3, 3);
          this.offsetY = getRandom(-3, 3);
          this.isUltra = isUltra;
          this.colorRGB = colorRGB; /* store custom colour */
          this.hue = Math.random() * 360;
          this.hueSpeed = getRandom(2, 4);
        }
        update(dt) {
          this.life -= this.fadeSpeed * dt * 60;
          this.x += this.dir * 0.5 * dt * 60;
          if (this.isUltra) this.hue = (this.hue + this.hueSpeed) % 360;
        }
        draw(c) {
          if (this.life <= 0) return;
          c.beginPath();
          c.arc(
            this.x + this.offsetX,
            this.y + this.offsetY,
            this.size,
            0,
            Math.PI * 2
          );

          if (this.isUltra) {
            c.fillStyle = `hsla(${this.hue},100%,50%,${this.life * 0.3})`;
            c.shadowBlur = 10;
            c.shadowColor = `hsla(${this.hue},100%,50%,${this.life * 0.3})`;
          } else if (this.colorRGB) {
            const { r, g, b } = this.colorRGB;
            c.fillStyle = `rgba(${r},${g},${b},${this.life * 0.3})`;
            c.shadowBlur = 6;
            c.shadowColor = `rgba(${r},${g},${b},${this.life * 0.3})`;
          } else {
            c.fillStyle = `rgba(255,255,255,${this.life * 0.05})`;
            c.shadowBlur = 0;
          }
          c.fill();
          c.shadowBlur = 0;
        }
      }

      /* ---- Fish (base) ---- */
      class Fish {
        constructor(x, y, sx, sy, img, maxSide, isPlayer = false) {
          this.x = x;
          this.y = y;
          this.speedX = sx;
          this.speedY = sy;
          this.sprite = img;
          this.maxSide = maxSide;
          this.isPlayer = isPlayer;
          this.lastTrailTime = 0;
          this.isFast =
            this.isUltraFast =
            this.isCrab =
            this.isJellyfish =
            this.isSushi =
            this.isPuffer =
              false;
          if (!isPlayer) {
            this.oscSpd = getRandom(0.005, 0.01);
            this.oscAmt = getRandom(0.05, 0.1);
            this.oscOff = getRandom(0, Math.PI * 2);
            this.accel = 0.05;
            this.maxSpd = Math.abs(sx) * 1.2;
          } else {
            this.vx = this.vy = 0;
            this.accel = 0.055;
            this.friction = 0.99;
            this.maxSpd = 10;
            this.facingLeft = false; // NEW: remember orientation
          }
          this.width = this.height = null;
        }
        calculateDimensions() {
          const w = this.sprite.naturalWidth,
            h = this.sprite.naturalHeight;
          if (!w || !h) {
            this.width = this.height = this.maxSide;
            return;
          }
          const asp = w / h;
          if (asp > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / asp;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * asp;
          }
        }
        draw(c) {
          if (!this.sprite.complete) return;
          if (this.width === null || this.height === null)
            this.calculateDimensions();

          /* -------- orientation -------- */
          if (this.isPlayer) {
            // maintain orientation if paralyzed
            if (Math.abs(this.vx) > 0.1) this.facingLeft = this.vx < 0;
          }
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;

          const ultra =
            this.isUltraFast || (this.isPlayer && playerIsPoweredUp);

          const flickerActive =
            this.isPlayer &&
            playerIsPoweredUp &&
            playerPowerUpTime <= 3 &&
            Math.floor(performance.now() / 100) % 2 === 0;

          c.save();
          if (movingLeft) {
            c.translate(this.x + this.width / 2, this.y + this.height / 2);
            c.scale(-1, 1);
            c.translate(-this.width / 2, -this.height / 2);
          } else c.translate(this.x, this.y);

          /* NEW: player frozen ‚Üí yellow tint */
          if (this.isPlayer && playerParalyzeTime > 0) {
            c.filter = "hue-rotate(30deg) brightness(1.4) saturate(1.8)";
          } else if (ultra) {
            c.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
          } else if (this.isFast) {
            c.filter = "hue-rotate(45deg) brightness(1.2)";
          }

          if (flickerActive) {
            c.globalAlpha = 0.5;
            c.filter =
              (c.filter ? c.filter + " " : "") +
              "brightness(0.7) contrast(0.9)";
          }

          c.drawImage(this.sprite, 0, 0, this.width, this.height);
          c.restore();
        }
        getBounds() {
          if (this.width == null || this.height == null)
            this.calculateDimensions();
          const scale = 0.6,
            rX = (this.width * scale) / 2,
            rY = (this.height * scale) / 2;
          let cX = this.x + this.width / 2,
            cY = this.y + this.height / 2;
          const shift = this.width * 0.07;
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;
          if (movingLeft) cX -= shift;
          else cX += shift;
          return { centerX: cX, centerY: cY, radiusX: rX, radiusY: rY };
        }
        update(dt) {
          const df = dt * 60;
          if (this.isPlayer) {
            const f = Math.pow(this.friction, df);
            this.vx *= f;
            this.vy *= f;
            this.x += this.vx * df;
            this.y += this.vy * df;
            if (this.width && this.height) {
              if (this.x < 0) {
                this.x = 0;
                this.vx = 0;
              }
              if (this.y < 0) {
                this.y = 0;
                this.vy = 0;
              }
              if (this.x + this.width > WIDTH) {
                this.x = WIDTH - this.width;
                this.vx = 0;
              }
              if (this.y + this.height > HEIGHT) {
                this.y = HEIGHT - this.height;
                this.vy = 0;
              }
            }
          } else {
            const osc =
              Math.sin(performance.now() * this.oscSpd + this.oscOff) *
              this.oscAmt;
            if (!this.isJellyfish && !this.isCrab) {
              this.speedX +=
                this.accel *
                Math.sign(this.speedX) *
                df *
                (Math.abs(this.speedX) < this.maxSpd ? 1 : 0);
              if (Math.abs(this.speedX) > this.maxSpd)
                this.speedX = Math.sign(this.speedX) * this.maxSpd;
              this.x += this.speedX * df;
              this.y += osc * df;
            }
          }
        }
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 50) return;
          this.lastTrailTime = now;
          const movingLeft = this.isPlayer ? this.facingLeft : this.speedX < 0;
          const speed = this.isPlayer
            ? Math.hypot(this.vx, this.vy)
            : Math.abs(this.speedX);
          if (speed > 0.5) {
            const ultra =
              this.isUltraFast || (this.isPlayer && playerIsPoweredUp);
            const count = ultra ? 3 : Math.random() < 0.3 ? 2 : 1;
            for (let i = 0; i < count; i++)
              waterTrails.push(
                new WaterTrail(
                  this.x + (movingLeft ? this.width : 0),
                  this.y + this.height * 0.5,
                  movingLeft ? 1 : -1,
                  this.maxSide,
                  ultra
                )
              );
          }
        }
      }

      /* ---- Crab ---- */
      class Crab extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, 0, crabImg, size, false);
          this.isCrab = true;
          this.entered = false;
          this.timeAlive = 0;
        }
        update(dt, player) {
          const df = dt * 60;
          if (!this.entered) {
            this.y -= 2 * df;
            if (this.y + this.height <= HEIGHT) this.entered = true;
            return;
          }
          this.timeAlive += dt;
          if (this.timeAlive > 15) {
            spawnExplosion(this);
            this.maxSide = 0;
            return;
          }
          const c = this.getBounds(),
            p = player.getBounds();
          const dx = p.centerX - c.centerX,
            dy = p.centerY - c.centerY,
            dist = Math.hypot(dx, dy) || 1;
          const s = 1.5;
          if (c.radiusX > p.radiusX) {
            this.x += (dx / dist) * s * df;
            this.y += (dy / dist) * s * df;
          } else {
            this.x -= (dx / dist) * s * df;
            this.y -= (dy / dist) * s * df;
          }
          if (this.width && this.height) {
            this.x = Math.min(Math.max(0, this.x), WIDTH - this.width);
            this.y = Math.min(Math.max(0, this.y), HEIGHT - this.height);
          }
        }
      }

      /* ---- Jellyfish ---- */
      class Jellyfish extends Fish {
        constructor(x, y, size) {
          super(x, y, 0, -1.2, jellyfishImg, size, false);
          this.isJellyfish = true;
          this.oscS = getRandom(0.0008, 0.0015);
          this.oscA = getRandom(10, 15);
          this.oscO = Math.random() * Math.PI * 2;
          this.baseX = x;
          this.vSpeed = getRandom(0.5, 1.2);
        }
        update(dt) {
          const df = dt * 60;
          this.y -= this.vSpeed * df;
          this.x =
            this.baseX +
            Math.sin(performance.now() * this.oscS + this.oscO) * this.oscA;
          if (this.y + this.height < -50) this.maxSide = 0;
        }
        /* NEW: poison trail */
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 80) return;
          this.lastTrailTime = now;
          waterTrails.push(
            new WaterTrail(
              this.x + this.width / 2,
              this.y + this.height,
              0,
              this.maxSide * 0.4,
              false,
              { r: 120, g: 0, b: 0 } // dark-red poison colour
            )
          );
        }
      }

      /* ---- Electric Jellyfish ---- */
      class ElectricJellyfish extends Jellyfish {
        constructor(x, y, size) {
          super(x, y, size);
          this.sprite = electricJellyfishImg; /* NEW sprite */
          this.isElectric = true;
          this.pulseCooldown = getRandom(5, 12); // seconds until first pulse
          this.pauseTimeRemaining = 0; // while pulsing, no movement
          this.pulseRadius = size * 2.3;
        }
        update(dt) {
          // During pulse: stay still and decrement pause timer
          if (this.pauseTimeRemaining > 0) {
            this.pauseTimeRemaining -= dt;
            if (this.pauseTimeRemaining <= 0) {
              /* pulse finished ‚Üí adjust baseX so that the oscillation resumes without a visual jump */
              const phase = Math.sin(performance.now() * this.oscS + this.oscO);
              this.baseX = this.x - phase * this.oscA;
              this.pulseCooldown = getRandom(5, 12);
            }
            return; // skip normal movement while pulsing
          }

          // Countdown to next pulse
          this.pulseCooldown -= dt;
          if (this.pulseCooldown <= 0) {
            this.performPulse();
            return;
          }

          // Normal upward drift
          super.update(dt);
        }
        performPulse() {
          this.pauseTimeRemaining = 1; // 1-second pulse animation
          playElectricSound();
          // Check if player is within pulse radius
          const p = player.getBounds();
          const b = this.getBounds();
          const dx = p.centerX - b.centerX;
          const dy = p.centerY - b.centerY;
          const dist = Math.hypot(dx, dy);
          if (dist <= this.pulseRadius) {
            playerParalyzeTime = PARALYZE_DURATION;
            playShockSound(); /* NEW */
          }
        }
        draw(c) {
          /* 1) render the sprite itself ----------------------------- */
          super.draw(c);

          /* 2) render the lightning pulse while the jellyfish is ‚Äúhot‚Äù */
          if (this.pauseTimeRemaining > 0 && this.width && this.height) {
            const alpha = this.pauseTimeRemaining; // 1 ‚Üí 0
            const cx = this.x + this.width / 2;
            const cy = this.y + this.height / 2;
            const maxLen = this.pulseRadius * (1 - alpha * 0.25); // slight shrink
            const bolts = 10; // how many rays
            const segmentsPerBolt = 3; // jaggedness

            /* draw each bolt */
            for (let i = 0; i < bolts; i++) {
              const baseAngle = (i / bolts) * Math.PI * 2;

              /* build the zig-zag path one segment at a time */
              let prevX = cx,
                prevY = cy;
              for (let s = 1; s <= segmentsPerBolt; s++) {
                const segLen = (maxLen / segmentsPerBolt) * s;
                const jitter = segLen * 0.25; // random wobble
                const angle = baseAngle + getRandom(-0.2, 0.2); // ¬± a little
                const x =
                  cx + Math.cos(angle) * segLen + getRandom(-jitter, jitter);
                const y =
                  cy + Math.sin(angle) * segLen + getRandom(-jitter, jitter);

                /* stroke that segment */
                c.save();
                c.beginPath();
                c.moveTo(prevX, prevY);
                c.lineTo(x, y);
                c.strokeStyle = `rgba(255,255,0,${alpha})`;
                c.lineWidth = 2;
                c.shadowBlur = 8;
                c.shadowColor = `rgba(255,255,0,${alpha})`;
                c.stroke();
                c.restore();

                prevX = x;
                prevY = y;
              }
            }
          }
        }
        /* NEW: spark trail */
        createWaterTrail() {
          if (!this.width || !this.height) return;
          const now = performance.now();
          if (now - this.lastTrailTime < 80) return;
          this.lastTrailTime = now;
          waterTrails.push(
            new WaterTrail(
              this.x + this.width / 2,
              this.y + this.height,
              0,
              this.maxSide * 0.4,
              false,
              { r: 255, g: 255, b: 0 } // yellow spark colour
            )
          );
        }
      }

      /* ---- Sushi ---- */
      class Sushi extends Fish {
        constructor(x, y, speedX) {
          super(x, y, speedX, 0, sushiImg, 30, false);
          this.isSushi = true;
        }
      }

      /* ---- Pufferfish ---- */
      class Pufferfish extends Fish {
        constructor(x, y, speedX, baseSize) {
          super(x, y, speedX, 0, pufferImg, baseSize, false);
          this.isPuffer = true;
          this.baseSize = baseSize;
          this.inflating = false;
          this.inflateStart = 0;
          this.inflateDuration = 500;
        }
        update(dt) {
          super.update(dt);
          if (!this.inflating && this.maxSide < this.baseSize * 2.9) {
            if (Math.random() < 0.0003 * dt * 60) {
              this.inflating = true;
              this.inflateStart = performance.now();
            }
          }
          if (this.inflating) {
            const elapsed = performance.now() - this.inflateStart;
            const p = Math.min(elapsed / this.inflateDuration, 1);
            const centreX = this.x + (this.width ?? this.maxSide) / 2;
            const centreY = this.y + (this.height ?? this.maxSide) / 2;
            this.maxSide = this.baseSize * (1 + 3 * p);
            this.width = this.height = null;
            this.calculateDimensions();
            this.x = centreX - this.width / 2;
            this.y = centreY - this.height / 2;
            if (p === 1) this.inflating = false;
          }
        }
      }

      /* ---- Bubble & Explosion ---- */
      class Bubble {
        constructor(baseX) {
          this.baseX = baseX;
          this.x = this.baseX + getRandom(-10, 10);
          this.y = HEIGHT + 20;
          this.size = getRandom(3, 8);
          this.speed = getRandom(2, 3.5);
          this.opacity = getRandom(0.2, 0.4);
          this.wobbleAmount = getRandom(0.1, 0.3);
          this.wobbleSpeed = getRandom(0.02, 0.05);
          this.wobbleOffset = getRandom(0, Math.PI * 2);
        }
        update(dt) {
          this.y -= this.speed * dt * 60;
          this.x +=
            Math.sin(this.wobbleOffset + performance.now() * this.wobbleSpeed) *
            this.wobbleAmount *
            dt *
            60;
        }
        draw(c) {
          c.beginPath();
          c.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          c.fillStyle = `rgba(255,255,255,${this.opacity})`;
          c.fill();
        }
      }

      class Explosion {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.particles = [];
          this.life = 1;
          this.fadeSpeed = 0.02;
          this.isComplete = false;
          const n = Math.floor(size * 0.5);
          for (let i = 0; i < n; i++) {
            const angle = (i / n) * Math.PI * 2,
              spd = getRandom(2, 4);
            this.particles.push({
              x: 0,
              y: 0,
              sx: Math.cos(angle) * spd,
              sy: Math.sin(angle) * spd,
              size: getRandom(3, 8),
              life: 1,
              fadeSpeed: getRandom(0.01, 0.03),
            });
          }
        }
        update(dt) {
          if (this.isComplete) return;
          this.life -= this.fadeSpeed * dt * 60;
          for (const p of this.particles) {
            p.x += p.sx * dt * 60;
            p.y += p.sy * dt * 60;
            p.life -= p.fadeSpeed * dt * 60;
          }
          if (this.life <= 0) this.isComplete = true;
        }
        draw(c) {
          if (this.life <= 0) return;
          for (const p of this.particles) {
            if (p.life <= 0) continue;
            c.beginPath();
            c.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
            c.fillStyle = `rgba(255,255,255,${p.life * 0.8})`;
            c.fill();
          }
        }
      }

      /*********************      SPAWNERS      *****************************/
      function spawnExplosion(f) {
        if (f.width && f.height)
          explosion = new Explosion(
            f.x + f.width / 2,
            f.y + f.height / 2,
            f.maxSide
          );
      }
      function spawnFish() {
        const t = getRandomWeightedFishType(fishTypes);
        const size = getRandom(t.minSize, t.maxSize);
        const fromLeft = Math.random() < 0.5;
        const x = fromLeft ? -size : WIDTH,
          y = getRandom(0, HEIGHT - size);
        const sizeFactor = 1 - size / 500;
        const minSpd = 0.3 + 0.5 * sizeFactor,
          maxSpd = 1.5 + 0.3 * sizeFactor;
        const difficulty = Math.min(score / 1000, 1),
          spdMultiplier = 0.4 + 0.6 * difficulty;
        let spd = getRandom(minSpd, maxSpd) * spdMultiplier;
        const ultra = Math.random() < 0.01,
          fast = !ultra && Math.random() < 0.03;
        if (ultra) spd *= 5;
        else if (fast) spd *= 3;
        const fish = new Fish(x, y, fromLeft ? spd : -spd, 0, t.image, size);
        fish.isFast = fast;
        fish.isUltraFast = ultra;
        fishList.push(fish);
      }
      function spawnCrab() {
        const size = getRandom(50, 120);
        const crab = new Crab(getRandom(0, WIDTH - size), HEIGHT + size, size);
        fishList.push(crab);
      }
      function spawnJellyfish() {
        const size = getRandom(30, 80);
        fishList.push(
          new Jellyfish(getRandom(0, WIDTH - size), HEIGHT + size, size)
        );
      }
      function spawnElectricJellyfish() {
        const size = getRandom(40, 90);
        fishList.push(
          new ElectricJellyfish(getRandom(0, WIDTH - size), HEIGHT + size, size)
        );
      }
      function spawnSushi() {
        const size = 30,
          fromLeft = Math.random() < 0.5,
          x = fromLeft ? -size : WIDTH,
          y = getRandom(0, HEIGHT - size),
          spd = (fromLeft ? 1 : -1) * 1.5;
        fishList.push(new Sushi(x, y, spd));
      }
      function spawnPufferfish() {
        const baseSize = getRandom(30, 60),
          fromLeft = Math.random() < 0.5,
          x = fromLeft ? -baseSize : WIDTH,
          y = getRandom(0, HEIGHT - baseSize),
          spd = getRandom(0.2, 1.2) * (fromLeft ? 1 : -1);
        fishList.push(new Pufferfish(x, y, spd, baseSize));
      }

      /* ---------------- MOD: dynamic max enemies ---------------- */
      function currentMaxEnemies() {
        return score < 1000 ? 20 : 30;
      }
      /* ---------------------------------------------------------- */

      /* bubble groups */
      function spawnBubbleGroup() {
        const n = Math.floor(getRandom(3, 6)),
          baseX = getRandom(50, WIDTH - 50);
        for (let i = 0; i < n; i++) bubbles.push(new Bubble(baseX));
      }
      let bubbleTimer = 0;
      const BUBBLE_INTERVAL = 20;

      /*********************     ROUND RESET     ****************************/
      function resetRound() {
        fishList = [];
        bubbles = [];
        waterTrails = [];
        explosion = null;
        player.maxSide = 25;
        player.width = player.height = null;
        player.x = WIDTH / 2;
        player.y = HEIGHT / 2;
        player.vx = player.vy = 0;
        playerPowerUpTime = 0;
        playerIsPoweredUp = false;
        playerParalyzeTime = 0;
        for (let i = 0; i < 3; i++) spawnFish();
        spawnBubbleGroup();
        bubbleTimer = 0;
      }

      /*********************      GAME LOGIC      ***************************/
      function checkCollisionOval(a, b) {
        const A = a.getBounds(),
          B = b.getBounds(),
          dx = A.centerX - B.centerX,
          dy = A.centerY - B.centerY;
        return (
          (dx * dx) / (A.radiusX + B.radiusX) ** 2 +
            (dy * dy) / (A.radiusY + B.radiusY) ** 2 <=
          1
        );
      }

      function updateGame(dt) {
        if (explosion) {
          explosion.update(dt);
          if (explosion.isComplete) {
            explosion = null;
            if (isGameOver) showGameOverScreen(score);
          }
        }
        if (gameState !== "playing") return;
        if (isGameOver && !explosion) return;
        gameTime += dt;

        if (playerPowerUpTime > 0) {
          playerPowerUpTime -= dt;
          if (playerPowerUpTime <= 0) {
            playerPowerUpTime = 0;
            playerIsPoweredUp = false;
          }
        }

        if (playerParalyzeTime > 0) {
          playerParalyzeTime -= dt;
          if (playerParalyzeTime < 0) playerParalyzeTime = 0;
        }

        /* ----- bubbles ----- */
        for (let i = bubbles.length - 1; i >= 0; i--) {
          bubbles[i].update(dt);
          if (bubbles[i].y < -20) bubbles.splice(i, 1);
        }
        bubbleTimer += dt;
        if (bubbleTimer >= BUBBLE_INTERVAL) {
          spawnBubbleGroup();
          bubbleTimer = 0;
        }

        /* ----- water trails ----- */
        for (let i = waterTrails.length - 1; i >= 0; i--) {
          waterTrails[i].update(dt);
          if (waterTrails[i].life <= 0) waterTrails.splice(i, 1);
        }

        /* ----- player input ----- */
        const canMove = playerParalyzeTime <= 0;
        const a = player.accel * dt * 60;
        if (canMove) {
          if (keys.left) player.vx -= a;
          if (keys.right) player.vx += a;
          if (keys.up) player.vy -= a;
          if (keys.down) player.vy += a;

          if (touchTarget && player.width && player.height) {
            const px = player.x + player.width / 2,
              py = player.y + player.height / 2,
              dx = touchTarget.x - px,
              dy = touchTarget.y - py,
              dist = Math.hypot(dx, dy);
            if (dist > 1) {
              const ax = (dx / dist) * a,
                ay = (dy / dist) * a;
              player.vx += ax;
              player.vy += ay;
            }
          }
        }
        // If paralyzed, no new input is applied; the fish just glides and slows via friction.

        const spd = Math.hypot(player.vx, player.vy);
        if (spd > player.maxSpd) {
          const r = player.maxSpd / spd;
          player.vx *= r;
          player.vy *= r;
        }

        player.update(dt);
        player.createWaterTrail();

        /* ----- enemies & collisions ----- */
        for (let i = fishList.length - 1; i >= 0; i--) {
          const e = fishList[i];
          if (e instanceof ElectricJellyfish) e.update(dt);
          else if (e.isCrab) e.update(dt, player);
          else e.update(dt);
          e.createWaterTrail();

          const b = e.getBounds();
          if (
            e.maxSide <= 0 ||
            b.centerX + b.radiusX < -200 ||
            b.centerX - b.radiusX > WIDTH + 200 ||
            e.y > HEIGHT + 200
          ) {
            fishList.splice(i, 1);
            continue;
          }

          if (checkCollisionOval(player, e)) {
            /* sushi == power-up */
            if (e.isSushi) {
              score += 50;
              playerPowerUpTime = POWER_UP_DURATION;
              playerIsPoweredUp = true;
              playPowerUpSound();
              fishList.splice(i, 1);
              continue;
            }

            /* ---------- Player IS powered-up ---------- */
            if (playerIsPoweredUp) {
              score += calculateFishScore(e.maxSide);

              if (e.isJellyfish && !e.isElectric) {
                /* regular jellyfish ‚Üí shrink */
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                /* any other fish (including electric jelly) ‚Üí grow */
                player.maxSide += Math.min(Math.sqrt(e.maxSide) * 0.05, 1.5);
                playEatSound();
              }

              /* Special case: electric jellyfish causes paralysis when eaten */
              if (e.isElectric) {
                playerParalyzeTime = PARALYZE_DURATION;
                playShockSound();
              }

              player.width = player.height = null;
              if (e.isUltraFast) {
                playerPowerUpTime = POWER_UP_DURATION;
                playerIsPoweredUp = true;
                playPowerUpSound();
              }
              fishList.splice(i, 1);
              continue;
            }

            /* ---------- Player is NOT powered-up ---------- */

            const pR = player.getBounds().radiusX,
              eR = e.getBounds().radiusX;
            if (pR * EATING_LEEWAY > eR) {
              /* player eats the fish */
              score += calculateFishScore(e.maxSide);

              if (e.isJellyfish && !e.isElectric) {
                /* regular jellyfish ‚Üí shrink */
                player.maxSide = Math.max(
                  player.maxSide * JELLY_SHRINK_FACTOR,
                  MIN_PLAYER_SIZE
                );
                playShrinkSound();
              } else {
                /* other fish (including electric) ‚Üí grow */
                player.maxSide += Math.min(Math.sqrt(e.maxSide) * 0.05, 1.5);
                playEatSound();
              }

              /* electric jellyfish paralyses the player */
              if (e.isElectric) {
                playerParalyzeTime = PARALYZE_DURATION;
                playShockSound();
              }

              player.width = player.height = null;
              if (e.isUltraFast) {
                playerPowerUpTime = POWER_UP_DURATION;
                playerIsPoweredUp = true;
                playPowerUpSound();
              }
              fishList.splice(i, 1);
            } else {
              /* player gets eaten */
              isGameOver = true;
              gameState = "over";
              sendScoreToAPI(score);
              explosion = new Explosion(
                player.x + (player.width ?? player.maxSide) / 2,
                player.y + (player.height ?? player.maxSide) / 2,
                player.maxSide
              );
              touchTarget = null;
              return;
            }
          }
        }

        /* -------------------- SPAWNING -------------------- */
        const maxEnemies = currentMaxEnemies(); // MOD: dynamic limit
        if (Math.random() < 0.03 * dt * 60 && fishList.length < maxEnemies)
          spawnFish();
        if (
          score >= 2000 /* MOD: crabs only after 2000 points */ &&
          Math.random() < 0.00005 * dt * 60 &&
          fishList.length < maxEnemies
        )
          spawnCrab();
        if (Math.random() < 0.001 * dt * 60 && fishList.length < maxEnemies)
          spawnJellyfish();
        if (Math.random() < 0.0005 * dt * 60 && fishList.length < maxEnemies)
          spawnElectricJellyfish();
        if (Math.random() < 0.0005 * dt * 60 && fishList.length < maxEnemies)
          spawnSushi();
        if (Math.random() < 0.002 * dt * 60 && fishList.length < maxEnemies)
          spawnPufferfish();
        /* --------------------------------------------------- */

        if (score >= nextMilestone) {
          playAchvSound();
          resetRound();
          while (score >= nextMilestone) nextMilestone += 100000;
        }
      }

      /*********************      RENDERING       ***************************/
      function renderGame() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        bubbles.forEach((b) => b.draw(ctx));
        waterTrails.forEach((t) => t.draw(ctx));
        if (player && !(isGameOver && explosion)) player.draw(ctx);
        fishList.forEach((f) => f.draw(ctx));
        if (explosion) explosion.draw(ctx);
        ctx.fillStyle = playerParalyzeTime > 0 ? "#ffea00" : "#fff";
        ctx.font = "20px 'Londrina Solid',sans-serif";
        ctx.fillText("Score: " + score, 20, 30);
        if (touchTarget) {
          ctx.beginPath();
          ctx.arc(touchTarget.x, touchTarget.y, 15, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffffff88";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        if (playerParalyzeTime > 0) {
          ctx.font = "16px 'Poppins',sans-serif";
          ctx.fillStyle = "#ffea00";
          ctx.fillText(`Paralyzed: ${playerParalyzeTime.toFixed(1)}s`, 20, 55);
        }
      }

      /*********************   GAME & SIM LOOPS    **************************/
      /* ---- SIMULATION LOOP ---- */
      let lastSimTime = performance.now();
      const MAX_DT = 0.1,
        SIM_STEP_MS = 16; // cap & 60 Hz
      function simLoop() {
        const now = performance.now();
        let dt = (now - lastSimTime) / 1000;
        if (dt > MAX_DT) dt = MAX_DT;
        lastSimTime = now;
        updateGame(dt);
      }
      setInterval(simLoop, SIM_STEP_MS);

      /* ---- RENDER LOOP ---- */
      function gameLoop() {
        renderGame();
        requestAnimationFrame(gameLoop);
      }

      /*********************        INIT          ***************************/
      function initGame() {
        resizeCanvas();
        lastSimTime = performance.now(); // reset sim-timer for fresh round
        score = 0;
        nextMilestone = 100000;
        gameTime = 0;
        gameStartTime = performance.now();
        isGameOver = false;
        fishList = [];
        bubbles = [];
        waterTrails = [];
        explosion = null;
        player = new Fish(WIDTH / 2, HEIGHT / 2, 0, 0, playerImg, 25, true);
        playerPowerUpTime = 0;
        playerIsPoweredUp = false;
        playerParalyzeTime = 0;
        clearKeys();
        initAudio();
        for (let i = 0; i < 3; i++) spawnFish();
        spawnBubbleGroup();
        bubbleTimer = 0;
        updateMusicButtons();
        updateSfxButtons();
      }

      /*********************      UI EVENTS       ***************************/
      const showOrHideArrowKeys = (show) => {
        controlsContainer.style.display = show ? "flex" : "none";
        const txt = show ? "üéÆ Arrow Keys On" : "üéÆ Arrow Keys Off";
        arrowKeysBtn.textContent = txt;
        arrowKeysBtnGameOver.textContent = txt;
        if (!show) clearKeys();
      };
      const syncGameOverUI = () => {
        showOrHideArrowKeys(controlsContainer.style.display !== "none");
        updateMusicButtons();
        updateSfxButtons();
      };

      startBtn.onclick = () => {
        hideStartScreen();
        showOrHideArrowKeys(arrowKeysBtn.textContent.includes("On"));
        gameState = "playing";
        initGame();
      };
      playAgainBtn.onclick = () => {
        hideGameOverScreen();
        showOrHideArrowKeys(arrowKeysBtnGameOver.textContent.includes("On"));
        gameState = "playing";
        initGame();
      };
      musicBtn.onclick = toggleMusic;
      musicBtnGameOver.onclick = toggleMusic;
      sfxBtn.onclick = toggleSFX;
      sfxBtnGameOver.onclick = toggleSFX;
      arrowKeysBtn.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");
      arrowKeysBtnGameOver.onclick = () =>
        showOrHideArrowKeys(controlsContainer.style.display === "none");

      /* ----------   NEW: pointer-based on-screen controls   ---------- */
      setupArrowButton(arrowUp, "up");
      setupArrowButton(arrowDown, "down");
      setupArrowButton(arrowLeft, "left");
      setupArrowButton(arrowRight, "right");

      /* ----------   HARDWARE KEYBOARD   ---------- */
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = true;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });

      /* ----------   TOUCH / MOUSE AIMING   ---------- */
      canvas.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        if (t) {
          const r = canvas.getBoundingClientRect();
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchmove", (e) => {
        const t = e.touches[0];
        if (t) {
          const r = canvas.getBoundingClientRect();
          touchTarget = { x: t.clientX - r.left, y: t.clientY - r.top };
        }
      });
      canvas.addEventListener("touchend", () => {
        touchTarget = null;
      });
      canvas.addEventListener("mousedown", (e) => {
        const r = canvas.getBoundingClientRect();
        touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
      });
      canvas.addEventListener("mousemove", (e) => {
        if (e.buttons > 0) {
          const r = canvas.getBoundingClientRect();
          touchTarget = { x: e.clientX - r.left, y: e.clientY - r.top };
        }
      });
      canvas.addEventListener("mouseup", () => {
        touchTarget = null;
      });

      /*********************    SAFETY: CLEAR KEYS ON BLUR   **************************/
      window.addEventListener("blur", clearKeys);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) clearKeys();
      });

      /*********************    PRELOAD & BOOT     **************************/
      Promise.all([
        new Promise((r) => (playerImg.onload = r)),
        ...fishTypes.map(({ image }) => new Promise((r) => (image.onload = r))),
        new Promise((r) => (crabImg.onload = r)),
        new Promise((r) => (jellyfishImg.onload = r)),
        new Promise((r) => (electricJellyfishImg.onload = r)) /* NEW */,
        new Promise((r) => (sushiImg.onload = r)),
        new Promise((r) => (pufferImg.onload = r)),
      ]).then(() => {
        resizeCanvas();
        showStartScreen();
        initAudio();
        startScreen.addEventListener("click", function first() {
          startAudio();
          startScreen.removeEventListener("click", first);
        });
        document.addEventListener("mousemove", function first() {
          startAudio();
          document.removeEventListener("mousemove", first);
        });
        requestAnimationFrame(gameLoop); /* kick-off renderer */
      });
    </script>
  </body>
</html>
