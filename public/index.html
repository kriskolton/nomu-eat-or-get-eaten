<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <title>Nomu: Eat or Get Eaten</title>

    <!-- Load Londrina Solid from Google Fonts -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Londrina+Solid&display=swap"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Add audio elements -->
    <audio id="backgroundMusic" loop>
      <source src="sounds/background.mp3" type="audio/mpeg" />
    </audio>
    <audio id="eatSound">
      <source src="sounds/eat.mp3" type="audio/mpeg" />
    </audio>
    <audio id="gameOverSound">
      <source src="sounds/gameover.mp3" type="audio/mpeg" />
    </audio>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
      /* Apply Londrina Solid globally (you can also specify body, .overlay, etc.) */
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: "Londrina Solid", sans-serif; /* Use our new font */
      }

      body {
        background: #222 url("img/bg.jpg") center center no-repeat;
        background-size: cover;
        overflow: hidden;
        user-select: none;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative; /* allows overlays to be "position: absolute" */
      }

      /* Game canvas */
      #gameCanvas {
        display: block;
        background: transparent;
        touch-action: none;
        max-width: 100%;
        max-height: 100%;
      }

      /* Overlays (start screen & game over) */
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999; /* on top of the canvas */
      }
      .hidden {
        display: none;
      }
      .overlay h1,
      .overlay button,
      .overlay p {
        color: #fff;
        margin: 8px;
      }
      .overlay button {
        font-size: 18px;
        font-weight: bold;
        color: #fff;
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 40px;
        background-color: #f78719;
        font-family: "Londrina Solid", sans-serif;
      }
      p {
        font-family: "Poppins", sans-serif;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <!-- Start Screen Overlay -->
    <div id="startScreen" class="overlay" style="text-align: center">
      <img
        src="img/title.png"
        alt="Eat or Get Eaten"
        style="max-width: 90%; height: auto; padding: 12px"
      />
      <div
        id="telegramStatus"
        style="
          color: white;
          font-family: 'Poppins', sans-serif;
          max-width: 90%;
          margin-bottom: 24px;
        "
      ></div>
      <p style="font-size: 24px; font-weight: bold; letter-spacing: 1px">
        Rules
      </p>
      <p>
        Use the touch screen or arrow keys (‚Üë‚Üí‚Üì‚Üê) to control Nomu. Eat the
        smaller fish to grow. Don't let the bigger fish eat you!
      </p>
      <p>The larger the fish the more points you get.</p>
      <p>You high score is <span id="highScore">0</span>.</p>
      <button id="startBtn">Start Game</button>
      <button id="soundBtn" style="margin-top: 12px">üîä Sound On</button>
    </div>

    <!-- Game Over Overlay -->
    <div id="gameOverScreen" class="overlay hidden">
      <h1>GAME OVER!</h1>
      <p id="finalScore"></p>
      <button id="playAgainBtn">Play Again</button>
    </div>

    <script>
      console.log("Script started executing");

      // Initialize Telegram Web App
      let tg;
      let userData;
      let userId;

      try {
        tg = window.Telegram.WebApp;
        console.log("Telegram WebApp object:", tg);

        if (!tg) {
          throw new Error("Telegram WebApp object not found");
        }

        userData = tg.initDataUnsafe?.user;
        console.log("Telegram user data:", userData);

        if (!userData) {
          throw new Error("No user data available");
        }

        userId = userData.id;
        console.log("Telegram user ID:", userId);

        tg.expand(); // Expand the web app to full screen
      } catch (error) {
        console.error("Telegram initialization error:", error);
      }

      // Update status display
      const statusDiv = document.getElementById("telegramStatus");
      if (userId) {
        statusDiv.textContent = `Telegram connected ‚úì (User: ${
          userData?.username || userData?.first_name || "Anonymous"
        })`;
        statusDiv.style.color = "lightgreen";
      } else {
        statusDiv.textContent =
          "‚ö†Ô∏è Not tracking scores - Please access via Telegram bot";
        statusDiv.style.color = "red";
      }

      // For sending score to your API
      async function sendScoreToAPI(score) {
        if (!userId) {
          console.error("Cannot send score: No Telegram user ID available");
          return;
        }
        console.log("Attempting to send score:", {
          userId,
          username: userData?.username || userData?.first_name || "Anonymous",
          score,
        });
        try {
          const response = await fetch("/api/scores", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              userId: userId,
              username:
                userData?.username || userData?.first_name || "Anonymous",
              score: score,
            }),
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error(
              "Failed to send score. Status:",
              response.status,
              "Error:",
              errorText
            );
            throw new Error(`Failed to send score: ${errorText}`);
          }
          const result = await response.json();
          console.log("Score sent successfully:", result);
        } catch (error) {
          console.error("Error sending score:", error);
        }
      }

      // Canvas setup
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high"; // options: "low", "medium", "high"

      let WIDTH = 800; // nominal design width
      let HEIGHT = 600; // nominal design height

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        WIDTH = canvas.width;
        HEIGHT = canvas.height;
      }
      window.addEventListener("resize", resizeCanvas);

      // Overlays
      const startScreen = document.getElementById("startScreen");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const startBtn = document.getElementById("startBtn");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const finalScoreElem = document.getElementById("finalScore");

      function showStartScreen() {
        startScreen.classList.remove("hidden");
      }
      function hideStartScreen() {
        startScreen.classList.add("hidden");
      }
      function showGameOverScreen(score) {
        finalScoreElem.textContent = `Your Score: ${score}`;
        gameOverScreen.classList.remove("hidden");
        // Play game over sound when the screen appears
        playGameOverSound();
      }
      function hideGameOverScreen() {
        gameOverScreen.classList.add("hidden");
      }

      // Game states
      let gameState = "start";
      let isGameOver = false;

      // Weighted fish definitions
      const fishTypeDefinitions = [
        { src: "img/fish1.png", minSize: 10, maxSize: 40, weight: 0.43 },
        { src: "img/fish2.png", minSize: 20, maxSize: 60, weight: 0.25 },
        { src: "img/fish3.png", minSize: 25, maxSize: 80, weight: 0.2 },
        { src: "img/fish4.png", minSize: 35, maxSize: 100, weight: 0.1 },
        { src: "img/fish6.png", minSize: 200, maxSize: 300, weight: 0.015 },
        { src: "img/fish5.png", minSize: 400, maxSize: 500, weight: 0.005 },
      ];

      // Preload fish images
      const fishTypes = fishTypeDefinitions.map((def) => {
        const image = new Image();
        image.src = def.src;
        return {
          image,
          minSize: def.minSize,
          maxSize: def.maxSize,
          weight: def.weight,
        };
      });

      // Load player image
      const playerImg = new Image();
      playerImg.src = "img/player_fish.png";

      // Game variables
      let fishList = [];
      let score = 0;
      let player;
      let touchTarget = null;
      const keys = { left: false, right: false, up: false, down: false };
      let bubbles = [];
      let waterTrails = [];
      let backgroundMusic;
      let eatSound;
      let gameOverSound;
      let isSoundEnabled = true;
      let explosion = null; // Explosion for player death effect

      // Initialize audio
      function initAudio() {
        backgroundMusic = document.getElementById("backgroundMusic");
        eatSound = document.getElementById("eatSound");
        gameOverSound = document.getElementById("gameOverSound");

        // Set volume levels
        backgroundMusic.volume = 0.3;
        eatSound.volume = 0.5;
        gameOverSound.volume = 0.5;
      }

      // Start audio playback
      function startAudio() {
        if (backgroundMusic && isSoundEnabled) {
          try {
            backgroundMusic.play();
          } catch (error) {
            console.log("Audio playback failed:", error);
          }
        }
      }

      // Toggle sound
      function toggleSound() {
        isSoundEnabled = !isSoundEnabled;
        if (backgroundMusic) {
          if (isSoundEnabled) {
            startAudio();
            backgroundMusic.volume = 0.3;
            eatSound.volume = 0.5;
            gameOverSound.volume = 0.5;
          } else {
            backgroundMusic.pause();
            backgroundMusic.volume = 0;
            eatSound.volume = 0;
            gameOverSound.volume = 0;
          }
        }
        // Update button text
        const soundBtn = document.getElementById("soundBtn");
        if (soundBtn) {
          soundBtn.textContent = isSoundEnabled
            ? "üîä Sound On"
            : "üîà Sound Off";
        }
      }

      // Play eat sound
      function playEatSound() {
        if (!isSoundEnabled) return;
        eatSound.currentTime = 0;
        try {
          eatSound.play();
        } catch (error) {
          console.log("Eat sound playback failed:", error);
        }
      }

      // Play game over sound
      function playGameOverSound() {
        if (!isSoundEnabled) return;
        gameOverSound.currentTime = 0;
        try {
          gameOverSound.play();
        } catch (error) {
          console.log("Game over sound playback failed:", error);
        }
      }

      // Utility
      function getRandom(min, max) {
        return Math.random() * (max - min) + min;
      }
      function calculateFishScore(fishSize) {
        return Math.floor(fishSize);
      }
      function getRandomWeightedFishType(fishTypes) {
        const totalWeight = fishTypes.reduce((sum, ft) => sum + ft.weight, 0);
        let randomVal = Math.random() * totalWeight;
        for (const ft of fishTypes) {
          if (randomVal < ft.weight) {
            return ft;
          }
          randomVal -= ft.weight;
        }
        return fishTypes[fishTypes.length - 1];
      }

      // ---------------------------------------------
      // WaterTrail class for movement effects
      // ---------------------------------------------
      class WaterTrail {
        constructor(x, y, direction, fishSize, isUltraFast = false) {
          this.x = x;
          this.y = y;
          const baseSize = Math.min(8, Math.max(2, fishSize * 0.1));
          this.size = getRandom(baseSize * 0.8, baseSize * 1.2);
          this.life = 1.0;
          this.fadeSpeed = getRandom(0.02, 0.04);
          this.direction = direction;
          const offsetScale = Math.min(3, Math.max(1, fishSize * 0.03));
          this.offsetX = getRandom(-offsetScale, offsetScale);
          this.offsetY = getRandom(-offsetScale, offsetScale);
          this.isUltraFast = isUltraFast;
          // Add neon color cycling for ultra-fast trails
          this.hue = Math.random() * 360;
          this.hueSpeed = getRandom(2, 4);
        }

        update(deltaTime) {
          this.life -= this.fadeSpeed * deltaTime * 60;
          this.x += this.direction * 0.5 * deltaTime * 60;
          if (this.isUltraFast) {
            this.hue = (this.hue + this.hueSpeed) % 360;
          }
        }

        draw(ctx) {
          if (this.life <= 0) return;

          ctx.beginPath();
          ctx.arc(
            this.x + this.offsetX,
            this.y + this.offsetY,
            this.size,
            0,
            Math.PI * 2
          );

          if (this.isUltraFast) {
            // Neon effect for ultra-fast trails
            ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, ${this.life * 0.3})`;
            ctx.shadowBlur = 10;
            ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, ${
              this.life * 0.3
            })`;
          } else {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.05})`;
          }
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      // ---------------------------------------------
      // Fish class
      // ---------------------------------------------
      class Fish {
        constructor(x, y, speedX, speedY, sprite, maxSide, isPlayer = false) {
          this.x = x;
          this.y = y;
          this.speedX = speedX;
          this.speedY = speedY;
          this.sprite = sprite;
          this.maxSide = maxSide;
          this.isPlayer = isPlayer;
          this.lastTrailTime = 0;
          this.isFast = false;
          this.isUltraFast = false; // Add ultra-fast flag

          // Add oscillation properties for enemy fish
          if (!isPlayer) {
            this.oscillationSpeed = getRandom(0.005, 0.01);
            this.oscillationAmount = getRandom(0.05, 0.1);
            this.oscillationOffset = getRandom(0, Math.PI * 2);
          }

          if (isPlayer) {
            this.velocityX = 0;
            this.velocityY = 0;
            this.acceleration = 0.055;
            this.friction = 0.99;
            this.maxSpeed = 10;
          } else {
            this.acceleration = 0.05;
            this.maxSpeed = Math.abs(speedX) * 1.2;
          }

          this.width = null;
          this.height = null;
        }

        calculateDimensions() {
          const w = this.sprite.naturalWidth;
          const h = this.sprite.naturalHeight;
          if (w === 0 || h === 0) {
            this.width = this.maxSide;
            this.height = this.maxSide;
            return;
          }
          const aspect = w / h;
          if (aspect > 1) {
            this.width = this.maxSide;
            this.height = this.maxSide / aspect;
          } else {
            this.height = this.maxSide;
            this.width = this.maxSide * aspect;
          }
        }

        draw(ctx) {
          if (!this.sprite.complete) return;
          if (this.width === null || this.height === null) {
            this.calculateDimensions();
          }
          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;

          if (isMovingLeft) {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(-1, 1);
            // Add special effects for ultra-fast fish
            if (this.isUltraFast) {
              ctx.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
            } else if (this.isFast) {
              ctx.filter = "hue-rotate(45deg) brightness(1.2)";
            }
            ctx.drawImage(
              this.sprite,
              -this.width / 2,
              -this.height / 2,
              this.width,
              this.height
            );
            ctx.restore();
          } else {
            if (this.isUltraFast) {
              ctx.save();
              ctx.filter = "hue-rotate(180deg) brightness(1.5) saturate(2)";
              ctx.drawImage(
                this.sprite,
                this.x,
                this.y,
                this.width,
                this.height
              );
              ctx.restore();
            } else if (this.isFast) {
              ctx.save();
              ctx.filter = "hue-rotate(45deg) brightness(1.2)";
              ctx.drawImage(
                this.sprite,
                this.x,
                this.y,
                this.width,
                this.height
              );
              ctx.restore();
            } else {
              ctx.drawImage(
                this.sprite,
                this.x,
                this.y,
                this.width,
                this.height
              );
            }
          }
        }

        getBounds() {
          const collisionScale = 0.6;
          const radiusX = ((this.width || 0) * collisionScale) / 2;
          const radiusY = ((this.height || 0) * collisionScale) / 2;

          let centerX = this.x + (this.width || 0) / 2;
          let centerY = this.y + (this.height || 0) / 2;

          // Shift center forward in direction of movement
          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;
          const shiftAmount = (this.width || 0) * 0.07;

          if (isMovingLeft) {
            centerX -= shiftAmount;
          } else {
            centerX += shiftAmount;
          }

          return { centerX, centerY, radiusX, radiusY };
        }

        // Update with deltaTime in seconds
        update(deltaTime) {
          const deltaFrames = deltaTime * 60; // scale to ~"per-frame" at 60fps
          if (this.isPlayer) {
            // friction
            const frictionFactor = Math.pow(this.friction, deltaFrames);
            this.velocityX *= frictionFactor;
            this.velocityY *= frictionFactor;

            // position update
            this.x += this.velocityX * deltaFrames;
            this.y += this.velocityY * deltaFrames;

            // clamp to screen
            if (this.width && this.height) {
              if (this.x < 0) {
                this.x = 0;
                this.velocityX = 0;
              }
              if (this.y < 0) {
                this.y = 0;
                this.velocityY = 0;
              }
              if (this.x + this.width > WIDTH) {
                this.x = WIDTH - this.width;
                this.velocityX = 0;
              }
              if (this.y + this.height > HEIGHT) {
                this.y = HEIGHT - this.height;
                this.velocityY = 0;
              }
            }
          } else {
            // Add horizontal oscillation for enemy fish
            const oscillation =
              Math.sin(
                performance.now() * this.oscillationSpeed +
                  this.oscillationOffset
              ) * this.oscillationAmount;

            // accelerate horizontal speed until max
            if (Math.abs(this.speedX) < this.maxSpeed) {
              this.speedX +=
                this.acceleration * Math.sign(this.speedX) * deltaFrames;
            }
            this.x += this.speedX * deltaFrames;
            this.y += oscillation * deltaFrames;
          }
        }

        // Add method to create water trails
        createWaterTrail() {
          if (!this.width || !this.height) return;

          const now = performance.now();
          if (now - this.lastTrailTime < 50) return;
          this.lastTrailTime = now;

          const isMovingLeft = this.isPlayer
            ? this.velocityX < 0
            : this.speedX < 0;
          const speed = this.isPlayer
            ? Math.sqrt(
                this.velocityX * this.velocityX +
                  this.velocityY * this.velocityY
              )
            : Math.abs(this.speedX);

          // Only create trails if moving fast enough
          if (speed > 0.5) {
            // Create more trails for ultra-fast fish
            const count = this.isUltraFast ? 3 : Math.random() < 0.3 ? 2 : 1;
            for (let i = 0; i < count; i++) {
              waterTrails.push(
                new WaterTrail(
                  this.x + (isMovingLeft ? this.width : 0),
                  this.y + this.height * 0.5,
                  isMovingLeft ? 1 : -1,
                  this.maxSide,
                  this.isUltraFast
                )
              );
            }
          }
        }
      }

      // ---------------------------------------------
      // Bubble class for decorative bubbles
      // ---------------------------------------------
      class Bubble {
        constructor(baseX) {
          this.reset(baseX);
        }

        reset(baseX) {
          this.x = baseX + getRandom(-10, 10);
          this.y = HEIGHT + 20; // Start below screen
          this.size = getRandom(3, 8);
          this.speed = getRandom(2, 3.5);
          this.opacity = getRandom(0.2, 0.4);
          this.wobbleAmount = getRandom(0.1, 0.3);
          this.wobbleSpeed = getRandom(0.02, 0.05);
          this.wobbleOffset = getRandom(0, Math.PI * 2);
        }

        update(deltaTime) {
          this.y -= this.speed * deltaTime * 60;
          this.x +=
            Math.sin(this.wobbleOffset + performance.now() * this.wobbleSpeed) *
            this.wobbleAmount *
            deltaTime *
            60;

          // Reset if above screen
          if (this.y < -20) {
            this.reset();
          }
        }

        draw(ctx) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.fill();
        }
      }

      // ---------------------------------------------
      // Explosion class for player death effect
      // ---------------------------------------------
      class Explosion {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.particles = [];
          this.life = 1.0;
          this.fadeSpeed = 0.02;
          this.isComplete = false;

          // Create explosion particles
          const particleCount = Math.floor(size * 0.5);
          for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const speed = getRandom(2, 4);
            this.particles.push({
              x: 0,
              y: 0,
              speedX: Math.cos(angle) * speed,
              speedY: Math.sin(angle) * speed,
              size: getRandom(3, 8),
              life: 1.0,
              fadeSpeed: getRandom(0.01, 0.03),
            });
          }
        }

        update(deltaTime) {
          if (this.isComplete) return;

          this.life -= this.fadeSpeed * deltaTime * 60;

          // Update particles
          for (const particle of this.particles) {
            particle.x += particle.speedX * deltaTime * 60;
            particle.y += particle.speedY * deltaTime * 60;
            particle.life -= particle.fadeSpeed * deltaTime * 60;
          }

          if (this.life <= 0) {
            this.isComplete = true;
          }
        }

        draw(ctx) {
          if (this.life <= 0) return;

          for (const particle of this.particles) {
            if (particle.life <= 0) continue;

            ctx.beginPath();
            ctx.arc(
              this.x + particle.x,
              this.y + particle.y,
              particle.size,
              0,
              Math.PI * 2
            );
            ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.8})`;
            ctx.fill();
          }
        }
      }

      // ---------------------------------------------
      // Spawn enemy fish
      // ---------------------------------------------
      function spawnFish() {
        const chosenType = getRandomWeightedFishType(fishTypes);
        const fishSize = getRandom(chosenType.minSize, chosenType.maxSize);
        const fromLeft = Math.random() < 0.5;
        const x = fromLeft ? -fishSize : WIDTH;
        const y = getRandom(0, HEIGHT - fishSize);

        const sizeFactor = 1 - fishSize / 500;
        const minSpeed = 0.3 + 0.5 * sizeFactor;
        const maxSpeed = 1.5 + 0.3 * sizeFactor;
        let baseSpeed = getRandom(minSpeed, maxSpeed);

        // Determine fish type
        const isUltraFast = Math.random() < 0.01; // 1% chance for ultra-fast
        const isFast = !isUltraFast && Math.random() < 0.03; // 3% chance for fast

        if (isUltraFast) {
          baseSpeed *= 5;
        } else if (isFast) {
          baseSpeed *= 3;
        }

        const speedX = fromLeft ? baseSpeed : -baseSpeed;

        const enemy = new Fish(
          x,
          y,
          speedX,
          0,
          chosenType.image,
          fishSize,
          false
        );
        enemy.isFast = isFast;
        enemy.isUltraFast = isUltraFast;
        fishList.push(enemy);
      }

      function checkCollisionOval(a, b) {
        const A = a.getBounds();
        const B = b.getBounds();

        // Calculate the distance between centers
        const dx = A.centerX - B.centerX;
        const dy = A.centerY - B.centerY;

        // Calculate the sum of the radii
        const sumRadiiX = A.radiusX + B.radiusX;
        const sumRadiiY = A.radiusY + B.radiusY;

        // Check if the distance is less than the sum of the radii
        return (
          (dx * dx) / (sumRadiiX * sumRadiiX) +
            (dy * dy) / (sumRadiiY * sumRadiiY) <=
          1
        );
      }

      // Function to spawn a group of bubbles
      function spawnBubbleGroup() {
        const groupSize = Math.floor(getRandom(3, 5)); // 3-4 bubbles
        const baseX = getRandom(50, WIDTH - 50);

        for (let i = 0; i < groupSize; i++) {
          if (bubbles.length < 8) {
            bubbles.push(new Bubble(baseX));
          }
        }
      }

      // ---------------------------------------------
      // updateGame (with fix to let explosion animate)
      // ---------------------------------------------
      function updateGame(deltaTime) {
        // Always update the explosion if it exists, even if gameState = "over"
        if (explosion) {
          explosion.update(deltaTime);
          if (explosion.isComplete) {
            explosion = null;
            showGameOverScreen(score);
            return; // After explosion completes, show game-over
          }
        }

        // If not in "playing" mode, skip the normal gameplay updates
        if (gameState !== "playing") return;

        // If game is over and there's no explosion, skip updates (fallback)
        if (isGameOver && !explosion) {
          return;
        }

        // Update bubbles
        for (const bubble of bubbles) {
          bubble.update(deltaTime);
        }

        // Update water trails
        for (let i = waterTrails.length - 1; i >= 0; i--) {
          const trail = waterTrails[i];
          trail.update(deltaTime);
          if (trail.life <= 0) {
            waterTrails.splice(i, 1);
          }
        }

        // Create water trails for player
        if (player) {
          player.createWaterTrail();
        }

        // Create water trails for enemies
        for (const fish of fishList) {
          fish.createWaterTrail();
        }

        // Spawn new bubble groups occasionally
        if (Math.random() < 0.002 * deltaTime * 60 && bubbles.length < 5) {
          spawnBubbleGroup();
        }

        // Movement controls
        const accel = player.acceleration * deltaTime * 60;
        if (keys.left) player.velocityX -= accel;
        if (keys.right) player.velocityX += accel;
        if (keys.up) player.velocityY -= accel;
        if (keys.down) player.velocityY += accel;

        // Touch/mouse movement
        if (touchTarget && player.width && player.height) {
          const px = player.x + player.width / 2;
          const py = player.y + player.height / 2;
          const dx = touchTarget.x - px;
          const dy = touchTarget.y - py;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 1) {
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;
            player.velocityX += ax;
            player.velocityY += ay;
          }
        }

        // Limit top speed
        const spd = Math.sqrt(player.velocityX ** 2 + player.velocityY ** 2);
        if (spd > player.maxSpeed) {
          const ratio = player.maxSpeed / spd;
          player.velocityX *= ratio;
          player.velocityY *= ratio;
        }

        // Update player
        player.update(deltaTime);

        // Update enemies
        for (let i = fishList.length - 1; i >= 0; i--) {
          const enemy = fishList[i];
          enemy.update(deltaTime);

          // Remove if off-screen
          const bounds = enemy.getBounds();
          if (
            bounds.centerX + bounds.radiusX < -200 ||
            bounds.centerX - bounds.radiusX > WIDTH + 200
          ) {
            fishList.splice(i, 1);
            continue;
          }

          // Collision check
          if (checkCollisionOval(player, enemy)) {
            // Compare bounding ellipse sizes
            if (player.getBounds().radiusX > enemy.getBounds().radiusX) {
              // Player eats smaller fish
              score += calculateFishScore(enemy.maxSide);
              const baseGrowth = Math.sqrt(enemy.maxSide) * 0.05;
              const growthAmount = Math.min(baseGrowth, 1.5);
              player.maxSide += growthAmount;
              player.width = null;
              player.height = null;

              // Play eat sound
              playEatSound();

              fishList.splice(i, 1);
            } else {
              // Game over
              console.log("Game Over triggered! Score:", score);
              isGameOver = true;
              gameState = "over";
              sendScoreToAPI(score);

              // Create explosion at player position
              if (player.width && player.height) {
                explosion = new Explosion(
                  player.x + player.width / 2,
                  player.y + player.height / 2,
                  player.maxSide
                );
              }
              return;
            }
          }
        }

        // Spawn fish occasionally
        if (Math.random() < 0.03 * deltaTime * 60 && fishList.length < 30) {
          spawnFish();
        }
      }

      // ---------------------------------------------
      // renderGame
      // ---------------------------------------------
      function renderGame() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        // Draw bubbles first
        for (const bubble of bubbles) {
          bubble.draw(ctx);
        }

        // Draw water trails
        for (const trail of waterTrails) {
          trail.draw(ctx);
        }

        // Draw the player if not in explosion
        if (player && !explosion) {
          player.draw(ctx);
        }

        // Draw enemies
        for (const fish of fishList) {
          fish.draw(ctx);
        }

        // Draw explosion if it exists
        if (explosion) {
          explosion.draw(ctx);
        }

        // Score text
        ctx.fillStyle = "#fff";
        ctx.font = "20px Londrina Solid, sans-serif";
        ctx.fillText("Score: " + score, 20, 30);

        // Draw touch indicator
        if (touchTarget) {
          ctx.beginPath();
          ctx.arc(touchTarget.x, touchTarget.y, 15, 0, Math.PI * 2);
          ctx.strokeStyle = "#ffffff88";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // ---------------------------------------------
      // gameLoop with deltaTime
      // ---------------------------------------------
      let lastTime = 0;
      function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        updateGame(deltaTime);
        renderGame();

        requestAnimationFrame(gameLoop);
      }

      // ---------------------------------------------
      // initGame: reset all main variables
      // ---------------------------------------------
      function initGame() {
        resizeCanvas();
        score = 0;
        isGameOver = false;
        fishList = [];
        bubbles = [];
        waterTrails = [];
        player = new Fish(WIDTH / 2, HEIGHT / 2, 0, 0, playerImg, 25, true);

        // Initialize audio immediately
        initAudio();

        // Spawn a few fish initially
        for (let i = 0; i < 3; i++) {
          spawnFish();
        }

        // Spawn an initial bubble group
        spawnBubbleGroup();
      }

      // ---------------------------------------------
      // Start & Replay handling
      // ---------------------------------------------
      startBtn.onclick = () => {
        hideStartScreen();
        gameState = "playing";
        initGame();
      };
      playAgainBtn.onclick = () => {
        hideGameOverScreen();
        gameState = "playing";
        initGame();
      };

      // ---------------------------------------------------------
      // Touch & Mouse event handlers
      // ---------------------------------------------------------
      canvas.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        if (touch) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("touchmove", (e) => {
        const touch = e.touches[0];
        if (touch) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("touchend", () => {
        touchTarget = null;
      });

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        touchTarget = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      });
      canvas.addEventListener("mousemove", (e) => {
        if (e.buttons > 0) {
          const rect = canvas.getBoundingClientRect();
          touchTarget = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        }
      });
      canvas.addEventListener("mouseup", () => {
        touchTarget = null;
      });

      // Keyboard events
      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = true;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = true;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = true;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a") keys.left = false;
        if (e.key === "ArrowRight" || e.key === "d") keys.right = false;
        if (e.key === "ArrowUp" || e.key === "w") keys.up = false;
        if (e.key === "ArrowDown" || e.key === "s") keys.down = false;
      });

      // ---------------------------------------------------------
      // Wait for images to load, then start the animation loop.
      // ---------------------------------------------------------
      Promise.all([
        new Promise((resolve) => (playerImg.onload = resolve)),
        ...fishTypes.map(
          ({ image }) => new Promise((resolve) => (image.onload = resolve))
        ),
      ]).then(() => {
        resizeCanvas();
        showStartScreen();

        // Initialize audio (but don't start playing yet)
        initAudio();

        // Add sound button event listener
        document.getElementById("soundBtn").onclick = toggleSound;

        // Let the user click anywhere on start screen to unlock audio on mobile
        document
          .getElementById("startScreen")
          .addEventListener("click", function firstInteraction() {
            startAudio();
            this.removeEventListener("click", firstInteraction);
          });

        // Also try to start on any mouse movement
        document.addEventListener("mousemove", function firstInteraction() {
          startAudio();
          document.removeEventListener("mousemove", firstInteraction);
        });

        requestAnimationFrame(gameLoop);
      });
    </script>
  </body>
</html>
